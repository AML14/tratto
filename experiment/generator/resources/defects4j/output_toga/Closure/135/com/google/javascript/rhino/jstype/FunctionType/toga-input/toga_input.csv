focal_method,test_prefix,docstring
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test000() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""...["", (Node) null);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a type name"", functionType0);
    functionType0.getLeastSupertype(enumType0);
    assertTrue(functionType0.hasCachedValues());
}",""
"public FunctionType(JSTypeRegistry registry, String name, Node source, Node parameters, JSType returnType, ObjectType typeOfThis) {
    this(registry, name, source, parameters, returnType, typeOfThis, null, false, false);
}","public void test011() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newNumber((double) 105);
    HashMap<String, JSType> hashMap0 = new HashMap<String, JSType>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ObjectType objectType0 = recordType0.getImplicitPrototype();
    FunctionType functionType0 = null;
    try {
        functionType0 = new FunctionType(jSTypeRegistry0, ""kh"", node0, node0, objectType0, recordType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates a function type.
 * @param registry the owner registry for this type
 * @param name the function's name or {@code null} to indicate that the
 *        function is anonymous.
 * @param source the node defining this function. Its type
 *        ({@link Node#getType()}) must be {@link Token#FUNCTION}.
 * @param parameters the function's parameters or {@code null}
 *        to indicate that the parameter types are unknown.
 * @param returnType the function's return type or {@code null} to indicate
 *        that the return type is unknown.
 * @param typeOfThis The type of {@code this} in non-constructors.  May be
 *        {@code null} to indicate that the type of {@code this} is unknown.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test022() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(noObjectType0, noObjectType0);
    noObjectType0.getGreatestSubtype(functionType0);
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test023() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(noObjectType0, noObjectType0);
    noObjectType0.getGreatestSubtype(functionType0);
    assertFalse(noObjectType0.isInterface());
}",""
"public boolean hasEqualCallType(FunctionType otherType) {
    return this.call.equals(otherType.call);
}","public void test034() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    boolean boolean0 = errorFunctionType0.hasEqualCallType(noType0);
    assertFalse(boolean0);
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test035() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    boolean boolean0 = errorFunctionType0.hasEqualCallType(noType0);
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test036() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    boolean boolean0 = errorFunctionType0.hasEqualCallType(noType0);
    assertFalse(errorFunctionType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test047() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    noObjectType0.isInstanceType();
    assertFalse(noObjectType0.isInterface());
}",""
"@Override
public boolean canBeCalled() {
    return referencedType.canBeCalled();
}","public void test058() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noType0, noType0);
    boolean boolean0 = indexedType0.canBeCalled();
    assertTrue(boolean0);
}",""
"@Override
public boolean isInterface() {
    return referencedType.isInterface();
}","public void test059() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noType0, noType0);
    boolean boolean0 = indexedType0.canBeCalled();
    assertFalse(indexedType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test0610() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""kD\""{IAk[z3~.y6V@A"");
    Node node0 = errorFunctionType0.getSource();
    assertFalse(errorFunctionType0.isInterface());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test0611() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""kD\""{IAk[z3~.y6V@A"");
    Node node0 = errorFunctionType0.getSource();
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public Node getSource() {
    return source;
}","public void test0612() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""kD\""{IAk[z3~.y6V@A"");
    Node node0 = errorFunctionType0.getSource();
    assertNull(node0);
}","/**
 * Gets the source node.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test0713() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    noType0.setSource((Node) null);
    assertFalse(noType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test0814() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    noObjectType0.getSubTypes();
    assertFalse(noObjectType0.isInterface());
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test0915() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newNumber((double) 105);
    Node node1 = new Node(105, node0, node0, node0);
    HashMap<String, JSType> hashMap0 = new HashMap<String, JSType>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ObjectType objectType0 = recordType0.getImplicitPrototype();
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""kh"", node1, node0, objectType0, recordType0);
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test0916() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newNumber((double) 105);
    Node node1 = new Node(105, node0, node0, node0);
    HashMap<String, JSType> hashMap0 = new HashMap<String, JSType>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ObjectType objectType0 = recordType0.getImplicitPrototype();
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""kh"", node1, node0, objectType0, recordType0);
    assertEquals(0, functionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public String getTemplateTypeName() {
    return templateTypeName;
}","public void test1017() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Rm(9:|z(q-Kyz1~J"", (Node) null);
    FunctionType functionType1 = new FunctionType(jSTypeRegistry0, ""Rm(9:|z(q-Kyz1~J"", (Node) null, (Node) null, functionType0, functionType0, ""RANGE_ERROR_FUNCTION_TYPE"", true, true);
    assertEquals(""RANGE_ERROR_FUNCTION_TYPE"", functionType1.getTemplateTypeName());
}","/**
 * Gets the template type name.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test1018() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Rm(9:|z(q-Kyz1~J"", (Node) null);
    FunctionType functionType1 = new FunctionType(jSTypeRegistry0, ""Rm(9:|z(q-Kyz1~J"", (Node) null, (Node) null, functionType0, functionType0, ""RANGE_ERROR_FUNCTION_TYPE"", true, true);
    assertFalse(functionType1.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test1119() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = new Node(105);
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""Not declared as a constructor"", node0);
    assertFalse(functionType0.hasCachedValues());
}",""
"FunctionType(JSTypeRegistry registry, String name, Node source) {
    super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE));
    Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType());
    Preconditions.checkArgument(name != null);
    this.source = source;
    this.call = null;
    this.kind = Kind.INTERFACE;
    this.typeOfThis = new InstanceObjectType(registry, this);
}","public void test1220() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = new Node(0);
    FunctionType functionType0 = null;
    try {
        functionType0 = new FunctionType(jSTypeRegistry0, ""Unknown class name"", node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates an instance for a function that is an interface.
 */"
"public FunctionType createInterfaceType(String name, Node source) {
    return new FunctionType(this, name, source);
}","public void test1321() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    // Undeclared exception!
    try {
        jSTypeRegistry0.createInterfaceType((String) null, (Node) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates an interface function type.
 * @param name the function's name
 * @param source the node defining this function. Its type
 *     ({@link Node#getType()}) must be {@link Token#FUNCTION}.
 */"
"public boolean hasUnknownSupertype() {
    Preconditions.checkArgument(isConstructor() || isInterface());
    Preconditions.checkArgument(!this.isUnknownType());
    // Potential infinite loop if our type system messes up or someone defines
    // a bad type. Otherwise the loop should always end.
    FunctionType ctor = this;
    while (true) {
        ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype();
        if (maybeSuperInstanceType == null) {
            return false;
        }
        if (maybeSuperInstanceType.isUnknownType()) {
            return true;
        }
        ctor = maybeSuperInstanceType.getConstructor();
        if (ctor == null) {
            return false;
        }
        Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());
    }
}","public void test1422() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Z)=s,\""ts=aRi"", (Node) null);
    boolean boolean0 = functionType0.hasUnknownSupertype();
    assertFalse(boolean0);
}","/**
 * Given a constructor or an interface type, find out whether the unknown
 * type is a supertype of the current type.
 */"
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test1423() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Z)=s,\""ts=aRi"", (Node) null);
    boolean boolean0 = functionType0.hasUnknownSupertype();
    assertFalse(functionType0.isConstructor());
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test1524() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = noType0.isOrdinaryFunction();
    assertFalse(boolean0);
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test1525() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = noType0.isOrdinaryFunction();
    assertFalse(noType0.isInterface());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test1626() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[6];
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) booleanType0, jSTypeArray0);
    FunctionPrototypeType functionPrototypeType0 = functionType0.getPrototype();
    FunctionType functionType1 = new FunctionType(jSTypeRegistry0, "";$}Pr6#< H)~`3"", (Node) null, (Node) null, functionPrototypeType0, functionPrototypeType0, ""Not declared as a type name"", false, false);
    boolean boolean0 = functionType1.isOrdinaryFunction();
    assertEquals(6, functionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test1627() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[6];
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) booleanType0, jSTypeArray0);
    FunctionPrototypeType functionPrototypeType0 = functionType0.getPrototype();
    FunctionType functionType1 = new FunctionType(jSTypeRegistry0, "";$}Pr6#< H)~`3"", (Node) null, (Node) null, functionPrototypeType0, functionPrototypeType0, ""Not declared as a type name"", false, false);
    boolean boolean0 = functionType1.isOrdinaryFunction();
    assertFalse(functionType1.isInterface());
}",""
"public String getTemplateTypeName() {
    return templateTypeName;
}","public void test1628() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[6];
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) booleanType0, jSTypeArray0);
    FunctionPrototypeType functionPrototypeType0 = functionType0.getPrototype();
    FunctionType functionType1 = new FunctionType(jSTypeRegistry0, "";$}Pr6#< H)~`3"", (Node) null, (Node) null, functionPrototypeType0, functionPrototypeType0, ""Not declared as a type name"", false, false);
    boolean boolean0 = functionType1.isOrdinaryFunction();
    assertEquals(""Not declared as a type name"", functionType1.getTemplateTypeName());
}","/**
 * Gets the template type name.
 */"
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test1629() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[6];
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) booleanType0, jSTypeArray0);
    FunctionPrototypeType functionPrototypeType0 = functionType0.getPrototype();
    FunctionType functionType1 = new FunctionType(jSTypeRegistry0, "";$}Pr6#< H)~`3"", (Node) null, (Node) null, functionPrototypeType0, functionPrototypeType0, ""Not declared as a type name"", false, false);
    boolean boolean0 = functionType1.isOrdinaryFunction();
    assertTrue(boolean0);
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test1630() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[6];
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) booleanType0, jSTypeArray0);
    FunctionPrototypeType functionPrototypeType0 = functionType0.getPrototype();
    FunctionType functionType1 = new FunctionType(jSTypeRegistry0, "";$}Pr6#< H)~`3"", (Node) null, (Node) null, functionPrototypeType0, functionPrototypeType0, ""Not declared as a type name"", false, false);
    boolean boolean0 = functionType1.isOrdinaryFunction();
    assertTrue(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test1731() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    int int0 = noType0.getMinArguments();
    assertFalse(noType0.isInterface());
}",""
"public int getMinArguments() {
    // NOTE(nicksantos): There are some native functions that have optional
    // parameters before required parameters. This algorithm finds the position
    // of the last required parameter.
    int i = 0;
    int min = 0;
    for (Node n : getParameters()) {
        i++;
        if (!n.isOptionalArg() && !n.isVarArgs()) {
            min = i;
        }
    }
    return min;
}","public void test1732() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    int int0 = noType0.getMinArguments();
    assertEquals(0, int0);
}","/**
 * Gets the minimum number of arguments that this function requires.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test1833() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    int int0 = errorFunctionType0.getMinArguments();
    assertFalse(errorFunctionType0.isInterface());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test1834() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    int int0 = errorFunctionType0.getMinArguments();
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public int getMinArguments() {
    // NOTE(nicksantos): There are some native functions that have optional
    // parameters before required parameters. This algorithm finds the position
    // of the last required parameter.
    int i = 0;
    int min = 0;
    for (Node n : getParameters()) {
        i++;
        if (!n.isOptionalArg() && !n.isVarArgs()) {
            min = i;
        }
    }
    return min;
}","public void test1835() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    int int0 = errorFunctionType0.getMinArguments();
    assertEquals(0, int0);
}","/**
 * Gets the minimum number of arguments that this function requires.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test1936() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, "")"", (Node) null);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(functionType0, functionType0);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public int getMinArguments() {
    // NOTE(nicksantos): There are some native functions that have optional
    // parameters before required parameters. This algorithm finds the position
    // of the last required parameter.
    int i = 0;
    int min = 0;
    for (Node n : getParameters()) {
        i++;
        if (!n.isOptionalArg() && !n.isVarArgs()) {
            min = i;
        }
    }
    return min;
}","public void test2037() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    int int0 = functionType0.getMinArguments();
    assertEquals(0, int0);
}","/**
 * Gets the minimum number of arguments that this function requires.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test2038() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    int int0 = functionType0.getMinArguments();
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public int getMinArguments() {
    // NOTE(nicksantos): There are some native functions that have optional
    // parameters before required parameters. This algorithm finds the position
    // of the last required parameter.
    int i = 0;
    int min = 0;
    for (Node n : getParameters()) {
        i++;
        if (!n.isOptionalArg() && !n.isVarArgs()) {
            min = i;
        }
    }
    return min;
}","public void test2139() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    JSType[] jSTypeArray0 = new JSType[4];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, false, jSTypeArray0);
    int int0 = functionType0.getMinArguments();
    assertEquals(4, int0);
}","/**
 * Gets the minimum number of arguments that this function requires.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test2140() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    JSType[] jSTypeArray0 = new JSType[4];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, false, jSTypeArray0);
    int int0 = functionType0.getMinArguments();
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test2241() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    int int0 = noType0.getMaxArguments();
    assertFalse(noType0.isInterface());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test2242() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    int int0 = noType0.getMaxArguments();
    assertEquals(Integer.MAX_VALUE, int0);
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test2343() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    int int0 = functionType0.getMaxArguments();
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test2344() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    int int0 = functionType0.getMaxArguments();
    assertEquals(Integer.MAX_VALUE, int0);
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test2445() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) noType0, (List<JSType>) linkedList0);
    int int0 = functionType0.getMaxArguments();
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test2446() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) noType0, (List<JSType>) linkedList0);
    int int0 = functionType0.getMaxArguments();
    assertEquals(0, int0);
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test2547() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""apply"");
    int int0 = errorFunctionType0.getMaxArguments();
    assertEquals(3, int0);
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test2548() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""apply"");
    int int0 = errorFunctionType0.getMaxArguments();
    assertFalse(errorFunctionType0.isInterface());
}",""
"public boolean hasUnknownSupertype() {
    Preconditions.checkArgument(isConstructor() || isInterface());
    Preconditions.checkArgument(!this.isUnknownType());
    // Potential infinite loop if our type system messes up or someone defines
    // a bad type. Otherwise the loop should always end.
    FunctionType ctor = this;
    while (true) {
        ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype();
        if (maybeSuperInstanceType == null) {
            return false;
        }
        if (maybeSuperInstanceType.isUnknownType()) {
            return true;
        }
        ctor = maybeSuperInstanceType.getConstructor();
        if (ctor == null) {
            return false;
        }
        Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());
    }
}","public void test2649() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) null, (List<JSType>) linkedList0);
    // Undeclared exception!
    try {
        functionType0.hasUnknownSupertype();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Given a constructor or an interface type, find out whether the unknown
 * type is a supertype of the current type.
 */"
"public boolean hasUnknownSupertype() {
    Preconditions.checkArgument(isConstructor() || isInterface());
    Preconditions.checkArgument(!this.isUnknownType());
    // Potential infinite loop if our type system messes up or someone defines
    // a bad type. Otherwise the loop should always end.
    FunctionType ctor = this;
    while (true) {
        ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype();
        if (maybeSuperInstanceType == null) {
            return false;
        }
        if (maybeSuperInstanceType.isUnknownType()) {
            return true;
        }
        ctor = maybeSuperInstanceType.getConstructor();
        if (ctor == null) {
            return false;
        }
        Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());
    }
}","public void test2750() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = noType0.hasUnknownSupertype();
    assertFalse(boolean0);
}","/**
 * Given a constructor or an interface type, find out whether the unknown
 * type is a supertype of the current type.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test2751() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = noType0.hasUnknownSupertype();
    noType0.setPrototypeBasedOn(noType0);
    assertFalse(noType0.isInterface());
}",""
"public boolean setPrototype(FunctionPrototypeType prototype) {
    if (prototype == null) {
        return false;
    }
    // getInstanceType fails if the function is not a constructor
    if (isConstructor() && prototype == getInstanceType()) {
        return false;
    }
    this.prototype = prototype;
    if (isConstructor() || isInterface()) {
        FunctionType superClass = getSuperClassConstructor();
        if (superClass != null) {
            superClass.addSubType(this);
        }
    }
    return true;
}","public void test2852() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = noType0.setPrototype((FunctionPrototypeType) null);
    assertFalse(boolean0);
}","/**
 * Sets the prototype.
 * @param prototype the prototype. If this value is {@code null} it will
 *        silently be discarded.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test2853() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = noType0.setPrototype((FunctionPrototypeType) null);
    assertFalse(noType0.isInterface());
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test2954() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    functionType0.getPrototype();
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public Iterable<ObjectType> getAllImplementedInterfaces() {
    Set<ObjectType> interfaces = Sets.newHashSet();
    for (ObjectType type : getImplementedInterfaces()) {
        addRelatedInterfaces(type, interfaces);
    }
    return interfaces;
}","public void test3055() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    LinkedList<ObjectType> linkedList0 = new LinkedList<ObjectType>();
    linkedList0.add((ObjectType) functionType0);
    functionType0.setImplementedInterfaces(linkedList0);
    Iterable<ObjectType> iterable0 = functionType0.getAllImplementedInterfaces();
    assertNotNull(iterable0);
}","/**
 * Returns all interfaces implemented by a class or its superclass and any
 * superclasses for any of those interfaces. If this is called before all
 * types are resolved, it may return an incomplete set.
 */"
"public Iterable<ObjectType> getAllImplementedInterfaces() {
    Set<ObjectType> interfaces = Sets.newHashSet();
    for (ObjectType type : getImplementedInterfaces()) {
        addRelatedInterfaces(type, interfaces);
    }
    return interfaces;
}","public void test3156() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    LinkedList<ObjectType> linkedList0 = new LinkedList<ObjectType>();
    linkedList0.add((ObjectType) functionType0);
    functionType0.setImplementedInterfaces(linkedList0);
    functionType0.resolve(simpleErrorReporter0, (StaticScope<JSType>) null);
    Iterable<ObjectType> iterable0 = functionType0.getAllImplementedInterfaces();
    assertNotNull(iterable0);
}","/**
 * Returns all interfaces implemented by a class or its superclass and any
 * superclasses for any of those interfaces. If this is called before all
 * types are resolved, it may return an incomplete set.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test3257() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, "")"", (Node) null);
    functionType0.getAllImplementedInterfaces();
    assertFalse(functionType0.hasCachedValues());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test3358() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""J,1RStX!tR*&=H"");
    boolean boolean0 = errorFunctionType0.hasProperty(""prototype"");
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean hasProperty(String name) {
    return super.hasProperty(name) || ""prototype"".equals(name);
}","public void test3359() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""J,1RStX!tR*&=H"");
    boolean boolean0 = errorFunctionType0.hasProperty(""prototype"");
    assertTrue(boolean0);
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test3360() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""J,1RStX!tR*&=H"");
    boolean boolean0 = errorFunctionType0.hasProperty(""prototype"");
    assertFalse(errorFunctionType0.isInterface());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test3461() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    errorFunctionType0.defineInferredProperty(""valueOf"", noType0, true);
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""valueOf"");
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean isPropertyTypeInferred(String property) {
    return ""prototype"".equals(property) || super.isPropertyTypeInferred(property);
}","public void test3462() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    errorFunctionType0.defineInferredProperty(""valueOf"", noType0, true);
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""valueOf"");
    assertTrue(boolean0);
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test3463() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    errorFunctionType0.defineInferredProperty(""valueOf"", noType0, true);
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""valueOf"");
    assertFalse(errorFunctionType0.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test3564() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""apply"");
    errorFunctionType0.getPropertyType(""apply"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test3665() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""prototype"");
    errorFunctionType0.getPropertyType(""prototype"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test3766() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    errorFunctionType0.getPropertyType(""call"");
    errorFunctionType0.getPropertyType(""call"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test3867() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((String) null, (Node) null, (Node) null, (JSType) objectType0);
    FunctionType functionType1 = (FunctionType) functionType0.getPropertyType(""call"");
    assertFalse(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test3868() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((String) null, (Node) null, (Node) null, (JSType) objectType0);
    FunctionType functionType1 = (FunctionType) functionType0.getPropertyType(""call"");
    assertFalse(functionType1.hasCachedValues());
}",""
"@Override
public boolean equals(Object otherType) {
    if (!(otherType instanceof FunctionType)) {
        return false;
    }
    FunctionType that = (FunctionType) otherType;
    if (!that.isFunctionType()) {
        return false;
    }
    if (this.isConstructor()) {
        if (that.isConstructor()) {
            return this == that;
        }
        return false;
    }
    if (this.isInterface()) {
        if (that.isInterface()) {
            return this.getReferenceName().equals(that.getReferenceName());
        }
        return false;
    }
    if (that.isInterface()) {
        return false;
    }
    return this.typeOfThis.equals(that.typeOfThis) && this.call.equals(that.call);
}","public void test3869() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((String) null, (Node) null, (Node) null, (JSType) objectType0);
    FunctionType functionType1 = (FunctionType) functionType0.getPropertyType(""call"");
    assertFalse(functionType1.equals((Object) functionType0));
}","/**
 * Two function types are equal if their signatures match. Since they don't
 * have signatures, two interfaces are equal if their names match.
 */"
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test3870() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((String) null, (Node) null, (Node) null, (JSType) objectType0);
    FunctionType functionType1 = (FunctionType) functionType0.getPropertyType(""call"");
    assertFalse(functionType0.isOrdinaryFunction());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test3971() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.FunctionType"");
    errorFunctionType0.getPropertyType(""eR&oR"");
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test3972() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.FunctionType"");
    errorFunctionType0.getPropertyType(""eR&oR"");
    assertFalse(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test3973() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.FunctionType"");
    errorFunctionType0.getPropertyType(""eR&oR"");
    assertFalse(errorFunctionType0.isInterface());
}",""
"@Override
boolean defineProperty(String name, JSType type, boolean inferred, boolean inExterns) {
    if (""prototype"".equals(name)) {
        ObjectType objType = type.toObjectType();
        if (objType != null) {
            return setPrototype(new FunctionPrototypeType(registry, this, objType, isNativeObjectType()));
        } else {
            return false;
        }
    }
    return super.defineProperty(name, type, inferred, inExterns);
}","public void test4074() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.FunctionType"");
    boolean boolean0 = errorFunctionType0.defineProperty(""prototype"", numberType0, false, false);
    assertFalse(boolean0);
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test4075() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.FunctionType"");
    boolean boolean0 = errorFunctionType0.defineProperty(""prototype"", numberType0, false, false);
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test4076() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.FunctionType"");
    boolean boolean0 = errorFunctionType0.defineProperty(""prototype"", numberType0, false, false);
    assertFalse(errorFunctionType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test4177() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""prototype"");
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""prototype"");
    assertFalse(errorFunctionType0.isInterface());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test4178() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""prototype"");
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""prototype"");
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean isPropertyTypeInferred(String property) {
    return ""prototype"".equals(property) || super.isPropertyTypeInferred(property);
}","public void test4179() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""prototype"");
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""prototype"");
    assertTrue(boolean0);
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test4280() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""valueOf"");
    assertFalse(errorFunctionType0.isInterface());
}",""
"@Override
public boolean isPropertyTypeInferred(String property) {
    return ""prototype"".equals(property) || super.isPropertyTypeInferred(property);
}","public void test4281() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""valueOf"");
    assertFalse(boolean0);
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test4282() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""valueOf"");
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4383() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""akG9UF"", (Node) null);
    functionType0.getLeastSupertype(functionType0);
    assertTrue(functionType0.hasCachedValues());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test4484() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""tGx/("", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    functionType1.getLeastSupertype(functionType0);
    assertEquals(0, functionType1.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test4485() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""tGx/("", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    functionType1.getLeastSupertype(functionType0);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4486() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""tGx/("", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    functionType1.getLeastSupertype(functionType0);
    assertFalse(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4587() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    errorFunctionType0.getLeastSupertype(functionType0);
    assertFalse(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test4588() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    errorFunctionType0.getLeastSupertype(functionType0);
    assertFalse(errorFunctionType0.isInterface());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test4589() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    errorFunctionType0.getLeastSupertype(functionType0);
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test4690() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = (FunctionType) jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) functionType0, (JSType) functionType0, (List<JSType>) linkedList0);
    functionType0.getLeastSupertype(functionType1);
    assertEquals(0, functionType1.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test4691() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = (FunctionType) jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) functionType0, (JSType) functionType0, (List<JSType>) linkedList0);
    functionType0.getLeastSupertype(functionType1);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4692() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = (FunctionType) jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) functionType0, (JSType) functionType0, (List<JSType>) linkedList0);
    functionType0.getLeastSupertype(functionType1);
    assertFalse(functionType1.hasCachedValues());
}",""
"@Override
public boolean equals(Object otherType) {
    if (!(otherType instanceof FunctionType)) {
        return false;
    }
    FunctionType that = (FunctionType) otherType;
    if (!that.isFunctionType()) {
        return false;
    }
    if (this.isConstructor()) {
        if (that.isConstructor()) {
            return this == that;
        }
        return false;
    }
    if (this.isInterface()) {
        if (that.isInterface()) {
            return this.getReferenceName().equals(that.getReferenceName());
        }
        return false;
    }
    if (that.isInterface()) {
        return false;
    }
    return this.typeOfThis.equals(that.typeOfThis) && this.call.equals(that.call);
}","public void test4693() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = (FunctionType) jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) functionType0, (JSType) functionType0, (List<JSType>) linkedList0);
    functionType0.getLeastSupertype(functionType1);
    assertFalse(functionType0.equals((Object) functionType1));
}","/**
 * Two function types are equal if their signatures match. Since they don't
 * have signatures, two interfaces are equal if their names match.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4794() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.FunctionType$Kind"", (Node) null);
    functionType0.getGreatestSubtype(functionType0);
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4895() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    JSType jSType0 = errorFunctionType0.getLeastSupertype(functionType0);
    FunctionType functionType1 = (FunctionType) functionType0.getGreatestSubtype(jSType0);
    assertFalse(functionType1.hasCachedValues());
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test4896() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    JSType jSType0 = errorFunctionType0.getLeastSupertype(functionType0);
    FunctionType functionType1 = (FunctionType) functionType0.getGreatestSubtype(jSType0);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test4897() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    JSType jSType0 = errorFunctionType0.getLeastSupertype(functionType0);
    FunctionType functionType1 = (FunctionType) functionType0.getGreatestSubtype(jSType0);
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4898() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    JSType jSType0 = errorFunctionType0.getLeastSupertype(functionType0);
    FunctionType functionType1 = (FunctionType) functionType0.getGreatestSubtype(jSType0);
    assertFalse(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4999() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    functionType0.getGreatestSubtype(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test49100() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    functionType0.getGreatestSubtype(errorFunctionType0);
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public FunctionType getSuperClassConstructor() {
    Preconditions.checkArgument(isConstructor() || isInterface());
    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();
    if (maybeSuperInstanceType == null) {
        return null;
    }
    return maybeSuperInstanceType.getConstructor();
}","public void test50101() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    // Undeclared exception!
    try {
        functionType0.getSuperClassConstructor();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Given a constructor or an interface type, get its superclass constructor
 * or {@code null} if none exists.
 */"
"public boolean hasUnknownSupertype() {
    Preconditions.checkArgument(isConstructor() || isInterface());
    Preconditions.checkArgument(!this.isUnknownType());
    // Potential infinite loop if our type system messes up or someone defines
    // a bad type. Otherwise the loop should always end.
    FunctionType ctor = this;
    while (true) {
        ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype();
        if (maybeSuperInstanceType == null) {
            return false;
        }
        if (maybeSuperInstanceType.isUnknownType()) {
            return true;
        }
        ctor = maybeSuperInstanceType.getConstructor();
        if (ctor == null) {
            return false;
        }
        Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());
    }
}","public void test51102() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    noType0.setPrototypeBasedOn((ObjectType) null);
    boolean boolean0 = noType0.hasUnknownSupertype();
    assertFalse(boolean0);
}","/**
 * Given a constructor or an interface type, find out whether the unknown
 * type is a supertype of the current type.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test51103() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    noType0.setPrototypeBasedOn((ObjectType) null);
    boolean boolean0 = noType0.hasUnknownSupertype();
    assertFalse(noType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test52104() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Unknown class name"", 0, 1);
    noType0.setPrototypeBasedOn(namedType0);
    boolean boolean0 = noType0.hasUnknownSupertype();
    assertFalse(noType0.isInterface());
}",""
"public boolean hasUnknownSupertype() {
    Preconditions.checkArgument(isConstructor() || isInterface());
    Preconditions.checkArgument(!this.isUnknownType());
    // Potential infinite loop if our type system messes up or someone defines
    // a bad type. Otherwise the loop should always end.
    FunctionType ctor = this;
    while (true) {
        ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype();
        if (maybeSuperInstanceType == null) {
            return false;
        }
        if (maybeSuperInstanceType.isUnknownType()) {
            return true;
        }
        ctor = maybeSuperInstanceType.getConstructor();
        if (ctor == null) {
            return false;
        }
        Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());
    }
}","public void test52105() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Unknown class name"", 0, 1);
    noType0.setPrototypeBasedOn(namedType0);
    boolean boolean0 = noType0.hasUnknownSupertype();
    assertTrue(boolean0);
}","/**
 * Given a constructor or an interface type, find out whether the unknown
 * type is a supertype of the current type.
 */"
"public JSType getTopMostDefiningType(String propertyName) {
    Preconditions.checkState(isConstructor() || isInterface());
    Preconditions.checkArgument(getPrototype().hasProperty(propertyName));
    FunctionType ctor = this;
    JSType topInstanceType;
    do {
        topInstanceType = ctor.getInstanceType();
        ctor = ctor.getSuperClassConstructor();
    } while (ctor != null && ctor.getPrototype().hasProperty(propertyName));
    return topInstanceType;
}","public void test53106() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""INTERFACE"", (Node) null);
    // Undeclared exception!
    try {
        functionType0.getTopMostDefiningType(""INTERFACE"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Given a constructor or an interface type and a property, finds the
 * top-most superclass that has the property defined (including this
 * constructor).
 */"
"public JSType getTopMostDefiningType(String propertyName) {
    Preconditions.checkState(isConstructor() || isInterface());
    Preconditions.checkArgument(getPrototype().hasProperty(propertyName));
    FunctionType ctor = this;
    JSType topInstanceType;
    do {
        topInstanceType = ctor.getInstanceType();
        ctor = ctor.getSuperClassConstructor();
    } while (ctor != null && ctor.getPrototype().hasProperty(propertyName));
    return topInstanceType;
}","public void test54107() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    // Undeclared exception!
    try {
        functionType0.getTopMostDefiningType(""Unknown class name"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Given a constructor or an interface type and a property, finds the
 * top-most superclass that has the property defined (including this
 * constructor).
 */"
"public boolean isInterface() {
    return false;
}","public void test55108() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    noType0.setPrototypeBasedOn(noType0);
    JSType jSType0 = noType0.getTopMostDefiningType(""Unknown class name"");
    assertFalse(jSType0.isInterface());
}","/**
 * Whether this type is a {@link FunctionType} that is an interface or a named
 * type that points to such a type.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test56109() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    boolean boolean0 = errorFunctionType0.isSubtype(noType0);
    assertTrue(noType0.hasCachedValues());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (this.equals(that)) {
        return true;
    }
    if (that.isFunctionType()) {
        if (((FunctionType) that).isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        FunctionType other = (FunctionType) that;
        return (this.isConstructor() || other.isConstructor() || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis)) && this.call.isSubtype(other.call);
    }
    if (that instanceof UnionType) {
        UnionType union = (UnionType) that;
        for (JSType element : union.alternates) {
            if (this.isSubtype(element)) {
                return true;
            }
        }
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test56110() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    boolean boolean0 = errorFunctionType0.isSubtype(noType0);
    assertFalse(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test57111() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""1|.Ip_5[-thB"", (Node) null);
    JSType jSType0 = functionType0.getGreatestSubtype(errorFunctionType0);
    assertFalse(functionType0.isConstructor());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test57112() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""1|.Ip_5[-thB"", (Node) null);
    JSType jSType0 = functionType0.getGreatestSubtype(errorFunctionType0);
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test57113() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""1|.Ip_5[-thB"", (Node) null);
    JSType jSType0 = functionType0.getGreatestSubtype(errorFunctionType0);
    assertFalse(functionType0.hasCachedValues());
}",""
"public boolean isInterface() {
    return false;
}","public void test57114() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""1|.Ip_5[-thB"", (Node) null);
    JSType jSType0 = functionType0.getGreatestSubtype(errorFunctionType0);
    assertFalse(jSType0.isInterface());
}","/**
 * Whether this type is a {@link FunctionType} that is an interface or a named
 * type that points to such a type.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test57115() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""1|.Ip_5[-thB"", (Node) null);
    JSType jSType0 = functionType0.getGreatestSubtype(errorFunctionType0);
    assertFalse(errorFunctionType0.hasCachedValues());
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test58116() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(functionType0);
    FunctionType functionType1 = (FunctionType) functionType0.getGreatestSubtype(jSType0);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean isFunctionType() {
    return true;
}","public void test58117() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(functionType0);
    FunctionType functionType1 = (FunctionType) functionType0.getGreatestSubtype(jSType0);
    assertTrue(functionType0.isFunctionType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test59118() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""7k"");
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(errorFunctionType0, errorFunctionType0);
    boolean boolean0 = functionType0.isSubtype(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (this.equals(that)) {
        return true;
    }
    if (that.isFunctionType()) {
        if (((FunctionType) that).isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        FunctionType other = (FunctionType) that;
        return (this.isConstructor() || other.isConstructor() || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis)) && this.call.isSubtype(other.call);
    }
    if (that instanceof UnionType) {
        UnionType union = (UnionType) that;
        for (JSType element : union.alternates) {
            if (this.isSubtype(element)) {
                return true;
            }
        }
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test59119() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""7k"");
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(errorFunctionType0, errorFunctionType0);
    boolean boolean0 = functionType0.isSubtype(errorFunctionType0);
    assertFalse(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public String toString() {
    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return ""Function"";
    }
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = (call == null || call.parameters == null) ? 0 : call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();
    if (hasKnownTypeOfThis) {
        b.append(""this:"");
        b.append(typeOfThis.toString());
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        if (p.isVarArgs()) {
            appendVarArgsString(b, p.getJSType());
        } else {
            b.append(p.getJSType().toString());
        }
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            if (p.isVarArgs()) {
                appendVarArgsString(b, p.getJSType());
            } else {
                b.append(p.getJSType().toString());
            }
            p = p.getNext();
        }
    }
    b.append("")"");
    if (call != null && call.returnType != null) {
        b.append("": "");
        b.append(call.returnType);
    }
    return b.toString();
}","public void test60120() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    String string0 = functionType0.toString();
    assertEquals(""Function"", string0);
}","/**
 * Informally, a function is represented by
 * {@code function (params): returnType} where the {@code params} is a comma
 * separated list of types, the first one being a special
 * {@code this:T} if the function expects a known type for {@code this}.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test61121() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""Not declared as a constructor"", (Node) null);
    functionType0.toString();
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test62122() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((String) null, (Node) null, (Node) null, (JSType) objectType0);
    functionType0.toString();
    assertTrue(functionType0.hasCachedValues());
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test63123() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    functionType0.toString();
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test63124() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    functionType0.toString();
    assertFalse(functionType0.hasCachedValues());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test64125() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    JSType[] jSTypeArray0 = new JSType[3];
    jSTypeArray0[0] = (JSType) errorFunctionType0;
    jSTypeArray0[1] = (JSType) errorFunctionType0;
    jSTypeArray0[2] = (JSType) errorFunctionType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) errorFunctionType0, jSTypeArray0);
    functionType0.toString();
    assertFalse(functionType0.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test64126() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    JSType[] jSTypeArray0 = new JSType[3];
    jSTypeArray0[0] = (JSType) errorFunctionType0;
    jSTypeArray0[1] = (JSType) errorFunctionType0;
    jSTypeArray0[2] = (JSType) errorFunctionType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) errorFunctionType0, jSTypeArray0);
    functionType0.toString();
    assertFalse(functionType0.hasCachedValues());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test64127() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    JSType[] jSTypeArray0 = new JSType[3];
    jSTypeArray0[0] = (JSType) errorFunctionType0;
    jSTypeArray0[1] = (JSType) errorFunctionType0;
    jSTypeArray0[2] = (JSType) errorFunctionType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) errorFunctionType0, jSTypeArray0);
    functionType0.toString();
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test65128() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    LinkedHashSet<JSType> linkedHashSet0 = new LinkedHashSet<JSType>();
    UnionType unionType0 = new UnionType(jSTypeRegistry0, linkedHashSet0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[2];
    jSTypeArray0[0] = (JSType) unionType0;
    jSTypeArray0[1] = (JSType) noType0;
    FunctionType functionType0 = jSTypeRegistry0.createConstructorTypeWithVarArgs((JSType) null, jSTypeArray0);
    functionType0.toString();
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test66129() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.FunctionType$Kind"", (Node) null);
    FunctionType functionType1 = new FunctionType(jSTypeRegistry0, ""-9kF"", (Node) null);
    boolean boolean0 = functionType1.canAssignTo(functionType0);
    assertFalse(functionType1.isConstructor());
}",""
"public boolean canAssignTo(JSType that) {
    if (this.isSubtype(that)) {
        return true;
    }
    return false;
}","public void test66130() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.FunctionType$Kind"", (Node) null);
    FunctionType functionType1 = new FunctionType(jSTypeRegistry0, ""-9kF"", (Node) null);
    boolean boolean0 = functionType1.canAssignTo(functionType0);
    assertTrue(boolean0);
}","/**
 * Tests whether values of {@code this} type can be safely assigned
 * to values of {@code that} type.<p>
 *
 * The default implementation verifies that {@code this} is a subtype
 * of {@code that}.<p>
 */"
"@Override
public boolean equals(Object otherType) {
    if (!(otherType instanceof FunctionType)) {
        return false;
    }
    FunctionType that = (FunctionType) otherType;
    if (!that.isFunctionType()) {
        return false;
    }
    if (this.isConstructor()) {
        if (that.isConstructor()) {
            return this == that;
        }
        return false;
    }
    if (this.isInterface()) {
        if (that.isInterface()) {
            return this.getReferenceName().equals(that.getReferenceName());
        }
        return false;
    }
    if (that.isInterface()) {
        return false;
    }
    return this.typeOfThis.equals(that.typeOfThis) && this.call.equals(that.call);
}","public void test66131() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.FunctionType$Kind"", (Node) null);
    FunctionType functionType1 = new FunctionType(jSTypeRegistry0, ""-9kF"", (Node) null);
    boolean boolean0 = functionType1.canAssignTo(functionType0);
    assertFalse(functionType1.equals((Object) functionType0));
}","/**
 * Two function types are equal if their signatures match. Since they don't
 * have signatures, two interfaces are equal if their names match.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test67132() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""tGx/("", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType0.isSubtype(functionType1);
    assertEquals(0, functionType1.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test67133() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""tGx/("", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType0.isSubtype(functionType1);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean isSubtype(JSType that) {
    if (this.equals(that)) {
        return true;
    }
    if (that.isFunctionType()) {
        if (((FunctionType) that).isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        FunctionType other = (FunctionType) that;
        return (this.isConstructor() || other.isConstructor() || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis)) && this.call.isSubtype(other.call);
    }
    if (that instanceof UnionType) {
        UnionType union = (UnionType) that;
        for (JSType element : union.alternates) {
            if (this.isSubtype(element)) {
                return true;
            }
        }
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test67134() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""tGx/("", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType0.isSubtype(functionType1);
    assertFalse(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean isFunctionType() {
    return true;
}","public void test67135() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""tGx/("", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType0.isSubtype(functionType1);
    assertTrue(functionType1.isFunctionType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test68136() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    JSType jSType0 = errorFunctionType0.getPropertyType(""call"");
    boolean boolean0 = errorFunctionType0.isSubtype(jSType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (this.equals(that)) {
        return true;
    }
    if (that.isFunctionType()) {
        if (((FunctionType) that).isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        FunctionType other = (FunctionType) that;
        return (this.isConstructor() || other.isConstructor() || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis)) && this.call.isSubtype(other.call);
    }
    if (that instanceof UnionType) {
        UnionType union = (UnionType) that;
        for (JSType element : union.alternates) {
            if (this.isSubtype(element)) {
                return true;
            }
        }
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test68137() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    JSType jSType0 = errorFunctionType0.getPropertyType(""call"");
    boolean boolean0 = errorFunctionType0.isSubtype(jSType0);
    assertTrue(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test69138() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(noType0, noType0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(noType0, noType0);
    functionType1.setInstanceType(noType0);
    boolean boolean0 = functionType1.isSubtype(functionType0);
    assertTrue(noType0.hasCachedValues());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (this.equals(that)) {
        return true;
    }
    if (that.isFunctionType()) {
        if (((FunctionType) that).isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        FunctionType other = (FunctionType) that;
        return (this.isConstructor() || other.isConstructor() || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis)) && this.call.isSubtype(other.call);
    }
    if (that instanceof UnionType) {
        UnionType union = (UnionType) that;
        for (JSType element : union.alternates) {
            if (this.isSubtype(element)) {
                return true;
            }
        }
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test69139() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(noType0, noType0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(noType0, noType0);
    functionType1.setInstanceType(noType0);
    boolean boolean0 = functionType1.isSubtype(functionType0);
    assertTrue(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test70140() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = (FunctionType) jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) functionType0, (JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType0.isSubtype(functionType1);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean isSubtype(JSType that) {
    if (this.equals(that)) {
        return true;
    }
    if (that.isFunctionType()) {
        if (((FunctionType) that).isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        FunctionType other = (FunctionType) that;
        return (this.isConstructor() || other.isConstructor() || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis)) && this.call.isSubtype(other.call);
    }
    if (that instanceof UnionType) {
        UnionType union = (UnionType) that;
        for (JSType element : union.alternates) {
            if (this.isSubtype(element)) {
                return true;
            }
        }
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test70141() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = (FunctionType) jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) functionType0, (JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType0.isSubtype(functionType1);
    assertTrue(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean equals(Object otherType) {
    if (!(otherType instanceof FunctionType)) {
        return false;
    }
    FunctionType that = (FunctionType) otherType;
    if (!that.isFunctionType()) {
        return false;
    }
    if (this.isConstructor()) {
        if (that.isConstructor()) {
            return this == that;
        }
        return false;
    }
    if (this.isInterface()) {
        if (that.isInterface()) {
            return this.getReferenceName().equals(that.getReferenceName());
        }
        return false;
    }
    if (that.isInterface()) {
        return false;
    }
    return this.typeOfThis.equals(that.typeOfThis) && this.call.equals(that.call);
}","public void test70142() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = (FunctionType) jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) functionType0, (JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType0.isSubtype(functionType1);
    assertFalse(functionType1.equals((Object) functionType0));
}","/**
 * Two function types are equal if their signatures match. Since they don't
 * have signatures, two interfaces are equal if their names match.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test70143() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = (FunctionType) jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) functionType0, (JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType0.isSubtype(functionType1);
    assertFalse(functionType0.hasCachedValues());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test70144() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = (FunctionType) jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) functionType0, (JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType0.isSubtype(functionType1);
    assertEquals(0, functionType1.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test71145() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(noType0, noType0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(noObjectType0, noType0);
    boolean boolean0 = functionType1.isSubtype(functionType0);
    assertTrue(noObjectType0.hasCachedValues());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (this.equals(that)) {
        return true;
    }
    if (that.isFunctionType()) {
        if (((FunctionType) that).isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        FunctionType other = (FunctionType) that;
        return (this.isConstructor() || other.isConstructor() || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis)) && this.call.isSubtype(other.call);
    }
    if (that instanceof UnionType) {
        UnionType union = (UnionType) that;
        for (JSType element : union.alternates) {
            if (this.isSubtype(element)) {
                return true;
            }
        }
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test71146() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(noType0, noType0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(noObjectType0, noType0);
    boolean boolean0 = functionType1.isSubtype(functionType0);
    assertFalse(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test72147() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    boolean boolean0 = errorFunctionType0.isNumber();
    assertEquals(3, errorFunctionType0.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public final boolean isNumber() {
    return this.isSubtype(getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));
}","public void test72148() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    boolean boolean0 = errorFunctionType0.isNumber();
    assertFalse(boolean0);
}","/**
 * Tests whether the type is a number (value or Object).
 * @return {@code this &lt;: (Number, number)}
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test72149() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    boolean boolean0 = errorFunctionType0.isNumber();
    assertFalse(errorFunctionType0.isInterface());
}",""
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test73150() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType("""", (Node) null);
    boolean boolean0 = functionType0.hasInstanceType();
    assertFalse(functionType0.isConstructor());
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test73151() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType("""", (Node) null);
    boolean boolean0 = functionType0.hasInstanceType();
    assertTrue(boolean0);
}","/**
 * Returns whether this function type has an instance type.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test74152() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    boolean boolean0 = functionType0.hasInstanceType();
    assertFalse(boolean0);
}","/**
 * Returns whether this function type has an instance type.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test75153() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(functionType0, functionType0);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test76154() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""rSU~(i;_P"");
    errorFunctionType0.getImplementedInterfaces();
    boolean boolean0 = errorFunctionType0.hasCachedValues();
    assertTrue(boolean0);
}",""
"void setImplicitPrototype(ObjectType implicitPrototype) {
    checkState(!hasCachedValues());
    this.implicitPrototype = implicitPrototype;
}","public void test77155() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionPrototypeType functionPrototypeType0 = new FunctionPrototypeType(jSTypeRegistry0, noType0, noType0);
    functionPrototypeType0.differsFrom(noType0);
    // Undeclared exception!
    try {
        noType0.setImplicitPrototype(functionPrototypeType0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * This should only be reset on the FunctionPrototypeType, only to fix an
 * incorrectly established prototype chain due to the user having a mismatch
 * in super class declaration, and only before properties on that type are
 * processed.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test78156() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    LinkedList<ObjectType> linkedList0 = new LinkedList<ObjectType>();
    linkedList0.add((ObjectType) errorFunctionType0);
    errorFunctionType0.setImplementedInterfaces(linkedList0);
    EmptyScope emptyScope0 = new EmptyScope();
    errorFunctionType0.resolveInternal(simpleErrorReporter0, emptyScope0);
    assertTrue(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public FunctionType getConstructor() {
    return primitiveObjectType == null ? null : primitiveObjectType.getConstructor();
}","public void test79157() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, JSType> hashMap0 = new HashMap<String, JSType>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ObjectType objectType0 = recordType0.getImplicitPrototype();
    EnumType enumType0 = new EnumType(jSTypeRegistry0, "")"", objectType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    FunctionType functionType0 = enumElementType0.getConstructor();
    assertNotNull(functionType0);
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test79158() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, JSType> hashMap0 = new HashMap<String, JSType>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ObjectType objectType0 = recordType0.getImplicitPrototype();
    EnumType enumType0 = new EnumType(jSTypeRegistry0, "")"", objectType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    FunctionType functionType0 = enumElementType0.getConstructor();
    EmptyScope emptyScope0 = new EmptyScope();
    FunctionType functionType1 = (FunctionType) functionType0.resolveInternal(simpleErrorReporter0, emptyScope0);
    assertFalse(functionType1.isInterface());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test79159() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, JSType> hashMap0 = new HashMap<String, JSType>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ObjectType objectType0 = recordType0.getImplicitPrototype();
    EnumType enumType0 = new EnumType(jSTypeRegistry0, "")"", objectType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    FunctionType functionType0 = enumElementType0.getConstructor();
    EmptyScope emptyScope0 = new EmptyScope();
    FunctionType functionType1 = (FunctionType) functionType0.resolveInternal(simpleErrorReporter0, emptyScope0);
    assertEquals(1, functionType1.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
