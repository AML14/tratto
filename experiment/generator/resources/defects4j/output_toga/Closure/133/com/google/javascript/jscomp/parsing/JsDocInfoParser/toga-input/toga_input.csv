focal_method,test_prefix,docstring
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test000() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""coyr"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test001() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""coyr"");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""coyr"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    JsDocToken jsDocToken0 = JsDocToken.EOC;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertEquals(0, node0.getSourcePosition());
}",""
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test002() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""coyr"");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""coyr"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    JsDocToken jsDocToken0 = JsDocToken.EOC;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertTrue(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean hasParsedJSDocInfo() {
    return jsdocBuilder.isPopulated();
}","public void test013() throws Throwable {
    Node node0 = Node.newString("")~>"");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("")~>"");
    HashSet<String> hashSet0 = new HashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(hashSet0, hashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    boolean boolean0 = jsDocInfoParser0.hasParsedJSDocInfo();
    assertFalse(boolean0);
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test024() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(I;2"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"JSDocInfo getFileOverviewJSDocInfo() {
    return fileOverviewJSDocInfo;
}","public void test035() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = Node.newString(""nq<=v=.'vcD3EgF"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""nq<=v=.'vcD3EgF"", 4095, 46);
    Token.CommentType token_CommentType0 = Token.CommentType.BLOCK_COMMENT;
    Comment comment0 = new Comment(49, 4095, token_CommentType0, ""nq<=v=.'vcD3EgF"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.getFileOverviewJSDocInfo();
    assertNull(jSDocInfo0);
}","/**
 * Gets the fileoverview JSDocInfo, if any.
 */"
"void setFileLevelJsDocBuilder(Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {
    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;
}","public void test046() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""Q9bugwgCe+\n"");
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = Node.newString(""Q9bugwgCe+\n"");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, false, config_LanguageMode0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, (ErrorReporter) null);
    Node.FileLevelJsDocBuilder node_FileLevelJsDocBuilder0 = node0.getJsDocBuilderForNode();
    jsDocInfoParser0.setFileLevelJsDocBuilder(node_FileLevelJsDocBuilder0);
}","/**
 * Sets the JsDocBuilder for the file-level (root) node of this parse. The
 * parser uses the builder to append any preserve annotations it encounters
 * in JsDoc comments.
 *
 * @param fileLevelJsDocBuilder
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test057() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""msg.jsdoc.interface.constructor"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test058() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""msg.jsdoc.interface.constructor"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""msg.jsdoc.interface.constructor"", 15, 55);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    jsDocInfoParser0.setFileOverviewJSDocInfo((JSDocInfo) null);
    assertEquals(0, node0.getSourcePosition());
}",""
"public int getLength() {
    return getIntProp(LENGTH);
}","public void test059() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""msg.jsdoc.interface.constructor"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""msg.jsdoc.interface.constructor"", 15, 55);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    jsDocInfoParser0.setFileOverviewJSDocInfo((JSDocInfo) null);
    assertEquals(31, node0.getLength());
}",""
"public boolean isString() {
    return this.getType() == Token.STRING;
}","public void test0510() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""msg.jsdoc.interface.constructor"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""msg.jsdoc.interface.constructor"", 15, 55);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    jsDocInfoParser0.setFileOverviewJSDocInfo((JSDocInfo) null);
    assertTrue(node0.isString());
}",""
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test0611() throws Throwable {
    Charset charset0 = Charset.defaultCharset();
    Set<String> set0 = charset0.aliases();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(set0, set0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""@*"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""@*"", 54, 31);
    Token.CommentType token_CommentType0 = Token.CommentType.BLOCK_COMMENT;
    Comment comment0 = new Comment(47, 16, token_CommentType0, ""@*"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test0712() throws Throwable {
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""(I;2"", 53, 42);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test0813() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = JsDocInfoParser.parseTypeString(""'9wg.\n"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test0814() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = JsDocInfoParser.parseTypeString(""'9wg.\n"");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, false, config_LanguageMode0, false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""'9wg.\n"", 1);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, (ErrorReporter) null);
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.parseInlineTypeDoc();
    assertEquals(0, node0.getSourcePosition());
}",""
"public JSDocInfo parseInlineTypeDoc() {
    Node typeAst = parseAndRecordTypeNode(next());
    JSTypeExpression expr = createJSTypeExpression(typeAst);
    if (expr != null) {
        jsdocBuilder.recordType(expr);
        return retrieveAndResetParsedJSDocInfo();
    }
    return null;
}","public void test0815() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = JsDocInfoParser.parseTypeString(""'9wg.\n"");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, false, config_LanguageMode0, false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""'9wg.\n"", 1);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, (ErrorReporter) null);
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.parseInlineTypeDoc();
    assertNotNull(jSDocInfo0);
}",""
"public int getLength() {
    return getIntProp(LENGTH);
}","public void test0816() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = JsDocInfoParser.parseTypeString(""'9wg.\n"");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, false, config_LanguageMode0, false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""'9wg.\n"", 1);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, (ErrorReporter) null);
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.parseInlineTypeDoc();
    assertEquals(5, node0.getLength());
}",""
"public int getLineno() {
    return extractLineno(sourcePosition);
}","public void test0817() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = JsDocInfoParser.parseTypeString(""'9wg.\n"");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, false, config_LanguageMode0, false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""'9wg.\n"", 1);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, (ErrorReporter) null);
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.parseInlineTypeDoc();
    assertEquals(0, node0.getLineno());
}",""
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test0918() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""Q9bugwgCe+\n"");
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = JsDocInfoParser.parseTypeString(""Q9bugwgCe+\n"");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    node0.setSourceFileForTesting(""Q9bugwgCe+\n"");
    Config config0 = new Config(treeSet0, treeSet0, false, config_LanguageMode0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, (ErrorReporter) null);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.parsing.JsDocInfoParser$ErrorReporterParser"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"public JSDocInfo parseInlineTypeDoc() {
    Node typeAst = parseAndRecordTypeNode(next());
    JSTypeExpression expr = createJSTypeExpression(typeAst);
    if (expr != null) {
        jsdocBuilder.recordType(expr);
        return retrieveAndResetParsedJSDocInfo();
    }
    return null;
}","public void test1019() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("")enN3\""hcA}gLz~UF1"", 52, 15);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, toolErrorReporter0);
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.parseInlineTypeDoc();
    assertNull(jSDocInfo0);
}",""
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1120() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    Set<String> set0 = locale0.getUnicodeLocaleAttributes();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(set0, set0, false, config_LanguageMode0, false);
    Node node0 = Node.newString("".java"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""@lXv@"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1221() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""*(|shST:z OIyID!N-"");
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = Node.newString(""*(|shST:z OIyID!N-"");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, false, config_LanguageMode0, false);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test1322() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""Rr\""}!Ot+6+}S:"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""Rr\""}!Ot+6+}S:"", 1, 2);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment((-412283329), 2, token_CommentType0, ""STRING_TYPE"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(4098, node1.getSourcePosition());
}",""
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, token == JsDocToken.LC);
}","public void test1323() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""Rr\""}!Ot+6+}S:"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""Rr\""}!Ot+6+}S:"", 1, 2);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment((-412283329), 2, token_CommentType0, ""STRING_TYPE"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertNotNull(node1);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"public int getLength() {
    return getIntProp(LENGTH);
}","public void test1324() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""Rr\""}!Ot+6+}S:"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""Rr\""}!Ot+6+}S:"", 1, 2);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment((-412283329), 2, token_CommentType0, ""STRING_TYPE"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(3, node1.getLength());
}",""
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1425() throws Throwable {
    Node node0 = Node.newString(""1bxZ"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""!1.-J"", 30, 52);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment(55, 31, token_CommentType0, ""!1.-J"");
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1526() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""tTcoyr"");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("",\n"", 37, 42);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1627() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""cbQoE,!MA9"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("":u'O,PdUdnsL,<*"", 8, 54);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1728() throws Throwable {
    Node node0 = Node.newString(""~>"");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""~>"");
    HashSet<String> hashSet0 = new HashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(hashSet0, hashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    JsDocToken jsDocToken0 = JsDocToken.QMARK;
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1829() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""[B1)"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""[B1)"", 12, 8);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1930() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""{=rf"");
    HashSet<String> hashSet0 = new HashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(hashSet0, hashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test2031() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""Ko%"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test2032() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""Ko%"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""Ko%"", 15, 55);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LT;
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    jsDocInfoParser0.parse();
    assertEquals(0, node0.getSourcePosition());
}",""
"public boolean isString() {
    return this.getType() == Token.STRING;
}","public void test2033() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""Ko%"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""Ko%"", 15, 55);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LT;
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    jsDocInfoParser0.parse();
    assertTrue(node0.isString());
}",""
"public int getLineno() {
    return extractLineno(sourcePosition);
}","public void test2034() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""Ko%"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""Ko%"", 15, 55);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LT;
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    jsDocInfoParser0.parse();
    assertEquals(0, node0.getLineno());
}",""
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2135() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""?"", 47, 37);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2236() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""|ujoSxU"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2337() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""*]%,"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""*]%,"", 2, 43);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2438() throws Throwable {
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    HashSet<String> hashSet0 = new HashSet<String>();
    Config config0 = new Config(hashSet0, hashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""}"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2539() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""$"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("")enN3\""hc}gLz~UF1"", 52, 15);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test2640() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""*"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test2641() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""*"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""*"", 2, 43);
    JsDocToken jsDocToken0 = JsDocToken.ELLIPSIS;
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    jsDocInfoParser0.parse();
    assertEquals(302, node0.getType());
}",""
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test2642() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""*"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""*"", 2, 43);
    JsDocToken jsDocToken0 = JsDocToken.ELLIPSIS;
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    jsDocInfoParser0.parse();
    assertEquals(0, node0.getChildCount());
}",""
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2743() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""=)!Wf}404"", 52, 15);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2844() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""*aB1u1/"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""*aB1u1/"", 46);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2945() throws Throwable {
    Node node0 = Node.newString(""coyr"");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""coyr"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    JsDocToken jsDocToken0 = JsDocToken.EOC;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertTrue(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test3046() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Node node0 = JsDocInfoParser.parseTypeString(""; !S^D( 5{SwmW "");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""; !S^D( 5{SwmW "");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, (ErrorReporter) null);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.parsing.JsDocInfoParser$ErrorReporterParser"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, token == JsDocToken.LC);
}","public void test3147() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""NY|"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    Set<String> set0 = jSDocInfo0.getModifies();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(set0, set0, false, config_LanguageMode0, false);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node0 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertNull(node0);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test3248() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""7tbE%"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""7tbE%"", 38);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment(49, 4095, token_CommentType0, ""7tbE%"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(155648, node1.getSourcePosition());
}",""
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, token == JsDocToken.LC);
}","public void test3249() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""7tbE%"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""7tbE%"", 38);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment(49, 4095, token_CommentType0, ""7tbE%"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertNotNull(node1);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"public int getLength() {
    return getIntProp(LENGTH);
}","public void test3250() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""7tbE%"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""7tbE%"", 38);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment(49, 4095, token_CommentType0, ""7tbE%"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(5, node1.getLength());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3351() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""e$_FW0T^ .<Lc"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3452() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""z-u.<=Lc"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test3453() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""z-u.<=Lc"");
    assertEquals(0, node0.getSourcePosition());
}",""
"public int getLength() {
    return getIntProp(LENGTH);
}","public void test3454() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""z-u.<=Lc"");
    assertEquals(3, node0.getLength());
}",""
"public int getType() {
    return type;
}","public void test3555() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?,LmixF\""@%6O@m."");
    assertEquals(304, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3556() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?,LmixF\""@%6O@m."");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test3657() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""? =u"");
    assertEquals(304, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3658() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""? =u"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3759() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?]#:"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test3760() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?]#:"");
    assertEquals(304, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3861() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?}N-&xJ,\""j^e'$ei=bX"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test3862() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?}N-&xJ,\""j^e'$ei=bX"");
    assertEquals(304, node0.getType());
}",""
"public int getType() {
    return type;
}","public void test3963() throws Throwable {
    Node node0 = Node.newString("")~>"");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("")~>"");
    HashSet<String> hashSet0 = new HashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(hashSet0, hashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    JsDocToken jsDocToken0 = JsDocToken.QMARK;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(304, node1.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4064() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""IRSOgvs$"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test4065() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""IRSOgvs$"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""|kV)WPX@"", (-649), 43);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment((-2466), 147, token_CommentType0, ""|kV)WPX@"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.QMARK;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(304, node1.getType());
}",""
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, token == JsDocToken.LC);
}","public void test4066() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""IRSOgvs$"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""|kV)WPX@"", (-649), 43);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment((-2466), 147, token_CommentType0, ""|kV)WPX@"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.QMARK;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertNotNull(node1);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test4067() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""IRSOgvs$"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""|kV)WPX@"", (-649), 43);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment((-2466), 147, token_CommentType0, ""|kV)WPX@"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.QMARK;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(0, node0.getSourcePosition());
}",""
"public int getType() {
    return type;
}","public void test4168() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?>.9!3"");
    assertEquals(304, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4169() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?>.9!3"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4270() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString("" sN%-|Q?u6"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test4271() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString("" sN%-|Q?u6"");
    assertEquals(301, node0.getType());
}",""
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test4272() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString("" sN%-|Q?u6"");
    assertEquals(2, node0.getChildCount());
}",""
"public int getSourcePosition() {
    return sourcePosition;
}","public void test4273() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString("" sN%-|Q?u6"");
    assertEquals(6, node0.getSourcePosition());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4374() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{=rf"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4475() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""function"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test4576() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""null"");
    assertEquals(0, node0.getSourcePosition());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4577() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""null"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getLength() {
    return getIntProp(LENGTH);
}","public void test4578() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""null"");
    assertEquals(4, node0.getLength());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4679() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""undefined"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test4680() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""undefined"");
    assertEquals(0, node0.getSourcePosition());
}",""
"public int getLength() {
    return getIntProp(LENGTH);
}","public void test4681() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""undefined"");
    assertEquals(9, node0.getLength());
}",""
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test4782() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""|*|SZ6C).\""6G7Xa"");
    assertEquals(3, node0.getChildCount());
}",""
"public int getType() {
    return type;
}","public void test4783() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""|*|SZ6C).\""6G7Xa"");
    assertEquals(301, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4784() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""|*|SZ6C).\""6G7Xa"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4885() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""<N|X_I20p ,"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4986() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(Ljava/lang/String;)Ljava/lang/StringBuffer;"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test4987() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(Ljava/lang/String;)Ljava/lang/StringBuffer;"");
    assertEquals(301, node0.getType());
}",""
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test4988() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(Ljava/lang/String;)Ljava/lang/StringBuffer;"");
    assertEquals(1, node0.getChildCount());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5089() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[ativebcode, asiJq="");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, token == JsDocToken.LC);
}","public void test5190() throws Throwable {
    Node node0 = Node.newString(""1bxV"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""!1.J"", 30, 52);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment(55, 31, token_CommentType0, ""!1.J"");
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.ELLIPSIS;
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    JsDocToken jsDocToken1 = JsDocToken.LB;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken1);
    assertNull(node1);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5291() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""["");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test5392() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[iX]T[Ntig&[{];[eRL"");
    assertEquals(308, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5393() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[iX]T[Ntig&[{];[eRL"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public boolean hasChildren() {
    return first != null;
}","public void test5394() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[iX]T[Ntig&[{];[eRL"");
    assertTrue(node0.hasChildren());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5495() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{N}"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test5496() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{N}"");
    assertEquals(309, node0.getType());
}",""
"public boolean hasChildren() {
    return first != null;
}","public void test5497() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{N}"");
    assertTrue(node0.hasChildren());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5598() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{O,Q/iEUCWI`$JO"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5699() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{OH6w:Z"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test57100() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{OyW:"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test58101() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test59102() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""%<p8zIb;*/Rm}{vW"");
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = JsDocInfoParser.parseTypeString(""fu{nction"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test59103() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""%<p8zIb;*/Rm}{vW"");
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = JsDocInfoParser.parseTypeString(""fu{nction"");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, false, config_LanguageMode0, true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, (ErrorReporter) null);
    jsDocInfoParser0.parse();
    assertEquals(0, node0.getSourcePosition());
}",""
"public boolean isString() {
    return this.getType() == Token.STRING;
}","public void test59104() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""%<p8zIb;*/Rm}{vW"");
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = JsDocInfoParser.parseTypeString(""fu{nction"");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, false, config_LanguageMode0, true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, (ErrorReporter) null);
    jsDocInfoParser0.parse();
    assertTrue(node0.isString());
}",""
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test59105() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""%<p8zIb;*/Rm}{vW"");
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Node node0 = JsDocInfoParser.parseTypeString(""fu{nction"");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(treeSet0, treeSet0, false, config_LanguageMode0, true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, (ErrorReporter) null);
    jsDocInfoParser0.parse();
    assertEquals(0, node0.getCharno());
}",""
"@SuppressWarnings(""incomplete-switch"")
boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case NG_INJECT:
                                if (jsdocBuilder.isNgInjectRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.nginject.extra"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.recordNgInject(true);
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case AUTHOR:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo authorInfo = extractSingleLineBlock();
                                    String author = authorInfo.string;
                                    if (author.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addAuthor(author);
                                    }
                                    token = authorInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case CONSISTENTIDGENERATOR:
                                if (!jsdocBuilder.recordConsistentIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.consistidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case STRUCT:
                                if (!jsdocBuilder.recordStruct()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DICT:
                                if (!jsdocBuilder.recordDict()) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addParserWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addTypeWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addParserWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                String fileOverview = """";
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                    fileOverview = fileOverviewInfo.string;
                                    token = fileOverviewInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                if (!jsdocBuilder.recordFileOverview(fileOverview)) {
                                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addParserWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXPOSE:
                                if (!jsdocBuilder.recordExpose()) {
                                    parser.addParserWarning(""msg.jsdoc.expose"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addParserWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addParserWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        // record the extended type, check later
                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addTypeWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addParserWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case LENDS:
                                skipEOLs();
                                matchingRc = false;
                                if (match(JsDocToken.LC)) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (match(JsDocToken.STRING)) {
                                    token = next();
                                    if (!jsdocBuilder.recordLends(stream.getString())) {
                                        parser.addTypeWarning(""msg.jsdoc.lends.incompatible"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addTypeWarning(""msg.jsdoc.lends.missing"", stream.getLineno(), stream.getCharno());
                                }
                                if (matchingRc && !match(JsDocToken.RC)) {
                                    parser.addTypeWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MEANING:
                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                                String meaning = meaningInfo.string;
                                token = meaningInfo.token;
                                if (!jsdocBuilder.recordMeaning(meaning)) {
                                    parser.addParserWarning(""msg.jsdoc.meaning.extra"", stream.getLineno(), stream.getCharno());
                                }
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addParserWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_COMPILE:
                                if (!jsdocBuilder.recordNoCompile()) {
                                    parser.addParserWarning(""msg.jsdoc.nocompile"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addParserWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addTypeWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    if (description.length() > 0) {
                                        jsdocBuilder.recordThrowDescription(type, description);
                                    }
                                    token = descriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addTypeWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter
                                        // annotation.  It makes no sense under our type
                                        // system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addTypeWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, sourceFile, lineno, charno);
                                // Find the parameter's description (if applicable).
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                    String paramDescription = paramDescriptionInfo.string;
                                    if (paramDescription.length() > 0) {
                                        jsdocBuilder.recordParameterDescription(name, paramDescription);
                                    }
                                    token = paramDescriptionInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addParserWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addParserWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addParserWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case MODIFIES:
                                token = parseModifiesTag(next());
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addTypeWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                if (jsdocBuilder.shouldParseDocumentation()) {
                                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                                    String reference = referenceInfo.string;
                                    if (reference.length() == 0) {
                                        parser.addParserWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        jsdocBuilder.addReference(reference);
                                    }
                                    token = referenceInfo.token;
                                } else {
                                    token = eatTokensUntilEOL(token);
                                }
                                continue retry;
                            case STABLEIDGENERATOR:
                                if (!jsdocBuilder.recordStableIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.stableidgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                {
                                    ExtractionInfo templateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = templateInfo.token;
                                    continue retry;
                                }
                            case CLASS_TEMPLATE:
                                {
                                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
                                    List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(classTemplateInfo.string));
                                    if (names.size() == 0 || names.get(0).length() == 0) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.missing.type.name"", stream.getLineno(), stream.getCharno());
                                    } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
                                        parser.addTypeWarning(""msg.jsdoc.classtemplate.at.most.once"", stream.getLineno(), stream.getCharno());
                                    }
                                    token = classTemplateInfo.token;
                                    continue retry;
                                }
                            case IDGENERATOR:
                                if (!jsdocBuilder.recordIdGenerator()) {
                                    parser.addParserWarning(""msg.jsdoc.idgen"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addParserWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addParserWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case CONSTANT:
                            case DEFINE:
                            case RETURN:
                            case PRIVATE:
                            case PROTECTED:
                            case PUBLIC:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                Node typeNode = null;
                                boolean hasType = lookAheadForTypeAnnotation();
                                boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
                                boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
                                type = null;
                                if (hasType || !canSkipTypeAnnotation) {
                                    skipEOLs();
                                    token = next();
                                    typeNode = parseAndRecordTypeNode(token);
                                    if (annotation == Annotation.THIS) {
                                        typeNode = wrapNode(Token.BANG, typeNode);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                }
                                // The error was reported during recursive descent
                                // recovering parsing
                                boolean hasError = type == null && !canSkipTypeAnnotation;
                                if (!hasError) {
                                    // Record types for @type.
                                    // If the @private, @protected, or @public annotations
                                    // have a type attached, pretend that they actually wrote:
                                    // @type {type}\n@private
                                    // This will have some weird behavior in some cases
                                    // (for example, @private can now be used as a type-cast),
                                    // but should be mostly OK.
                                    if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
                                        if (!jsdocBuilder.recordType(type)) {
                                            parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    }
                                    switch(annotation) {
                                        case CONSTANT:
                                            if (!jsdocBuilder.recordConstancy()) {
                                                parser.addParserWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                            }
                                            break;
                                        case DEFINE:
                                            if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addParserWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case PRIVATE:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.private"", lineno, charno);
                                            }
                                            break;
                                        case PROTECTED:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.protected"", lineno, charno);
                                            }
                                            break;
                                        case PUBLIC:
                                            if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                                parser.addParserWarning(""msg.jsdoc.visibility.public"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (type == null) {
                                                type = createJSTypeExpression(newNode(Token.QMARK));
                                            }
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // Find the return's description (if applicable).
                                            if (jsdocBuilder.shouldParseDocumentation()) {
                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                                String returnDescription = returnDescriptionInfo.string;
                                                if (returnDescription.length() > 0) {
                                                    jsdocBuilder.recordReturnDescription(returnDescription);
                                                }
                                                token = returnDescriptionInfo.token;
                                            } else {
                                                token = eatTokensUntilEOL(token);
                                            }
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addTypeWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                checkExtendedTypes(extendedTypes);
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addParserWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                checkExtendedTypes(extendedTypes);
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test60106() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""*aB1u1/"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""*aB1u1/"", 46);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.EOL;
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
