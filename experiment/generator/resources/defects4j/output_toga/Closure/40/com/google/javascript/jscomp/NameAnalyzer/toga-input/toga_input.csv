focal_method,test_prefix,docstring
"String getHtmlReport() {
    StringBuilder sb = new StringBuilder();
    sb.append(""<html><body><style type=\""text/css\"">"" + ""body, td, p {font-family: Arial; font-size: 83%} "" + ""ul {margin-top:2px; margin-left:0px; padding-left:1em;} "" + ""li {margin-top:3px; margin-left:24px; padding-left:0px;"" + ""padding-bottom: 4px}</style>"");
    sb.append(""OVERALL STATS<ul>"");
    appendListItem(sb, ""Total Names: "" + countOf(TriState.BOTH, TriState.BOTH));
    appendListItem(sb, ""Total Classes: "" + countOf(TriState.TRUE, TriState.BOTH));
    appendListItem(sb, ""Total Static Functions: "" + countOf(TriState.FALSE, TriState.BOTH));
    appendListItem(sb, ""Referenced Names: "" + countOf(TriState.BOTH, TriState.TRUE));
    appendListItem(sb, ""Referenced Classes: "" + countOf(TriState.TRUE, TriState.TRUE));
    appendListItem(sb, ""Referenced Functions: "" + countOf(TriState.FALSE, TriState.TRUE));
    sb.append(""</ul>"");
    sb.append(""ALL NAMES<ul>\n"");
    for (JsName node : allNames.values()) {
        sb.append(""<li>"" + nameAnchor(node.name) + ""<ul>"");
        if (node.prototypeNames.size() > 0) {
            sb.append(""<li>PROTOTYPES: "");
            Iterator<String> protoIter = node.prototypeNames.iterator();
            while (protoIter.hasNext()) {
                sb.append(protoIter.next());
                if (protoIter.hasNext()) {
                    sb.append("", "");
                }
            }
        }
        if (referenceGraph.hasNode(node)) {
            List<DiGraphEdge<JsName, RefType>> refersTo = referenceGraph.getOutEdges(node);
            if (refersTo.size() > 0) {
                sb.append(""<li>REFERS TO: "");
                Iterator<DiGraphEdge<JsName, RefType>> toIter = refersTo.iterator();
                while (toIter.hasNext()) {
                    sb.append(nameLink(toIter.next().getDestination().getValue().name));
                    if (toIter.hasNext()) {
                        sb.append("", "");
                    }
                }
            }
            List<DiGraphEdge<JsName, RefType>> referencedBy = referenceGraph.getInEdges(node);
            if (referencedBy.size() > 0) {
                sb.append(""<li>REFERENCED BY: "");
                Iterator<DiGraphEdge<JsName, RefType>> fromIter = refersTo.iterator();
                while (fromIter.hasNext()) {
                    sb.append(nameLink(fromIter.next().getDestination().getValue().name));
                    if (fromIter.hasNext()) {
                        sb.append("", "");
                    }
                }
            }
        }
        sb.append(""</li>"");
        sb.append(""</ul></li>"");
    }
    sb.append(""</ul>"");
    sb.append(""</body></html>"");
    return sb.toString();
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""var t;"", ""var t;"");
    Node node1 = new Node(16, node0);
    nameAnalyzer0.process(node0, node1);
    String string0 = nameAnalyzer0.getHtmlReport();
    assertEquals(""<html><body><style type=\""text/css\"">body, td, p {font-family: Arial; font-size: 83%} ul {margin-top:2px; margin-left:0px; padding-left:1em;} li {margin-top:3px; margin-left:24px; padding-left:0px;padding-bottom: 4px}</style>OVERALL STATS<ul><li>Total Names: 2</li>\n<li>Total Classes: 0</li>\n<li>Total Static Functions: 2</li>\n<li>Referenced Names: 2</li>\n<li>Referenced Classes: 0</li>\n<li>Referenced Functions: 2</li>\n</ul>ALL NAMES<ul>\n<li><a name=\""Function\"">Function</a><ul></li></ul></li><li><a name=\""t\"">t</a><ul><li>REFERENCED BY: </li></ul></li><li><a name=\""window\"">window</a><ul><li>REFERS TO: <a href=\""#t\"">t</a></li></ul></li></ul></body></html>"", string0);
}","/**
 * Generates an HTML report
 *
 * @return The report
 */"
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""FFr=QM"", ""FFr=QM"");
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, false);
    nameAnalyzer0.process(node0, node0);
    assertEquals(52, Node.LENGTH);
}",""
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test022() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""var t"", ""var t"");
    Node node1 = new Node(16, node0);
    nameAnalyzer0.process(node1, node0);
    assertFalse(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"public boolean hasChildren() {
    return first != null;
}","public void test023() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""var t"", ""var t"");
    Node node1 = new Node(16, node0);
    nameAnalyzer0.process(node1, node0);
    assertFalse(node0.hasChildren());
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test034() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""_jq$o^L?v_OW"", ""function JSCompiler_returnArg(JSCompiler_returnArg_value) {  return function() {return JSCompiler_returnArg_value}}"");
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    // Undeclared exception!
    try {
        nameAnalyzer0.process(node0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test045() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(130, 130, 130);
    Node node1 = new Node(37);
    node0.addChildToBack(node1);
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    // Undeclared exception!
    try {
        nameAnalyzer0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public boolean isRegExp() {
    return this.getType() == Token.REGEXP;
}","public void test056() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(148, ""B"");
    Node node1 = new Node(0, node0, node0, node0);
    Node node2 = new Node(16, node1);
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    nameAnalyzer0.process(node2, node1);
    assertFalse(node2.isRegExp());
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test067() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""com.<oogle.javascript.jscomp.CompilerOptions$TracerMode"", ""com.<oogle.javascript.jscomp.CompilerOptions$TracerMode"");
    Node node1 = new Node(37, 48, 1);
    node1.addChildToBack(node0);
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, false);
    nameAnalyzer0.process(node1, node1);
    assertEquals(2, Node.POST_FLAG);
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test078() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""window"", ""window"");
    nameAnalyzer0.process(node0, node0);
    assertEquals(45, Node.IS_VAR_ARGS_PARAM);
}",""
"public boolean hasChildren() {
    return first != null;
}","public void test089() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""com.google.javascript.jscomp.NameAnalyzer$ReferencePropagationCallback"", ""com.google.javascript.jscomp.NameAnalyzer$ReferencePropagationCallback"");
    nameAnalyzer0.process(node0, node0);
    assertTrue(node0.hasChildren());
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test0910() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = new Node(118);
    Node node1 = compiler0.parseSyntheticCode(""Pq0"", ""Pq0"");
    node0.addChildToBack(node1);
    // Undeclared exception!
    try {
        nameAnalyzer0.process(node0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test1011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(114, 114, 114);
    Node node1 = new Node(115);
    node0.addChildToBack(node1);
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, false);
    // Undeclared exception!
    try {
        nameAnalyzer0.process(node1, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public boolean isLabelName() {
    return this.getType() == Token.LABEL_NAME;
}","public void test1112() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-1791368267));
    Node node1 = new Node(4);
    node1.addChildToBack(node0);
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    nameAnalyzer0.process(node0, node1);
    assertFalse(node0.isLabelName());
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test1213() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, false);
    Node node0 = new Node(103, 103, 103);
    Node node1 = new Node(49, node0, node0, 8, 42);
    nameAnalyzer0.process(node1, node1);
    assertEquals(29, Node.JSDOC_INFO_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test1314() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = new Node(108, 108, 108);
    Node node1 = Node.newNumber((double) 16, 0, 49);
    node0.addChildToBack(node1);
    nameAnalyzer0.process(node1, node0);
    assertEquals(54, Node.LAST_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test1415() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = new Node(113);
    Node node1 = new Node(113);
    node1.addChildToBack(node0);
    nameAnalyzer0.process(node1, node1);
    assertEquals(45, Node.IS_VAR_ARGS_PARAM);
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test1516() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, false);
    Node node0 = new Node(119);
    Node node1 = new Node(8);
    node0.addChildToBack(node1);
    nameAnalyzer0.process(node0, node0);
    assertEquals(54, Node.LAST_PROP);
}",""
"public boolean isString() {
    return this.getType() == Token.STRING;
}","public void test1617() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = new Node(111);
    Node node1 = Node.newNumber((double) 30, 4, 46);
    node0.addChildToBack(node1);
    nameAnalyzer0.process(node0, node0);
    assertFalse(node0.isString());
}",""
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test1718() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = new Node(114);
    Node node1 = new Node(114);
    Node node2 = new Node(110, node0, node1, node0, node1, 12, 54);
    nameAnalyzer0.process(node0, node2);
    assertFalse(node2.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test1819() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = new Node(114);
    Node node1 = new Node(35);
    node0.addChildToBack(node1);
    // Undeclared exception!
    try {
        nameAnalyzer0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public boolean isThrow() {
    return this.getType() == Token.THROW;
}","public void test1920() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(97);
    Node node1 = new Node(0);
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node2 = new Node(114, node0, node0, node0, node1, 37, 42);
    nameAnalyzer0.process(node2, node2);
    assertFalse(node2.isThrow());
}",""
"public boolean isRegExp() {
    return this.getType() == Token.REGEXP;
}","public void test2021() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""var t"", ""var t"");
    Node node1 = new Node(16, node0);
    nameAnalyzer0.process(node0, node1);
    nameAnalyzer0.process(node1, node1);
    assertFalse(node1.isRegExp());
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendents. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test2122() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(148, ""FB"");
    Node node1 = new Node(16, node0);
    Node node2 = new Node(38, node1);
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, false);
    // Undeclared exception!
    try {
        nameAnalyzer0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test2223() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""var t;"", ""var t;"");
    nameAnalyzer0.process(node0, node0);
    assertEquals(1, node0.getChildCount());
}",""
"String getHtmlReport() {
    StringBuilder sb = new StringBuilder();
    sb.append(""<html><body><style type=\""text/css\"">"" + ""body, td, p {font-family: Arial; font-size: 83%} "" + ""ul {margin-top:2px; margin-left:0px; padding-left:1em;} "" + ""li {margin-top:3px; margin-left:24px; padding-left:0px;"" + ""padding-bottom: 4px}</style>"");
    sb.append(""OVERALL STATS<ul>"");
    appendListItem(sb, ""Total Names: "" + countOf(TriState.BOTH, TriState.BOTH));
    appendListItem(sb, ""Total Classes: "" + countOf(TriState.TRUE, TriState.BOTH));
    appendListItem(sb, ""Total Static Functions: "" + countOf(TriState.FALSE, TriState.BOTH));
    appendListItem(sb, ""Referenced Names: "" + countOf(TriState.BOTH, TriState.TRUE));
    appendListItem(sb, ""Referenced Classes: "" + countOf(TriState.TRUE, TriState.TRUE));
    appendListItem(sb, ""Referenced Functions: "" + countOf(TriState.FALSE, TriState.TRUE));
    sb.append(""</ul>"");
    sb.append(""ALL NAMES<ul>\n"");
    for (JsName node : allNames.values()) {
        sb.append(""<li>"" + nameAnchor(node.name) + ""<ul>"");
        if (node.prototypeNames.size() > 0) {
            sb.append(""<li>PROTOTYPES: "");
            Iterator<String> protoIter = node.prototypeNames.iterator();
            while (protoIter.hasNext()) {
                sb.append(protoIter.next());
                if (protoIter.hasNext()) {
                    sb.append("", "");
                }
            }
        }
        if (referenceGraph.hasNode(node)) {
            List<DiGraphEdge<JsName, RefType>> refersTo = referenceGraph.getOutEdges(node);
            if (refersTo.size() > 0) {
                sb.append(""<li>REFERS TO: "");
                Iterator<DiGraphEdge<JsName, RefType>> toIter = refersTo.iterator();
                while (toIter.hasNext()) {
                    sb.append(nameLink(toIter.next().getDestination().getValue().name));
                    if (toIter.hasNext()) {
                        sb.append("", "");
                    }
                }
            }
            List<DiGraphEdge<JsName, RefType>> referencedBy = referenceGraph.getInEdges(node);
            if (referencedBy.size() > 0) {
                sb.append(""<li>REFERENCED BY: "");
                Iterator<DiGraphEdge<JsName, RefType>> fromIter = refersTo.iterator();
                while (fromIter.hasNext()) {
                    sb.append(nameLink(fromIter.next().getDestination().getValue().name));
                    if (fromIter.hasNext()) {
                        sb.append("", "");
                    }
                }
            }
        }
        sb.append(""</li>"");
        sb.append(""</ul></li>"");
    }
    sb.append(""</ul>"");
    sb.append(""</body></html>"");
    return sb.toString();
}","public void test2224() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""var t;"", ""var t;"");
    nameAnalyzer0.process(node0, node0);
    String string0 = nameAnalyzer0.getHtmlReport();
    assertEquals(""<html><body><style type=\""text/css\"">body, td, p {font-family: Arial; font-size: 83%} ul {margin-top:2px; margin-left:0px; padding-left:1em;} li {margin-top:3px; margin-left:24px; padding-left:0px;padding-bottom: 4px}</style>OVERALL STATS<ul><li>Total Names: 2</li>\n<li>Total Classes: 0</li>\n<li>Total Static Functions: 2</li>\n<li>Referenced Names: 2</li>\n<li>Referenced Classes: 0</li>\n<li>Referenced Functions: 2</li>\n</ul>ALL NAMES<ul>\n<li><a name=\""Function\"">Function</a><ul></li></ul></li><li><a name=\""t\"">t</a><ul></li></ul></li><li><a name=\""window\"">window</a><ul></li></ul></li></ul></body></html>"", string0);
}","/**
 * Generates an HTML report
 *
 * @return The report
 */"
