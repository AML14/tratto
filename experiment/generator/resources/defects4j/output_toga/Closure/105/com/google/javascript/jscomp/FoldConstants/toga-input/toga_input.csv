focal_method,test_prefix,docstring
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test0000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""~1^]xH:vR?zrGN"");
    Node node1 = new Node(29);
    node1.addChildToFront(node0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node1, node0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test0001() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""~1^]xH:vR?zrGN"");
    Node node1 = new Node(29);
    node1.addChildToFront(node0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node1, node0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public void process(Node externs, Node jsRoot) {
    NodeTraversal.traverse(compiler, jsRoot, this);
}","public void test0012() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.process((Node) null, (Node) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"boolean hasBreakOrContinue(Node n) {
    // TODO(johnlenz): This is overkill as named breaks may refer to outer
    // loops or labels, and any break my refer to an inner loop.
    // More generally, this check may be more expensive than we like.
    return NodeUtil.has(n, Predicates.<Node>or(new NodeUtil.MatchNodeType(Token.BREAK), new NodeUtil.MatchNodeType(Token.CONTINUE)), Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION)));
}","public void test0023() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.hasBreakOrContinue((Node) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil$MatchNodeType"", e);
    }
}","/**
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test0034() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = new Node(661);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node1 = new Node(32, node0, node0, node0, 967, 115);
    foldConstants0.visit(nodeTraversal0, node1, node0);
    assertEquals(36, Node.OPT_ARG_NAME);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test0045() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((double) 661, 661, 661);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node1 = new Node(32, node0, node0, node0, 24, 1);
    // Undeclared exception!
    try {
        foldConstants0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"public void traverse(Node root) {
    try {
        sourceName = """";
        curNode = root;
        pushScope(root);
        traverseBranch(root, null);
        popScope();
    } catch (Exception unexpectedException) {
        throwUnexpectedException(unexpectedException);
    }
}","public void test0056() throws Throwable {
    FoldConstants foldConstants0 = new FoldConstants((AbstractCompiler) null);
    Node node0 = Node.newString(""rfo^0AJV+Bf0iZ5MVW"", 2389, 2389);
    Node node1 = Node.newString(32, ""rfo^0AJV+Bf0iZ5MVW"");
    node1.addChildrenToBack(node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal((AbstractCompiler) null, foldConstants0);
    // Undeclared exception!
    try {
        nodeTraversal0.traverse(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeTraversal"", e);
    }
}","/**
 * Traverses a parse tree recursively.
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test0067() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((double) 100, 100, 100);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node1 = new Node(26, node0, node0, node0);
    // Undeclared exception!
    try {
        foldConstants0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test0078() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = new Node(89, 89, 89);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node1 = new Node(27, node0, node0, node0, 33, 43);
    foldConstants0.visit(nodeTraversal0, node1, node0);
    assertFalse(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 * @return Whether the node has exactly one child.
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test0089() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((double) 89, 89, 89);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node1 = new Node(27, node0, node0, node0, 33, 43);
    // Undeclared exception!
    try {
        foldConstants0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test00910() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((double) 952, 952, 952);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node1 = new Node(30, node0, node0, node0, 3, 16);
    foldConstants0.visit(nodeTraversal0, node1, node1);
    assertEquals(4095, Node.COLUMN_MASK);
}",""
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test01011() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""JSC_INDEX_OUT_OF_BOUNDS_ERROR"", ""JSC_INDEX_OUT_OF_BOUNDS_ERROR"");
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) foldConstants0);
    assertEquals(1, Node.LEFT);
}","/**
 * Traverses a node recursively.
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test01112() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""JSCcINDEX_OUT_OFBO!NDS_ERR["", ""Array index out of ounds: {0}"");
    Node node1 = compiler0.parseSyntheticCode(""J$R_"", ""J$R_"");
    Node node2 = new Node(98, node0, node1, node1, 1, 29);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertEquals(2, Node.BREAK_PROP);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test01213() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""L5h?}~]/eN*3P}UO"");
    Node node1 = Node.newNumber((double) 46, 1, 9);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node2 = new Node(114, node0, node1, node1);
    // Undeclared exception!
    try {
        foldConstants0.visit((NodeTraversal) null, node2, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.FoldConstants"", e);
    }
}",""
"public int getLineno() {
    return extractLineno(sourcePosition);
}","public void test01314() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nL3wO ok,;%KU?tj"");
    Node node1 = Node.newNumber((double) 33, 78, 27);
    Node node2 = new Node(113, node1, node1, node0, 31, 43);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node2);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertEquals(31, node2.getLineno());
}",""
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test01315() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nL3wO ok,;%KU?tj"");
    Node node1 = Node.newNumber((double) 33, 78, 27);
    Node node2 = new Node(113, node1, node1, node0, 31, 43);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node2);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertEquals(43, node2.getCharno());
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test01416() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[0];
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
    Node node1 = Node.newString(""y"", 30, 9);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    Node node2 = compiler0.parseSyntheticCode(""y"", ""y"");
    Node node3 = new Node(115, node2, node1, node0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit(nodeTraversal0, node3, node1);
    assertEquals(11, Node.USES_PROP);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test01517() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""OBJECT_NUMBER_STRING_BOOLEAN"", ""OBJECT_NUMBER_STRING_BOOLEAN"");
    Node node1 = compiler0.parseSyntheticCode(""wgoo7.pro2ide"", ""OBJECT_NUMBER_STRING_BOOLEAN"");
    Node node2 = new Node(101, node0, node1, node1, 9, 29);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node1);
    assertEquals(1, Node.LEFT);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test01618() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""Object"", ""Object"");
    Node node1 = compiler0.parseSyntheticCode(""wgoo7.pro2ide"", ""Object"");
    Node node2 = new Node(100, node0, node1, node1, 9, 29);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node2);
    assertEquals(16, Node.SOURCENAME_PROP);
}",""
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test01719() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nL3wO ok,%KU?tj"");
    Node node1 = Node.newNumber(1631.3981567077049, 124, 4);
    CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccessControls0);
    Node node2 = new Node(9, node1, node0, node0, 1, 43);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertFalse(node2.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 * @return Whether the node has exactly one child.
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test01820() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[0];
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
    Node node1 = Node.newString("""", 7, 29);
    Node node2 = new Node(11, node0, node1);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertEquals(1, Node.LEFT);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test01921() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[0];
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
    Node node1 = compiler0.parseSyntheticCode(""=Z"", ""Y&g_I3OY"");
    Node node2 = new Node(19, node0, node0, node1, 45, 23);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit(nodeTraversal0, node2, node2);
    assertEquals((-2), Node.OBJECT_IDS_PROP);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test02022() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(63, 63, 63);
    Node node1 = Node.newString(""com.google.protobuf.DescriptorProtos$FieldOptions"");
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node2 = new Node(20, node0, node0, node1);
    foldConstants0.visit((NodeTraversal) null, node2, (Node) null);
    assertEquals(34, Node.PARENTHESIZED_PROP);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test02123() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nL3wO ok,;%KU?tj"");
    Node node1 = Node.newNumber((double) 33, 50, 27);
    Node node2 = new Node(33, node1, node1, node0, 31, 43);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node2);
    assertEquals(29, Node.VAR_ARGS_NAME);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test02224() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""ad LHS for assignent: "", ""ad LHS for assignent: "");
    Node node1 = Node.newString(""ad LHS for assignent: "", 38, 13);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node2 = new Node(37, node1, node1, node0, 11, (-3));
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, (Node) null);
    assertEquals(6, Node.TEMP_PROP);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test02325() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""JSC_INVALID_GETELEM_INDEX_ERROR"");
    Node node1 = Node.newNumber((double) 16, (-2), 15);
    Node node2 = new Node(86, node0, node0, node1, 47, 2);
    CompilerOptions compilerOptions0 = compiler0.createDefaultOptions();
    DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
    TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertEquals(1, Node.SPECIALCALL_EVAL);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test02426() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""%{6p[j0 EB|;//V6`U"", ""%{6p[j0 EB|;//V6`U"");
    Node node1 = compiler0.parseSyntheticCode(""@_}R^g{|y*S#0"", ""@_}R^g{|y*S#0"");
    Node node2 = new Node(14, node1, node0, node1, node0, 47, 8);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node1);
    assertEquals(16, Node.SOURCENAME_PROP);
}",""
"public boolean isOptionalArg() {
    return getBooleanProp(OPT_ARG_NAME);
}","public void test02527() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newString(""nXvAuOQrc\""CY\""1#(nX*"");
    Node node1 = new Node(34, 11, 29);
    Node node2 = new Node(88, node0, node1, node1, 8, 0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertFalse(node2.isOptionalArg());
}","/**
 * Returns whether this node is an optional argument node. This
 * method's return value is meaningful only on {@link Token#NAME} nodes
 * used to define a {@link Token#FUNCTION}'s argument list.
 */"
"public boolean isUnscopedQualifiedName() {
    switch(getType()) {
        case Token.NAME:
            return true;
        case Token.GETPROP:
            return getFirstChild().isUnscopedQualifiedName();
        default:
            return false;
    }
}","public void test02628() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = new Node(919);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0, (ScopeCreator) null);
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""aliasExternals"", ""aliasExternals"");
    Node node1 = compiler0.parse(jSSourceFile0);
    Node node2 = new Node(21, node0, node0, node1, 32, 8367);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertFalse(node2.isUnscopedQualifiedName());
}","/**
 * Returns whether a node corresponds to a simple or a qualified name
 * without a ""this"" reference, such as <code>a.b.c</code>, but not
 * <code>this.a</code>.
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test02729() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""$0"", ""*@U{7EAQl0\""mjQ"");
    Node node1 = new Node((-1431), 0, 9);
    Node node2 = new Node(16, node0, node1, node1, 2, 21);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit((NodeTraversal) null, node2, node0);
    assertEquals(18, Node.SPECIAL_PROP_PROP);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test02830() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(63, 63, 63);
    Node node1 = Node.newString(""com.google.protobuf.DescriptorProtos$FieldOptions"");
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node2 = new Node(21, node1, node0, node0, 2, 0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node2);
    assertEquals(7, Node.LOCAL_PROP);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test02931() throws Throwable {
    Compiler compiler0 = new Compiler();
    FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0, (ScopeCreator) null);
    Node node0 = Node.newNumber((double) 43, 46, 6);
    Node node1 = Node.newNumber((double) 4);
    Node node2 = new Node(22, node0, node0, node1, 4095, 4095);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.visit(nodeTraversal0, node2, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test03032() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(63, 63, 63);
    Node node1 = Node.newString(""G|hF3j)QgrO"");
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node2 = new Node(23, node0, node1);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertEquals(35, Node.QUOTED_PROP);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test03133() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""YP<lKyt1]Px="");
    Node node1 = Node.newNumber((-1122.0114), 31, (-2145755970));
    Node node2 = new Node(14, node1, node0, node0, 32, (-1830));
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node1);
    assertEquals(0, Node.BOTH);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test03234() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nLn3wOok,;%KU?tj"");
    Node node1 = Node.newNumber((double) 13, 43, 4);
    Node node2 = new Node(16, node0, node1);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node1);
    assertEquals(30, Node.SKIP_INDEXES_PROP);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test03335() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""JSC_INVALID_GETELEM_INDEX_ERROR"");
    Node node1 = Node.newNumber((double) 16, (-2), 15);
    Node node2 = new Node(12, node0, node0, node1, 47, 2);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
    TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertEquals(21, Node.LOCALCOUNT_PROP);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test03436() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nL3wO ok,;%KU?tj"");
    Node node1 = Node.newNumber((double) 13, 43, 4);
    Node node2 = new Node(13, node1, node1, node0, 958, 114);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertEquals(20, Node.FINALLY_PROP);
}",""
"public boolean hasChildren() {
    return first != null;
}","public void test03638() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""B1],N"", ""B1],N"");
    Node node1 = new Node(31, node0, node0, node0, 21, 9);
    node0.addChildrenToFront(node1);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node0, node1);
    assertTrue(node0.hasChildren());
}",""
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test03639() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""B1],N"", ""B1],N"");
    Node node1 = new Node(31, node0, node0, node0, 21, 9);
    node0.addChildrenToFront(node1);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node0, node1);
    assertTrue(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 * @return Whether the node has exactly one child.
 */"
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test03740() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node0 = compiler0.parseTestCode(""JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS"");
    foldConstants0.tryFoldBlock(nodeTraversal0, node0, node0);
    assertFalse(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 * @return Whether the node has exactly one child.
 */"
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test03741() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node0 = compiler0.parseTestCode(""JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS"");
    foldConstants0.tryFoldBlock(nodeTraversal0, node0, node0);
    assertEquals(0, node0.getChildCount());
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test03842() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""A~^]a]"", ""+im}H+{=X{5<"");
    foldConstants0.visit((NodeTraversal) null, node0, (Node) null);
    assertEquals(0, Node.BOTH);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test03943() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""nX%?uOQrc\""CY\""1!(nX*"", ""nX%?uOQrc\""CY\""1!(nX*"");
    Node node1 = new Node(132, node0, node0, node0, (-3584), 0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node0, node0);
    assertEquals(1, Node.LEFT);
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test04044() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[0];
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
    Node node1 = Node.newString(""y"", 30, 9);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    Node node2 = compiler0.parseSyntheticCode(""y"", ""y"");
    Node node3 = new Node(108, node2, node1, node0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.visit(nodeTraversal0, node3, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test04145() throws Throwable {
    Node node0 = Node.newString("""");
    Node node1 = Node.newNumber((double) 16, (-2), 15);
    Node node2 = new Node(108, node0, node0, node1, 47, 44);
    FoldConstants foldConstants0 = new FoldConstants((AbstractCompiler) null);
    Compiler compiler0 = new Compiler();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    // Undeclared exception!
    try {
        foldConstants0.visit(nodeTraversal0, node2, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Invalid attempt to remove node: IF 47 of NUMBER 16.0
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",""
"boolean tryFoldHookIf(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    Node cond = n.getFirstChild();
    Node thenBody = cond.getNext();
    Node elseBody = thenBody.getNext();
    boolean changes = false;
    if (type == Token.IF) {
        // if (x) { .. } else { } --> if (x) { ... }
        if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) {
            n.removeChild(elseBody);
            elseBody = null;
            t.getCompiler().reportCodeChange();
            changes = true;
        }
        // if (x) { } else { ... } --> if (!x) { ... }
        if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {
            n.removeChild(elseBody);
            n.replaceChild(thenBody, elseBody);
            Node notCond = new Node(Token.NOT);
            n.replaceChild(cond, notCond);
            notCond.addChildToFront(cond);
            cond = notCond;
            thenBody = cond.getNext();
            elseBody = null;
            t.getCompiler().reportCodeChange();
            changes = true;
        }
        // if (x()) { }
        if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) {
            if (NodeUtil.mayHaveSideEffects(cond)) {
                // x() has side effects, just leave the condition on its own.
                n.removeChild(cond);
                parent.replaceChild(n, NodeUtil.newExpr(cond));
            } else {
                // x() has no side effects, the whole tree is useless now.
                NodeUtil.removeChild(parent, n);
            }
            t.getCompiler().reportCodeChange();
            // The if has been removed. There is nothing to do.
            return true;
        }
    } else {
        Preconditions.checkState(type == Token.HOOK);
        if (NodeUtil.isExpressionNode(parent)) {
            // Try to remove useless nodes.
            if (!NodeUtil.mayHaveSideEffects(thenBody)) {
                // x?void 0:y --> if(!x)y
                Node ifNode = new Node(Token.IF);
                if (cond.getType() == Token.NOT) {
                    Node expr = cond.getFirstChild();
                    cond.removeChild(expr);
                    ifNode.addChildToBack(expr);
                } else {
                    Node not = new Node(Token.NOT);
                    n.removeChild(cond);
                    not.addChildToBack(cond);
                    ifNode.addChildToBack(not);
                }
                n.removeChild(elseBody);
                ifNode.addChildToBack(new Node(Token.BLOCK, NodeUtil.newExpr(elseBody)));
                parent.getParent().replaceChild(parent, ifNode);
                t.getCompiler().reportCodeChange();
                return true;
            } else if (!NodeUtil.mayHaveSideEffects(elseBody)) {
                // x?y:void 0 --> if(x)y
                Node ifNode = new Node(Token.IF);
                n.removeChild(cond);
                ifNode.addChildToBack(cond);
                n.removeChild(thenBody);
                ifNode.addChildToBack(new Node(Token.BLOCK, NodeUtil.newExpr(thenBody)));
                parent.getParent().replaceChild(parent, ifNode);
                t.getCompiler().reportCodeChange();
                return true;
            }
        }
    }
    // Try transforms that apply to both IF and HOOK.
    if (!NodeUtil.isLiteralValue(cond)) {
        // We can't remove branches otherwise!
        return changes;
    }
    boolean condTrue = NodeUtil.getBooleanValue(cond);
    if (n.getChildCount() == 2) {
        Preconditions.checkState(type == Token.IF);
        if (condTrue) {
            // Replace ""if (true) { X }"" with ""X"".
            Node thenStmt = n.getFirstChild().getNext();
            n.removeChild(thenStmt);
            parent.replaceChild(n, thenStmt);
            t.getCompiler().reportCodeChange();
        } else {
            // Replace ""if (false) { X }"" with empty node.
            NodeUtil.redeclareVarsInsideBranch(n);
            NodeUtil.removeChild(parent, n);
            t.getCompiler().reportCodeChange();
        }
    } else {
        // Replace ""if (true) { X } else { Y }"" with X, or
        // replace ""if (false) { X } else { Y }"" with Y.
        Node firstBranch = n.getFirstChild().getNext();
        Node secondBranch = firstBranch.getNext();
        Node branch = condTrue ? firstBranch : secondBranch;
        Node notBranch = condTrue ? secondBranch : firstBranch;
        NodeUtil.redeclareVarsInsideBranch(notBranch);
        n.removeChild(branch);
        parent.replaceChild(n, branch);
        t.getCompiler().reportCodeChange();
    }
    return true;
}","public void test04246() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode((String) null, ""Unexpected const change.\n  name: "");
    Node node1 = new Node(17, 7, 23);
    Node node2 = new Node(13, node0, node0, node1, (-3), 25);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldHookIf((NodeTraversal) null, node2, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Try folding :? (hook) and IF nodes by removing dead branches.
 * @return were any changes performed?
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test04347() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""JSC_INVLID_GETELEM_IDEk_ERROR"");
    Node node1 = Node.newNumber((double) 16, (-2), 15);
    Node node2 = new Node(98, node0, node0, node1, 47, 2);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
    TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.visit(nodeTraversal0, node2, node2);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"void tryMinimizeIf(NodeTraversal t, Node n, Node parent) {
    Node cond = n.getFirstChild();
    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();
    if (elseBranch == null) {
        if (isExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (isPropertyAssignmentInExpression(t, expr)) {
                // Keep opportunities for CollapseProperties such as
                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;
                return;
            }
            if (cond.getType() == Token.NOT) {
                // if(!x)bar(); -> x||bar();
                if (isLowerPrecedenceInExpression(t, cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(t, expr.getFirstChild(), OR_PRECEDENCE)) {
                    // It's not okay to add two sets of parentheses.
                    return;
                }
                Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild());
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                t.getCompiler().reportCodeChange();
                return;
            }
            // if(x)foo(); -> x&&foo();
            if (isLowerPrecedenceInExpression(t, cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(t, expr.getFirstChild(), AND_PRECEDENCE)) {
                // One additional set of parentheses isn't worth it.
                return;
            }
            n.removeChild(cond);
            Node and = new Node(Token.AND, cond, expr.removeFirstChild());
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    tryRemoveRepeatedStatements(t, n);
    // if(!x)foo();else bar(); -> if(x)bar();else foo();
    // An additional set of curly braces isn't worth it.
    if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        t.getCompiler().reportCodeChange();
        return;
    }
    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);
        thenExpr.detachFromParent();
        elseExpr.detachFromParent();
        // note - we ignore any cases with ""return;"", technically this
        // can be converted to ""return undefined;"" or some variant, but
        // that does not help code size.
        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
        Node returnNode = new Node(Token.RETURN, hookNode);
        parent.replaceChild(n, returnNode);
        t.getCompiler().reportCodeChange();
        return;
    }
    boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch);
    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType()) {
            // if(x)a=1;else a=2; -> a=x?1:2;
            if (NodeUtil.isAssignmentOp(thenOp)) {
                Node lhs = thenOp.getFirstChild();
                if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization
                // evaluates LHS before cond]
                // NOTE - there are some circumstances where we can
                // proceed even if there are side effects...
                !NodeUtil.mayEffectMutableState(lhs)) {
                    n.removeChild(cond);
                    Node assignName = thenOp.removeFirstChild();
                    Node thenExpr = thenOp.removeFirstChild();
                    Node elseExpr = elseOp.getLastChild();
                    elseOp.removeChild(elseExpr);
                    Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
                    Node assign = new Node(thenOp.getType(), assignName, hookNode);
                    Node expr = NodeUtil.newExpr(assign);
                    parent.replaceChild(n, expr);
                    t.getCompiler().reportCodeChange();
                }
            } else if (NodeUtil.isCall(thenOp)) {
                // if(x)foo();else bar(); -> x?foo():bar()
                n.removeChild(cond);
                thenOp.detachFromParent();
                elseOp.detachFromParent();
                Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp);
                Node expr = NodeUtil.newExpr(hookNode);
                parent.replaceChild(n, expr);
                t.getCompiler().reportCodeChange();
            }
        }
        return;
    }
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);
    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        Node name1 = var.getFirstChild();
        Node maybeName2 = elseAssign.getFirstChild();
        if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) {
            Node thenExpr = name1.removeChildren();
            Node elseExpr = elseAssign.getLastChild().detachFromParent();
            cond.detachFromParent();
            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
            var.detachFromParent();
            name1.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            t.getCompiler().reportCodeChange();
        }
        // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        Node maybeName1 = thenAssign.getFirstChild();
        Node name2 = var.getFirstChild();
        if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) {
            Node thenExpr = thenAssign.getLastChild().detachFromParent();
            Node elseExpr = name2.removeChildren();
            cond.detachFromParent();
            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
            var.detachFromParent();
            name2.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            t.getCompiler().reportCodeChange();
        }
    }
}","public void test04448() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[0];
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
    Node node1 = Node.newString(""4"", 30, 23);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    Node node2 = compiler0.parseSyntheticCode(""4"", ""4"");
    Node node3 = new Node(112, node2, node1, node0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.tryMinimizeIf(nodeTraversal0, node3, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Try turning IF nodes into smaller HOOKs
 */"
"void tryMinimizeIf(NodeTraversal t, Node n, Node parent) {
    Node cond = n.getFirstChild();
    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();
    if (elseBranch == null) {
        if (isExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (isPropertyAssignmentInExpression(t, expr)) {
                // Keep opportunities for CollapseProperties such as
                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;
                return;
            }
            if (cond.getType() == Token.NOT) {
                // if(!x)bar(); -> x||bar();
                if (isLowerPrecedenceInExpression(t, cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(t, expr.getFirstChild(), OR_PRECEDENCE)) {
                    // It's not okay to add two sets of parentheses.
                    return;
                }
                Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild());
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                t.getCompiler().reportCodeChange();
                return;
            }
            // if(x)foo(); -> x&&foo();
            if (isLowerPrecedenceInExpression(t, cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(t, expr.getFirstChild(), AND_PRECEDENCE)) {
                // One additional set of parentheses isn't worth it.
                return;
            }
            n.removeChild(cond);
            Node and = new Node(Token.AND, cond, expr.removeFirstChild());
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    tryRemoveRepeatedStatements(t, n);
    // if(!x)foo();else bar(); -> if(x)bar();else foo();
    // An additional set of curly braces isn't worth it.
    if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        t.getCompiler().reportCodeChange();
        return;
    }
    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);
        thenExpr.detachFromParent();
        elseExpr.detachFromParent();
        // note - we ignore any cases with ""return;"", technically this
        // can be converted to ""return undefined;"" or some variant, but
        // that does not help code size.
        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
        Node returnNode = new Node(Token.RETURN, hookNode);
        parent.replaceChild(n, returnNode);
        t.getCompiler().reportCodeChange();
        return;
    }
    boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch);
    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType()) {
            // if(x)a=1;else a=2; -> a=x?1:2;
            if (NodeUtil.isAssignmentOp(thenOp)) {
                Node lhs = thenOp.getFirstChild();
                if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization
                // evaluates LHS before cond]
                // NOTE - there are some circumstances where we can
                // proceed even if there are side effects...
                !NodeUtil.mayEffectMutableState(lhs)) {
                    n.removeChild(cond);
                    Node assignName = thenOp.removeFirstChild();
                    Node thenExpr = thenOp.removeFirstChild();
                    Node elseExpr = elseOp.getLastChild();
                    elseOp.removeChild(elseExpr);
                    Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
                    Node assign = new Node(thenOp.getType(), assignName, hookNode);
                    Node expr = NodeUtil.newExpr(assign);
                    parent.replaceChild(n, expr);
                    t.getCompiler().reportCodeChange();
                }
            } else if (NodeUtil.isCall(thenOp)) {
                // if(x)foo();else bar(); -> x?foo():bar()
                n.removeChild(cond);
                thenOp.detachFromParent();
                elseOp.detachFromParent();
                Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp);
                Node expr = NodeUtil.newExpr(hookNode);
                parent.replaceChild(n, expr);
                t.getCompiler().reportCodeChange();
            }
        }
        return;
    }
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);
    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        Node name1 = var.getFirstChild();
        Node maybeName2 = elseAssign.getFirstChild();
        if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) {
            Node thenExpr = name1.removeChildren();
            Node elseExpr = elseAssign.getLastChild().detachFromParent();
            cond.detachFromParent();
            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
            var.detachFromParent();
            name1.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            t.getCompiler().reportCodeChange();
        }
        // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        Node maybeName1 = thenAssign.getFirstChild();
        Node name2 = var.getFirstChild();
        if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) {
            Node thenExpr = thenAssign.getLastChild().detachFromParent();
            Node elseExpr = name2.removeChildren();
            cond.detachFromParent();
            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
            var.detachFromParent();
            name2.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            t.getCompiler().reportCodeChange();
        }
    }
}","public void test04549() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""Bad LS for assignmen: "", ""Bad LS for assignmen: "");
    Node node1 = Node.newString(""Bad LS for assignmen: "", 38, 13);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node2 = new Node(26, node1, node0, 48, 21);
    foldConstants0.tryMinimizeIf((NodeTraversal) null, node2, node0);
    assertEquals(4, Node.ENUM_PROP);
}","/**
 * Try turning IF nodes into smaller HOOKs
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test04650() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node0 = new Node(4);
    Node node1 = new Node(38);
    node0.addChildToFront(node1);
    // Undeclared exception!
    try {
        foldConstants0.visit(nodeTraversal0, node0, node0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // NAME is not a string node
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test04751() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node0 = new Node(4);
    node0.addChildToFront(node0);
    foldConstants0.visit(nodeTraversal0, node0, node0);
    assertEquals(45, Node.IS_VAR_ARGS_PARAM);
}",""
"public boolean hasMoreThanOneChild() {
    return first != null && first != last;
}","public void test04852() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Sez'1/_>]a"");
    Node node0 = new Node(122, 122, 122);
    SyntheticAst syntheticAst0 = new SyntheticAst(""Sez'1/_>]a"");
    Compiler compiler0 = new Compiler(mockPrintStream0);
    Node node1 = syntheticAst0.getAstRoot(compiler0);
    node0.addChildrenToBack(node1);
    Node node2 = new Node(4, node0, node0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit((NodeTraversal) null, node2, node1);
    assertFalse(node2.hasMoreThanOneChild());
}","/**
 * Check for more than one child more efficiently than by iterating over all
 * the children as is done with Node.getChildCount().
 * @return Whether the node more than one child.
 */"
"void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    Node result = null;
    int type = n.getType();
    if (NodeUtil.isLiteralValue(left)) {
        boolean lval = NodeUtil.getBooleanValue(left);
        // (TRUE || x) => TRUE (also, (3 || x) => 3)
        // (FALSE && x) => FALSE
        if (lval && type == Token.OR || !lval && type == Token.AND) {
            result = left;
        } else {
            // (FALSE || x) => x
            // (TRUE && x) => x
            result = right;
        }
    } else if (NodeUtil.isLiteralValue(right)) {
        // Note: We cannot always fold when the constant is on the
        // right, because the typed value of the expression will depend
        // on the type of the constant on the right, even if the boolean
        // equivalent of the value does not. Specifically, in ""a = x ||
        // 0"", a will be numeric 0 if x is undefined (and hence is
        // e.g. a valid array index). However, it is safe to fold
        // e.g. ""if (x || true)"" because 'if' doesn't care if the
        // expression is 'true' or '3'.
        int pt = parent.getType();
        if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) || (pt == Token.HOOK && parent.getFirstChild() == n)) {
            boolean rval = NodeUtil.getBooleanValue(right);
            // (x || FALSE) => x
            // (x && TRUE) => x
            if (type == Token.OR && !rval || type == Token.AND && rval) {
                result = left;
            } else {
                // If x has no side-effects:
                //   (x || TRUE) => TRUE
                //   (x && FALSE) => FALSE
                if (!NodeUtil.mayHaveSideEffects(left)) {
                    result = right;
                }
            }
        }
    }
    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so
    // there is not much need to worry about const values on left's
    // right child.
    if (result != null) {
        // Fold it!
        n.removeChild(result);
        parent.replaceChild(n, result);
        t.getCompiler().reportCodeChange();
    }
}","public void test04953() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((-2.147483648E9));
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldAndOr(nodeTraversal0, node0, node0, node0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold a AND/OR node.
 */"
"void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    Node result = null;
    int type = n.getType();
    if (NodeUtil.isLiteralValue(left)) {
        boolean lval = NodeUtil.getBooleanValue(left);
        // (TRUE || x) => TRUE (also, (3 || x) => 3)
        // (FALSE && x) => FALSE
        if (lval && type == Token.OR || !lval && type == Token.AND) {
            result = left;
        } else {
            // (FALSE || x) => x
            // (TRUE && x) => x
            result = right;
        }
    } else if (NodeUtil.isLiteralValue(right)) {
        // Note: We cannot always fold when the constant is on the
        // right, because the typed value of the expression will depend
        // on the type of the constant on the right, even if the boolean
        // equivalent of the value does not. Specifically, in ""a = x ||
        // 0"", a will be numeric 0 if x is undefined (and hence is
        // e.g. a valid array index). However, it is safe to fold
        // e.g. ""if (x || true)"" because 'if' doesn't care if the
        // expression is 'true' or '3'.
        int pt = parent.getType();
        if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) || (pt == Token.HOOK && parent.getFirstChild() == n)) {
            boolean rval = NodeUtil.getBooleanValue(right);
            // (x || FALSE) => x
            // (x && TRUE) => x
            if (type == Token.OR && !rval || type == Token.AND && rval) {
                result = left;
            } else {
                // If x has no side-effects:
                //   (x || TRUE) => TRUE
                //   (x && FALSE) => FALSE
                if (!NodeUtil.mayHaveSideEffects(left)) {
                    result = right;
                }
            }
        }
    }
    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so
    // there is not much need to worry about const values on left's
    // right child.
    if (result != null) {
        // Fold it!
        n.removeChild(result);
        parent.replaceChild(n, result);
        t.getCompiler().reportCodeChange();
    }
}","public void test05054() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString("""");
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldAndOr(nodeTraversal0, node0, node0, node0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold a AND/OR node.
 */"
"void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    Node result = null;
    int type = n.getType();
    if (NodeUtil.isLiteralValue(left)) {
        boolean lval = NodeUtil.getBooleanValue(left);
        // (TRUE || x) => TRUE (also, (3 || x) => 3)
        // (FALSE && x) => FALSE
        if (lval && type == Token.OR || !lval && type == Token.AND) {
            result = left;
        } else {
            // (FALSE || x) => x
            // (TRUE && x) => x
            result = right;
        }
    } else if (NodeUtil.isLiteralValue(right)) {
        // Note: We cannot always fold when the constant is on the
        // right, because the typed value of the expression will depend
        // on the type of the constant on the right, even if the boolean
        // equivalent of the value does not. Specifically, in ""a = x ||
        // 0"", a will be numeric 0 if x is undefined (and hence is
        // e.g. a valid array index). However, it is safe to fold
        // e.g. ""if (x || true)"" because 'if' doesn't care if the
        // expression is 'true' or '3'.
        int pt = parent.getType();
        if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) || (pt == Token.HOOK && parent.getFirstChild() == n)) {
            boolean rval = NodeUtil.getBooleanValue(right);
            // (x || FALSE) => x
            // (x && TRUE) => x
            if (type == Token.OR && !rval || type == Token.AND && rval) {
                result = left;
            } else {
                // If x has no side-effects:
                //   (x || TRUE) => TRUE
                //   (x && FALSE) => FALSE
                if (!NodeUtil.mayHaveSideEffects(left)) {
                    result = right;
                }
            }
        }
    }
    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so
    // there is not much need to worry about const values on left's
    // right child.
    if (result != null) {
        // Fold it!
        n.removeChild(result);
        parent.replaceChild(n, result);
        t.getCompiler().reportCodeChange();
    }
}","public void test05155() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""com.google.common.coll2c.Immutablet$ArrayImmutabliSet"", 45, 82);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node1 = new Node(100);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldAndOr((NodeTraversal) null, node1, node0, node0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold a AND/OR node.
 */"
"void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    Node result = null;
    int type = n.getType();
    if (NodeUtil.isLiteralValue(left)) {
        boolean lval = NodeUtil.getBooleanValue(left);
        // (TRUE || x) => TRUE (also, (3 || x) => 3)
        // (FALSE && x) => FALSE
        if (lval && type == Token.OR || !lval && type == Token.AND) {
            result = left;
        } else {
            // (FALSE || x) => x
            // (TRUE && x) => x
            result = right;
        }
    } else if (NodeUtil.isLiteralValue(right)) {
        // Note: We cannot always fold when the constant is on the
        // right, because the typed value of the expression will depend
        // on the type of the constant on the right, even if the boolean
        // equivalent of the value does not. Specifically, in ""a = x ||
        // 0"", a will be numeric 0 if x is undefined (and hence is
        // e.g. a valid array index). However, it is safe to fold
        // e.g. ""if (x || true)"" because 'if' doesn't care if the
        // expression is 'true' or '3'.
        int pt = parent.getType();
        if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) || (pt == Token.HOOK && parent.getFirstChild() == n)) {
            boolean rval = NodeUtil.getBooleanValue(right);
            // (x || FALSE) => x
            // (x && TRUE) => x
            if (type == Token.OR && !rval || type == Token.AND && rval) {
                result = left;
            } else {
                // If x has no side-effects:
                //   (x || TRUE) => TRUE
                //   (x && FALSE) => FALSE
                if (!NodeUtil.mayHaveSideEffects(left)) {
                    result = right;
                }
            }
        }
    }
    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so
    // there is not much need to worry about const values on left's
    // right child.
    if (result != null) {
        // Fold it!
        n.removeChild(result);
        parent.replaceChild(n, result);
        t.getCompiler().reportCodeChange();
    }
}","public void test05256() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nL3wO ok,;%KU?tj"");
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    File file0 = MockFile.createTempFile(""+8hb[9J(5_f#(~Rb>_J"", ""@Q|RhYK"");
    SourceFile.OnDisk sourceFile_OnDisk0 = new SourceFile.OnDisk(file0);
    JsAst jsAst0 = new JsAst(sourceFile_OnDisk0);
    Node node1 = jsAst0.getAstRoot(compiler0);
    foldConstants0.tryFoldAndOr(nodeTraversal0, node0, node1, node0, node0);
    assertEquals(2, Node.RIGHT);
}","/**
 * Try to fold a AND/OR node.
 */"
"void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    Node result = null;
    int type = n.getType();
    if (NodeUtil.isLiteralValue(left)) {
        boolean lval = NodeUtil.getBooleanValue(left);
        // (TRUE || x) => TRUE (also, (3 || x) => 3)
        // (FALSE && x) => FALSE
        if (lval && type == Token.OR || !lval && type == Token.AND) {
            result = left;
        } else {
            // (FALSE || x) => x
            // (TRUE && x) => x
            result = right;
        }
    } else if (NodeUtil.isLiteralValue(right)) {
        // Note: We cannot always fold when the constant is on the
        // right, because the typed value of the expression will depend
        // on the type of the constant on the right, even if the boolean
        // equivalent of the value does not. Specifically, in ""a = x ||
        // 0"", a will be numeric 0 if x is undefined (and hence is
        // e.g. a valid array index). However, it is safe to fold
        // e.g. ""if (x || true)"" because 'if' doesn't care if the
        // expression is 'true' or '3'.
        int pt = parent.getType();
        if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) || (pt == Token.HOOK && parent.getFirstChild() == n)) {
            boolean rval = NodeUtil.getBooleanValue(right);
            // (x || FALSE) => x
            // (x && TRUE) => x
            if (type == Token.OR && !rval || type == Token.AND && rval) {
                result = left;
            } else {
                // If x has no side-effects:
                //   (x || TRUE) => TRUE
                //   (x && FALSE) => FALSE
                if (!NodeUtil.mayHaveSideEffects(left)) {
                    result = right;
                }
            }
        }
    }
    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so
    // there is not much need to worry about const values on left's
    // right child.
    if (result != null) {
        // Fold it!
        n.removeChild(result);
        parent.replaceChild(n, result);
        t.getCompiler().reportCodeChange();
    }
}","public void test05357() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString("""");
    Node node1 = new Node(108, node0, node0, node0, 47, 44);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0, syntacticScopeCreator0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldAndOr(nodeTraversal0, node1, node1, node0, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold a AND/OR node.
 */"
"void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    Node result = null;
    int type = n.getType();
    if (NodeUtil.isLiteralValue(left)) {
        boolean lval = NodeUtil.getBooleanValue(left);
        // (TRUE || x) => TRUE (also, (3 || x) => 3)
        // (FALSE && x) => FALSE
        if (lval && type == Token.OR || !lval && type == Token.AND) {
            result = left;
        } else {
            // (FALSE || x) => x
            // (TRUE && x) => x
            result = right;
        }
    } else if (NodeUtil.isLiteralValue(right)) {
        // Note: We cannot always fold when the constant is on the
        // right, because the typed value of the expression will depend
        // on the type of the constant on the right, even if the boolean
        // equivalent of the value does not. Specifically, in ""a = x ||
        // 0"", a will be numeric 0 if x is undefined (and hence is
        // e.g. a valid array index). However, it is safe to fold
        // e.g. ""if (x || true)"" because 'if' doesn't care if the
        // expression is 'true' or '3'.
        int pt = parent.getType();
        if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) || (pt == Token.HOOK && parent.getFirstChild() == n)) {
            boolean rval = NodeUtil.getBooleanValue(right);
            // (x || FALSE) => x
            // (x && TRUE) => x
            if (type == Token.OR && !rval || type == Token.AND && rval) {
                result = left;
            } else {
                // If x has no side-effects:
                //   (x || TRUE) => TRUE
                //   (x && FALSE) => FALSE
                if (!NodeUtil.mayHaveSideEffects(left)) {
                    result = right;
                }
            }
        }
    }
    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so
    // there is not much need to worry about const values on left's
    // right child.
    if (result != null) {
        // Fold it!
        n.removeChild(result);
        parent.replaceChild(n, result);
        t.getCompiler().reportCodeChange();
    }
}","public void test05458() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nL3wO ok,;%KU?tj"");
    Node node1 = new Node(113, node0, node0, node0, 31, 43);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    File file0 = MockFile.createTempFile(""+8hb[9J(5_f#(~Rb>_J"", ""@Q|RhYK"");
    SourceFile.OnDisk sourceFile_OnDisk0 = new SourceFile.OnDisk(file0);
    JsAst jsAst0 = new JsAst(sourceFile_OnDisk0);
    Node node2 = jsAst0.getAstRoot(compiler0);
    foldConstants0.tryFoldAndOr(nodeTraversal0, node0, node2, node0, node1);
    assertEquals(19, Node.LABEL_PROP);
}","/**
 * Try to fold a AND/OR node.
 */"
"void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    Node result = null;
    int type = n.getType();
    if (NodeUtil.isLiteralValue(left)) {
        boolean lval = NodeUtil.getBooleanValue(left);
        // (TRUE || x) => TRUE (also, (3 || x) => 3)
        // (FALSE && x) => FALSE
        if (lval && type == Token.OR || !lval && type == Token.AND) {
            result = left;
        } else {
            // (FALSE || x) => x
            // (TRUE && x) => x
            result = right;
        }
    } else if (NodeUtil.isLiteralValue(right)) {
        // Note: We cannot always fold when the constant is on the
        // right, because the typed value of the expression will depend
        // on the type of the constant on the right, even if the boolean
        // equivalent of the value does not. Specifically, in ""a = x ||
        // 0"", a will be numeric 0 if x is undefined (and hence is
        // e.g. a valid array index). However, it is safe to fold
        // e.g. ""if (x || true)"" because 'if' doesn't care if the
        // expression is 'true' or '3'.
        int pt = parent.getType();
        if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) || (pt == Token.HOOK && parent.getFirstChild() == n)) {
            boolean rval = NodeUtil.getBooleanValue(right);
            // (x || FALSE) => x
            // (x && TRUE) => x
            if (type == Token.OR && !rval || type == Token.AND && rval) {
                result = left;
            } else {
                // If x has no side-effects:
                //   (x || TRUE) => TRUE
                //   (x && FALSE) => FALSE
                if (!NodeUtil.mayHaveSideEffects(left)) {
                    result = right;
                }
            }
        }
    }
    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so
    // there is not much need to worry about const values on left's
    // right child.
    if (result != null) {
        // Fold it!
        n.removeChild(result);
        parent.replaceChild(n, result);
        t.getCompiler().reportCodeChange();
    }
}","public void test05559() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[0];
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
    Node node1 = Node.newString(""j"", 30, 39);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    Node node2 = compiler0.parseSyntheticCode(""j"", ""j"");
    Node node3 = new Node(115, node2, node1, node0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.tryFoldAndOr(nodeTraversal0, node3, node3, node1, node3);
    assertEquals(42, Node.NO_SIDE_EFFECTS_CALL);
}","/**
 * Try to fold a AND/OR node.
 */"
"void tryFoldLeftChildAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (NodeUtil.isLiteralValue(right) && left.getType() == Token.ADD && left.getChildCount() == 2) {
        Node ll = left.getFirstChild();
        Node lr = ll.getNext();
        // Left's right child MUST be a string. We would not want to fold
        // foo() + 2 + 'a' because we don't know what foo() will return, and
        // therefore we don't know if left is a string concat, or a numeric add.
        if (lr.getType() != Token.STRING)
            return;
        String leftString = NodeUtil.getStringValue(lr);
        String rightString = NodeUtil.getStringValue(right);
        if (leftString != null && rightString != null) {
            left.removeChild(ll);
            String result = leftString + rightString;
            n.replaceChild(left, ll);
            n.replaceChild(right, Node.newString(result));
            t.getCompiler().reportCodeChange();
        }
    }
}","public void test05660() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0, (ScopeCreator) null);
    Node node0 = Node.newNumber((double) 834, 834, 834);
    foldConstants0.tryFoldLeftChildAdd(nodeTraversal0, node0, node0, node0, node0);
    assertEquals(1, Node.SPECIALCALL_EVAL);
}","/**
 * Expressions such as [foo() + 'a' + 'b'] generate parse trees
 * where no node has two const children ((foo() + 'a') + 'b'), so
 * tryFoldAdd() won't fold it -- tryFoldLeftChildAdd() will (for Strings).
 * Specifically it folds Add exprssions where:
 *  - The left child is also and add expression
 *  - The right child is a constant value
 *  - The left child's right child is a STRING constant.
 *
 * WARNING: If javascript ever adds operator overloading, this will
 * probably stop being correct.
 */"
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test05761() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((double) 661, 661, 661);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node1 = new Node(21, node0);
    foldConstants0.tryFoldLeftChildAdd(nodeTraversal0, node0, node1, node0, node1);
    assertTrue(node1.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 * @return Whether the node has exactly one child.
 */"
"void tryFoldAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (left.getType() == Token.STRING || right.getType() == Token.STRING) {
        // Add strings.
        String leftString = NodeUtil.getStringValue(left);
        String rightString = NodeUtil.getStringValue(right);
        if (leftString != null && rightString != null) {
            parent.replaceChild(n, Node.newString(leftString + rightString));
            t.getCompiler().reportCodeChange();
        }
    } else {
        // Try arithmetic add
        tryFoldArithmetic(t, n, left, right, parent);
    }
}","public void test05862() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0, (ScopeCreator) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType[] jSTypeArray0 = new JSType[4];
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    jSTypeArray0[3] = (JSType) objectType0;
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
    foldConstants0.tryFoldAdd(nodeTraversal0, node0, node0, node0, node0);
    assertEquals((-1), Node.CATCH_SCOPE_PROP);
}","/**
 * Try to fold a ADD node
 */"
"public boolean hasMoreThanOneChild() {
    return first != null && first != last;
}","public void test05963() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""gAu_4\"""", ""gAu_4\"""");
    Node node1 = Node.newString(""gAu_4\"""", 38, 13);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryFoldAdd(nodeTraversal0, node0, node0, node1, node0);
    assertFalse(node0.hasMoreThanOneChild());
}","/**
 * Check for more than one child more efficiently than by iterating over all
 * the children as is done with Node.getChildCount().
 * @return Whether the node more than one child.
 */"
"void tryFoldAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (left.getType() == Token.STRING || right.getType() == Token.STRING) {
        // Add strings.
        String leftString = NodeUtil.getStringValue(left);
        String rightString = NodeUtil.getStringValue(right);
        if (leftString != null && rightString != null) {
            parent.replaceChild(n, Node.newString(leftString + rightString));
            t.getCompiler().reportCodeChange();
        }
    } else {
        // Try arithmetic add
        tryFoldArithmetic(t, n, left, right, parent);
    }
}","public void test06064() throws Throwable {
    Compiler compiler0 = new Compiler();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    Node node0 = Node.newString(40, ""Y&g_I3OY"", 40, 40);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldAdd(nodeTraversal0, node0, node0, node0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold a ADD node
 */"
"void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();
        switch(n.getType()) {
            case Token.ADD:
                result = lval + rval;
                break;
            case Token.SUB:
                result = lval - rval;
                break;
            case Token.MUL:
                result = lval * rval;
                break;
            case Token.DIV:
                if (rval == 0) {
                    error(t, DIVIDE_BY_0_ERROR, right);
                    return;
                }
                result = lval / rval;
                break;
            default:
                throw new Error(""Unknown arithmetic operator"");
        }
        // length of the left and right value plus 1 byte for the operator.
        if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {
            parent.replaceChild(n, Node.newNumber(result));
            t.getCompiler().reportCodeChange();
        }
    }
}","public void test06165() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0, (ScopeCreator) null);
    Node node0 = Node.newNumber((double) 856, 856, 856);
    Node node1 = new Node(4, node0);
    foldConstants0.tryFoldArithmetic(nodeTraversal0, node1, node0, node1, node1);
    assertEquals(15, Node.CASEARRAY_PROP);
}","/**
 * Try to fold arithmetic binary operators
 */"
"void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();
        switch(n.getType()) {
            case Token.ADD:
                result = lval + rval;
                break;
            case Token.SUB:
                result = lval - rval;
                break;
            case Token.MUL:
                result = lval * rval;
                break;
            case Token.DIV:
                if (rval == 0) {
                    error(t, DIVIDE_BY_0_ERROR, right);
                    return;
                }
                result = lval / rval;
                break;
            default:
                throw new Error(""Unknown arithmetic operator"");
        }
        // length of the left and right value plus 1 byte for the operator.
        if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {
            parent.replaceChild(n, Node.newNumber(result));
            t.getCompiler().reportCodeChange();
        }
    }
}","public void test06266() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0, (ScopeCreator) null);
    Node node0 = Node.newNumber((double) 856, 856, 856);
    Node node1 = new Node(21, node0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldArithmetic(nodeTraversal0, node1, node0, node0, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // node is not a child
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold arithmetic binary operators
 */"
"void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();
        switch(n.getType()) {
            case Token.ADD:
                result = lval + rval;
                break;
            case Token.SUB:
                result = lval - rval;
                break;
            case Token.MUL:
                result = lval * rval;
                break;
            case Token.DIV:
                if (rval == 0) {
                    error(t, DIVIDE_BY_0_ERROR, right);
                    return;
                }
                result = lval / rval;
                break;
            default:
                throw new Error(""Unknown arithmetic operator"");
        }
        // length of the left and right value plus 1 byte for the operator.
        if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {
            parent.replaceChild(n, Node.newNumber(result));
            t.getCompiler().reportCodeChange();
        }
    }
}","public void test06367() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0, (ScopeCreator) null);
    Node node0 = Node.newNumber((double) 856, 856, 856);
    Node node1 = new Node(24, node0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldArithmetic(nodeTraversal0, node1, node0, node0, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // node is not a child
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold arithmetic binary operators
 */"
"void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();
        switch(n.getType()) {
            case Token.ADD:
                result = lval + rval;
                break;
            case Token.SUB:
                result = lval - rval;
                break;
            case Token.MUL:
                result = lval * rval;
                break;
            case Token.DIV:
                if (rval == 0) {
                    error(t, DIVIDE_BY_0_ERROR, right);
                    return;
                }
                result = lval / rval;
                break;
            default:
                throw new Error(""Unknown arithmetic operator"");
        }
        // length of the left and right value plus 1 byte for the operator.
        if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {
            parent.replaceChild(n, Node.newNumber(result));
            t.getCompiler().reportCodeChange();
        }
    }
}","public void test06468() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((double) 100, 100, 100);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldArithmetic(nodeTraversal0, node0, node0, node0, node0);
        fail(""Expecting exception: Error"");
    } catch (Error e) {
        //
        // Unknown arithmetic operator
        //
        verifyException(""com.google.javascript.jscomp.FoldConstants"", e);
    }
}","/**
 * Try to fold arithmetic binary operators
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test06569() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nL3wO ok,%KU?tj"");
    Node node1 = Node.newNumber(1631.3981567077049, 124, 4);
    CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccessControls0);
    Node node2 = Node.newNumber((-458.11));
    Node node3 = new Node(9, node1, node2, node2, 1, 43);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit(nodeTraversal0, node3, node0);
    assertEquals(0, Node.LABEL_ID_PROP);
}",""
"void tryFoldBitAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();
        // For now, we are being extra conservative, and only folding ints in
        // the range MIN_VALUE-MAX_VALUE
        if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) {
            // Fall back through and let the javascript use the larger values
            return;
        }
        // Convert the numbers to ints
        int lvalInt = (int) lval;
        if (lvalInt != lval) {
            return;
        }
        int rvalInt = (int) rval;
        if (rvalInt != rval) {
            return;
        }
        switch(n.getType()) {
            case Token.BITAND:
                result = lvalInt & rvalInt;
                break;
            case Token.BITOR:
                result = lvalInt | rvalInt;
                break;
            default:
                throw new Error(""Unknown bitwise operator"");
        }
        parent.replaceChild(n, Node.newNumber(result));
        t.getCompiler().reportCodeChange();
    }
}","public void test06670() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((-2.1474836492406154E9));
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryFoldBitAndOr(nodeTraversal0, node0, node0, node0, node0);
    assertEquals(9, Node.FIXUPS_PROP);
}","/**
 * Try to fold arithmetic binary operators
 */"
"public boolean isUnscopedQualifiedName() {
    switch(getType()) {
        case Token.NAME:
            return true;
        case Token.GETPROP:
            return getFirstChild().isUnscopedQualifiedName();
        default:
            return false;
    }
}","public void test06771() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber(4.294967296E9);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryFoldBitAndOr(nodeTraversal0, node0, node0, node0, node0);
    assertFalse(node0.isUnscopedQualifiedName());
}","/**
 * Returns whether a node corresponds to a simple or a qualified name
 * without a ""this"" reference, such as <code>a.b.c</code>, but not
 * <code>this.a</code>.
 */"
"void tryFoldBitAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();
        // For now, we are being extra conservative, and only folding ints in
        // the range MIN_VALUE-MAX_VALUE
        if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) {
            // Fall back through and let the javascript use the larger values
            return;
        }
        // Convert the numbers to ints
        int lvalInt = (int) lval;
        if (lvalInt != lval) {
            return;
        }
        int rvalInt = (int) rval;
        if (rvalInt != rval) {
            return;
        }
        switch(n.getType()) {
            case Token.BITAND:
                result = lvalInt & rvalInt;
                break;
            case Token.BITOR:
                result = lvalInt | rvalInt;
                break;
            default:
                throw new Error(""Unknown bitwise operator"");
        }
        parent.replaceChild(n, Node.newNumber(result));
        t.getCompiler().reportCodeChange();
    }
}","public void test06872() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((-2.147483648E9));
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldBitAndOr(nodeTraversal0, node0, node0, node0, node0);
        fail(""Expecting exception: Error"");
    } catch (Error e) {
        //
        // Unknown bitwise operator
        //
        verifyException(""com.google.javascript.jscomp.FoldConstants"", e);
    }
}","/**
 * Try to fold arithmetic binary operators
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test06973() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) (-3568), (-3568), 70);
    CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccessControls0);
    Node node1 = Node.newNumber((-3392.08727231292));
    Node node2 = new Node(18, node1, node0, node0, 1936, 49);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test06974() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) (-3568), (-3568), 70);
    CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccessControls0);
    Node node1 = Node.newNumber((-3392.08727231292));
    Node node2 = new Node(18, node1, node0, node0, 1936, 49);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit(nodeTraversal0, node2, node0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public boolean isSyntheticBlock() {
    return getBooleanProp(SYNTHETIC_BLOCK_PROP);
}","public void test07075() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((double) 100, 100, 100);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node1 = new Node(27, node0, node0, node0, 33, 43);
    foldConstants0.tryFoldShift(nodeTraversal0, node0, node0, node1, node0);
    assertFalse(node0.isSyntheticBlock());
}","/**
 * Returns whether this is a synthetic block that should not be considered
 * a real source block.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test07176() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((-2.147483648937212E9));
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryFoldShift(nodeTraversal0, node0, node0, node0, node0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test07177() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((-2.147483648937212E9));
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryFoldShift(nodeTraversal0, node0, node0, node0, node0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test07278() throws Throwable {
    Compiler compiler0 = new Compiler();
    MoveFunctionDeclarations moveFunctionDeclarations0 = new MoveFunctionDeclarations(compiler0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber(2.147483647738228E9, 1, 31);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, moveFunctionDeclarations0);
    foldConstants0.tryFoldShift(nodeTraversal0, (Node) null, node0, node0, node0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test07279() throws Throwable {
    Compiler compiler0 = new Compiler();
    MoveFunctionDeclarations moveFunctionDeclarations0 = new MoveFunctionDeclarations(compiler0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber(2.147483647738228E9, 1, 31);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, moveFunctionDeclarations0);
    foldConstants0.tryFoldShift(nodeTraversal0, (Node) null, node0, node0, node0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test07380() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) (-3568), (-3568), 70);
    CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccessControls0);
    Node node1 = Node.newNumber((double) 2, 34, 2022);
    Node node2 = new Node(18, node0, node1, node1, 1936, 49);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.visit(nodeTraversal0, node2, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test07481() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) 661, 661, 661);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryFoldShift(nodeTraversal0, node0, node0, node0, node0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test07482() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) 661, 661, 661);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryFoldShift(nodeTraversal0, node0, node0, node0, node0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test07583() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) (-3568), (-3568), 70);
    CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccessControls0);
    Node node1 = Node.newNumber((double) 2, 34, 2022);
    Node node2 = Node.newNumber((-3392.08727231292));
    Node node3 = new Node(18, node2, node1, node1, 1936, 49);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit(nodeTraversal0, node3, node0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test07584() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) (-3568), (-3568), 70);
    CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccessControls0);
    Node node1 = Node.newNumber((double) 2, 34, 2022);
    Node node2 = Node.newNumber((-3392.08727231292));
    Node node3 = new Node(18, node2, node1, node1, 1936, 49);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.visit(nodeTraversal0, node3, node0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"void tryFoldShift(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {
        double result;
        double lval = left.getDouble();
        double rval = right.getDouble();
        // check ranges.  We do not do anything that would clip the double to
        // a 32-bit range, since the user likely does not intend that.
        if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
            error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
            return;
        }
        // only the lower 5 bits are used when shifting, so don't do anything
        // if the shift amount is outside [0,32)
        if (!(rval >= 0 && rval < 32)) {
            error(t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
            return;
        }
        // Convert the numbers to ints
        int lvalInt = (int) lval;
        if (lvalInt != lval) {
            error(t, FRACTIONAL_BITWISE_OPERAND, left);
            return;
        }
        int rvalInt = (int) rval;
        if (rvalInt != rval) {
            error(t, FRACTIONAL_BITWISE_OPERAND, right);
            return;
        }
        switch(n.getType()) {
            case Token.LSH:
                result = lvalInt << rvalInt;
                break;
            case Token.RSH:
                result = lvalInt >> rvalInt;
                break;
            case Token.URSH:
                result = lvalInt >>> rvalInt;
                break;
            default:
                throw new AssertionError(""Unknown shift operator: "" + Node.tokenToName(n.getType()));
        }
        parent.replaceChild(n, Node.newNumber(result));
        t.getCompiler().reportCodeChange();
    }
}","public void test07685() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) 22, 19, (-4658));
    CompilerOptions compilerOptions0 = compiler0.options_;
    DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
    TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldShift(nodeTraversal0, node0, node0, node0, node0);
        fail(""Expecting exception: AssertionError"");
    } catch (AssertionError e) {
        //
        // Unknown shift operator: number
        //
    }
}","/**
 * Try to fold shift operations
 */"
"public boolean hasChildren() {
    return first != null;
}","public void test07786() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Sez'1M/_>]a"");
    Node node0 = Node.newString(122, ""Sez'1M/_>]a"");
    SyntheticAst syntheticAst0 = new SyntheticAst(""Sez'1M/_>]a"");
    Compiler compiler0 = new Compiler(mockPrintStream0);
    Node node1 = syntheticAst0.getAstRoot(compiler0);
    node0.addChildrenToBack(node1);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.tryFoldComparison((NodeTraversal) null, node1, node0, node0, node1);
    assertFalse(node1.hasChildren());
}",""
"public boolean isNoSideEffectsCall() {
    return getBooleanProp(NO_SIDE_EFFECTS_CALL);
}","public void test07887() throws Throwable {
    Node node0 = Node.newString(122, ""O3Sez'1M/_>]a"");
    Compiler compiler0 = new Compiler();
    node0.addChildrenToBack(node0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.tryFoldComparison((NodeTraversal) null, node0, node0, node0, node0);
    assertFalse(node0.isNoSideEffectsCall());
}","/**
 * Returns true if this node is a function or constructor call that
 * has no side effects.
 */"
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test07988() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[0];
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    Node node1 = new Node(38);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.tryFoldComparison(nodeTraversal0, node0, node1, node0, node0);
    assertEquals(35, Node.QUOTED_PROP);
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test08089() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(41);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    foldConstants0.tryFoldComparison(nodeTraversal0, node0, node0, node0, node0);
    assertEquals(22, Node.TARGETBLOCK_PROP);
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test08190() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node0 = Node.newString(42, ""t]NA4'fAl["");
    foldConstants0.tryFoldComparison(nodeTraversal0, node0, node0, node0, node0);
    assertEquals(29, Node.VAR_ARGS_NAME);
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"public boolean isUnscopedQualifiedName() {
    switch(getType()) {
        case Token.NAME:
            return true;
        case Token.GETPROP:
            return getFirstChild().isUnscopedQualifiedName();
        default:
            return false;
    }
}","public void test08291() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(63, 63, 0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node1 = new Node(43, node0, 5, 43);
    foldConstants0.tryFoldComparison((NodeTraversal) null, node0, node1, node1, node1);
    assertFalse(node1.isUnscopedQualifiedName());
}","/**
 * Returns whether a node corresponds to a simple or a qualified name
 * without a ""this"" reference, such as <code>a.b.c</code>, but not
 * <code>this.a</code>.
 */"
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test08392() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0, (ScopeCreator) null);
    Node node0 = Node.newNumber((double) 141, 141, 141);
    Node node1 = new Node(44, node0, node0, node0, 22, 24);
    foldConstants0.tryFoldComparison(nodeTraversal0, node1, node1, node1, node0);
    assertEquals(12, Node.REGEXP_PROP);
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test08493() throws Throwable {
    Node node0 = Node.newString(122, ""O3Sez'1M/_>]a"");
    Compiler compiler0 = new Compiler();
    node0.addChildrenToBack(node0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node1 = Node.newString(34, ""X*D*{:C3g@WJX6f306N"", 1, (-1840));
    foldConstants0.tryFoldComparison((NodeTraversal) null, node0, node0, node1, node0);
    assertEquals(16, Node.SOURCENAME_PROP);
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test08594() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Sez'1M/_>]a"");
    Node node0 = Node.newString(122, ""Sez'1M/_>]a"");
    Compiler compiler0 = new Compiler(mockPrintStream0);
    Node node1 = new Node(29, node0, node0, 22, 2);
    node0.addChildrenToBack(node1);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.tryFoldComparison((NodeTraversal) null, node1, node0, node1, node0);
    assertEquals(35, Node.QUOTED_PROP);
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test08695() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""0"");
    Node node1 = new Node(44);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryFoldComparison(nodeTraversal0, node1, node1, node0, node0);
    assertEquals(35, Node.QUOTED_PROP);
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test08796() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newString(""B1]6,N"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryFoldComparison(nodeTraversal0, node0, node0, node0, node0);
    assertEquals(29, Node.JSDOC_INFO_PROP);
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test08897() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nL3wO ok,;%KU?tj"");
    Node node1 = Node.newNumber((double) 13, 43, 4);
    Node node2 = new Node(13, node1, node1, node0, 958, 114);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryMinimizeCondition(nodeTraversal0, node0, node2);
    // Undeclared exception!
    try {
        foldConstants0.visit(nodeTraversal0, node2, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test08998() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""com.google.javascript.jscomp.CrossModuleMethodMotion$IdGenerator"");
    Node node1 = Node.newNumber((-3388.865365999262), 115, (-1780));
    Node node2 = new Node(15, node0, node1, node1, 1109, 44);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    CodingConventionAnnotator codingConventionAnnotator0 = new CodingConventionAnnotator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, codingConventionAnnotator0, (ScopeCreator) null);
    foldConstants0.tryMinimizeCondition(nodeTraversal0, node0, node2);
    // Undeclared exception!
    try {
        foldConstants0.visit(nodeTraversal0, node2, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test09099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) 661, 661, 661);
    Node node1 = new Node(16);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldComparison(nodeTraversal0, node1, node0, node0, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"public boolean isSyntheticBlock() {
    return getBooleanProp(SYNTHETIC_BLOCK_PROP);
}","public void test091100() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) 661, 661, 661);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryFoldComparison(nodeTraversal0, node0, node0, node0, node0);
    assertFalse(node0.isSyntheticBlock());
}","/**
 * Returns whether this is a synthetic block that should not be considered
 * a real source block.
 */"
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test092101() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) 661, 661, 661);
    Node node1 = new Node(13);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldComparison(nodeTraversal0, node1, node0, node0, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test093102() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""com.google.common.collect.ImmutableSet$ArrayImmutableSet"", ""com.google.common.collect.ImmutableSet$ArrayImmutableSet"");
    Node node1 = Node.newNumber((double) 25, 26, 29);
    Node node2 = new Node(15, node0, node1, node1, 38, 44);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    RemoveConstantExpressions.RemoveConstantRValuesCallback removeConstantExpressions_RemoveConstantRValuesCallback0 = new RemoveConstantExpressions.RemoveConstantRValuesCallback();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, removeConstantExpressions_RemoveConstantRValuesCallback0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldComparison(nodeTraversal0, node2, node1, node1, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // node is not a child
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"@SuppressWarnings(""fallthrough"")
void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    int op = n.getType();
    boolean result;
    // TODO(johnlenz): Use the JSType to compare nodes of different types.
    boolean rightLiteral = NodeUtil.isLiteralValue(right);
    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(""undefined"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
    switch(left.getType()) {
        case Token.VOID:
            if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
                return;
            } else if (!rightLiteral) {
                return;
            } else {
                boolean nullRight = (Token.NULL == right.getType());
                boolean equivalent = undefinedRight || nullRight;
                switch(op) {
                    case Token.EQ:
                        // undefined is only equal to
                        result = equivalent;
                        break;
                    case Token.NE:
                        result = !equivalent;
                        break;
                    case Token.SHEQ:
                        result = undefinedRight;
                        break;
                    case Token.SHNE:
                        result = !undefinedRight;
                        break;
                    case Token.LT:
                    case Token.GT:
                    case Token.LE:
                    case Token.GE:
                        result = false;
                        break;
                    default:
                        return;
                }
            }
            break;
        case Token.NULL:
            if (undefinedRight) {
                result = (op == Token.EQ);
                break;
            }
        // fall through
        case Token.TRUE:
        case Token.FALSE:
            if (undefinedRight) {
                result = false;
                break;
            }
        // fall through
        case Token.THIS:
            int tt = right.getType();
            if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL)
                return;
            switch(op) {
                case Token.EQ:
                    result = left.getType() == right.getType();
                    break;
                case Token.NE:
                    result = left.getType() != right.getType();
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.STRING:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.STRING != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            switch(op) {
                case Token.EQ:
                    result = left.getString().equals(right.getString());
                    break;
                case Token.NE:
                    result = !left.getString().equals(right.getString());
                    break;
                default:
                    // we only handle == and != here
                    return;
            }
            break;
        case Token.NUMBER:
            if (undefinedRight) {
                result = false;
                break;
            }
            if (Token.NUMBER != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            double lv = left.getDouble();
            double rv = right.getDouble();
            switch(op) {
                case Token.EQ:
                    result = lv == rv;
                    break;
                case Token.NE:
                    result = lv != rv;
                    break;
                case Token.LE:
                    result = lv <= rv;
                    break;
                case Token.LT:
                    result = lv < rv;
                    break;
                case Token.GE:
                    result = lv >= rv;
                    break;
                case Token.GT:
                    result = lv > rv;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        case Token.NAME:
            if (rightLiteral) {
                boolean undefinedLeft = (left.getString().equals(""undefined""));
                if (undefinedLeft) {
                    boolean nullRight = (Token.NULL == right.getType());
                    boolean equivalent = undefinedRight || nullRight;
                    switch(op) {
                        case Token.EQ:
                            // undefined is only equal to
                            result = equivalent;
                            break;
                        case Token.NE:
                            result = !equivalent;
                            break;
                        case Token.SHEQ:
                            result = undefinedRight;
                            break;
                        case Token.SHNE:
                            result = !undefinedRight;
                            break;
                        case Token.LT:
                        case Token.GT:
                        case Token.LE:
                        case Token.GE:
                            result = false;
                            break;
                        default:
                            return;
                    }
                    break;
                }
            }
            if (Token.NAME != right.getType()) {
                // Only eval if they are the same type
                return;
            }
            String ln = left.getString();
            String rn = right.getString();
            if (!ln.equals(rn)) {
                // Not the same value name.
                return;
            }
            switch(op) {
                // If we knew the named value wouldn't be NaN, it would be nice
                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
                case Token.LT:
                case Token.GT:
                    result = false;
                    break;
                default:
                    // don't handle that op
                    return;
            }
            break;
        default:
            // assert, this should cover all consts
            return;
    }
    parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE));
    t.getCompiler().reportCodeChange();
}","public void test094103() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[0];
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
    Node node1 = Node.newString(""Unknown class name"", 4, 11);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    Node node2 = new Node(38);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldComparison(nodeTraversal0, node0, node2, node1, node1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // NAME is not a string node
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold comparison nodes, e.g ==
 */"
"public boolean isNoSideEffectsCall() {
    return getBooleanProp(NO_SIDE_EFFECTS_CALL);
}","public void test095104() throws Throwable {
    Compiler compiler0 = new Compiler();
    MoveFunctionDeclarations moveFunctionDeclarations0 = new MoveFunctionDeclarations(compiler0);
    Node node0 = Node.newString(14, ""IsExtension"");
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node1 = new Node(33);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, moveFunctionDeclarations0);
    foldConstants0.tryFoldStringIndexOf(nodeTraversal0, node0, node1, node0, node1);
    assertFalse(node1.isNoSideEffectsCall());
}","/**
 * Returns true if this node is a function or constructor call that
 * has no side effects.
 */"
"void tryFoldStringIndexOf(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }
    Node lstringNode = left.getFirstChild();
    Node functionName = lstringNode.getNext();
    if ((lstringNode.getType() != Token.STRING) || (!functionName.getString().equals(""indexOf"") && !functionName.getString().equals(""lastIndexOf""))) {
        return;
    }
    String lstring = NodeUtil.getStringValue(lstringNode);
    boolean isIndexOf = functionName.getString().equals(""indexOf"");
    Node firstArg = right;
    Node secondArg = right.getNext();
    String searchValue = NodeUtil.getStringValue(firstArg);
    // searchValue must be a valid string.
    if (searchValue == null) {
        return;
    }
    int fromIndex = isIndexOf ? 0 : lstring.length();
    if (secondArg != null) {
        // Third-argument and non-numeric second arg are problematic. Discard.
        if ((secondArg.getNext() != null) || (secondArg.getType() != Token.NUMBER)) {
            return;
        } else {
            fromIndex = (int) secondArg.getDouble();
        }
    }
    int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex) : lstring.lastIndexOf(searchValue, fromIndex);
    Node newNode = Node.newNumber(indexVal);
    parent.replaceChild(n, newNode);
    t.getCompiler().reportCodeChange();
}","public void test096105() throws Throwable {
    Compiler compiler0 = new Compiler();
    MoveFunctionDeclarations moveFunctionDeclarations0 = new MoveFunctionDeclarations(compiler0);
    Node node0 = Node.newString(""IsExtension"", 14, 14);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node1 = new Node(33);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, moveFunctionDeclarations0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldStringIndexOf(nodeTraversal0, node0, node1, node0, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.FoldConstants"", e);
    }
}","/**
 * Try to evaluate String.indexOf/lastIndexOf:
 *     ""abcdef"".indexOf(""bc"") -> 1
 *     ""abcdefbc"".indexOf(""bc"", 3) -> 6
 */"
"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
        return;
    }
    Node arrayNode = left.getFirstChild();
    Node functionName = arrayNode.getNext();
    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(""join"")) {
        return;
    }
    String joinString = NodeUtil.getStringValue(right);
    List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
    int foldedSize = 0;
    Node elem = arrayNode.getFirstChild();
    // Merges adjacent String nodes.
    while (elem != null) {
        if (NodeUtil.isImmutableValue(elem)) {
            if (sb.length() > 0) {
                sb.append(joinString);
            }
            sb.append(NodeUtil.getStringValue(elem));
        } else {
            if (sb.length() > 0) {
                // + 2 for the quotes.
                foldedSize += sb.length() + 2;
                arrayFoldedChildren.add(Node.newString(sb.toString()));
                sb = new StringBuilder();
            }
            foldedSize += InlineCostEstimator.getCost(elem);
            arrayFoldedChildren.add(elem);
        }
        elem = elem.getNext();
    }
    if (sb.length() > 0) {
        // + 2 for the quotes.
        foldedSize += sb.length() + 2;
        arrayFoldedChildren.add(Node.newString(sb.toString()));
    }
    // one for each comma.
    foldedSize += arrayFoldedChildren.size() - 1;
    int originalSize = InlineCostEstimator.getCost(n);
    switch(arrayFoldedChildren.size()) {
        case 0:
            Node emptyStringNode = Node.newString("""");
            parent.replaceChild(n, emptyStringNode);
            break;
        case 1:
            Node foldedStringNode = arrayFoldedChildren.remove(0);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            if (foldedStringNode.getType() != Token.STRING) {
                // If the Node is not a string literal, ensure that
                // it is coerced to a string.
                Node replacement = new Node(Token.ADD, Node.newString(""""), foldedStringNode);
                foldedStringNode = replacement;
            }
            parent.replaceChild(n, foldedStringNode);
            break;
        default:
            // No folding could actually be performed.
            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
                return;
            }
            int kJoinOverhead = ""[].join()"".length();
            foldedSize += kJoinOverhead;
            foldedSize += InlineCostEstimator.getCost(right);
            if (foldedSize > originalSize) {
                return;
            }
            arrayNode.detachChildren();
            for (Node node : arrayFoldedChildren) {
                arrayNode.addChildToBack(node);
            }
            break;
    }
    t.getCompiler().reportCodeChange();
}","public void test097106() throws Throwable {
    Compiler compiler0 = new Compiler();
    MoveFunctionDeclarations moveFunctionDeclarations0 = new MoveFunctionDeclarations(compiler0);
    Node node0 = Node.newString(14, ""IsExtension"");
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node1 = new Node(33);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, moveFunctionDeclarations0);
    foldConstants0.tryFoldStringJoin(nodeTraversal0, node1, node1, node0, node1);
    assertEquals(8, Node.CODEOFFSET_PROP);
}","/**
 * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';
 */"
"void tryFoldGetElem(NodeTraversal t, Node n, Node left, Node right, Node parent) {
    if (left.getType() == Token.ARRAYLIT) {
        if (right.getType() != Token.NUMBER) {
            // Sometimes people like to use complex expressions to index into
            // arrays, or strings to index into array methods.
            return;
        }
        double index = right.getDouble();
        int intIndex = (int) index;
        if (intIndex != index) {
            t.getCompiler().report(JSError.make(t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf(index)));
            return;
        }
        if (intIndex < 0) {
            t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex)));
            return;
        }
        Node elem = left.getFirstChild();
        for (int i = 0; elem != null && i < intIndex; i++) {
            elem = elem.getNext();
        }
        if (elem == null) {
            t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex)));
            return;
        }
        // Replace the entire GETELEM with the value
        left.removeChild(elem);
        parent.replaceChild(n, elem);
        t.getCompiler().reportCodeChange();
    }
}","public void test098107() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(63, 63, 0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.tryFoldGetElem((NodeTraversal) null, node0, node0, node0, node0);
    assertEquals(2, Node.ATTRIBUTE_FLAG);
}","/**
 * Try to fold array-element. e.g [1, 2, 3][10];
 */"
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test099108() throws Throwable {
    Compiler compiler0 = new Compiler();
    DeadAssignmentsElimination deadAssignmentsElimination0 = new DeadAssignmentsElimination(compiler0);
    Node node0 = Node.newString("""", (-2726), 22);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, deadAssignmentsElimination0);
    Node node1 = compiler0.parseSyntheticCode(""cKQ:d';dH@*"", """");
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.tryFoldGetProp(nodeTraversal0, node1, node0, node1, node1);
    assertEquals((-1), node0.getCharno());
}",""
"void tryFoldRegularExpressionConstructor(NodeTraversal t, Node n, Node parent) {
    Node constructor = n.getFirstChild();
    // e.g.  ^foobar$
    Node pattern = constructor.getNext();
    // e.g. gi
    Node flags = null != pattern ? pattern.getNext() : null;
    if (null == pattern || (null != flags && null != flags.getNext())) {
        // too few or too many arguments
        return;
    }
    if (// is pattern folded
    pattern.getType() == Token.STRING && // make sure empty pattern doesn't fold to //
    !"""".equals(pattern.getString()) && // NOTE(nicksantos): Make sure that the regexp isn't longer than
    // 100 chars, or it blows up the regexp parser in Opera 9.2.
    pattern.getString().length() < 100 && (null == flags || flags.getType() == Token.STRING) && // don't escape patterns with unicode escapes since Safari behaves badly
    // (read can't parse or crashes) on regex literals with unicode escapes
    !containsUnicodeEscape(pattern.getString())) {
        // Make sure that / is escaped, so that it will fit safely in /brackets/.
        // pattern is a string value with \\ and similar already escaped
        pattern = makeForwardSlashBracketSafe(pattern);
        Node regexLiteral;
        if (null == flags || """".equals(flags.getString())) {
            // fold to /foobar/
            regexLiteral = new Node(Token.REGEXP, pattern);
        } else {
            // fold to /foobar/gi
            if (!areValidRegexpFlags(flags.getString())) {
                error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags);
                return;
            }
            if (!areSafeFlagsToFold(flags.getString())) {
                return;
            }
            n.removeChild(flags);
            regexLiteral = new Node(Token.REGEXP, pattern, flags);
        }
        parent.replaceChild(n, regexLiteral);
        t.getCompiler().reportCodeChange();
    }
}","public void test100109() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseTestCode(""PK"");
    foldConstants0.tryFoldRegularExpressionConstructor((NodeTraversal) null, node0, node0);
    assertEquals(19, Node.LABEL_PROP);
}","/**
 * Try to fold a RegExp constructor to a regular expression literal.
 */"
"void tryFoldRegularExpressionConstructor(NodeTraversal t, Node n, Node parent) {
    Node constructor = n.getFirstChild();
    // e.g.  ^foobar$
    Node pattern = constructor.getNext();
    // e.g. gi
    Node flags = null != pattern ? pattern.getNext() : null;
    if (null == pattern || (null != flags && null != flags.getNext())) {
        // too few or too many arguments
        return;
    }
    if (// is pattern folded
    pattern.getType() == Token.STRING && // make sure empty pattern doesn't fold to //
    !"""".equals(pattern.getString()) && // NOTE(nicksantos): Make sure that the regexp isn't longer than
    // 100 chars, or it blows up the regexp parser in Opera 9.2.
    pattern.getString().length() < 100 && (null == flags || flags.getType() == Token.STRING) && // don't escape patterns with unicode escapes since Safari behaves badly
    // (read can't parse or crashes) on regex literals with unicode escapes
    !containsUnicodeEscape(pattern.getString())) {
        // Make sure that / is escaped, so that it will fit safely in /brackets/.
        // pattern is a string value with \\ and similar already escaped
        pattern = makeForwardSlashBracketSafe(pattern);
        Node regexLiteral;
        if (null == flags || """".equals(flags.getString())) {
            // fold to /foobar/
            regexLiteral = new Node(Token.REGEXP, pattern);
        } else {
            // fold to /foobar/gi
            if (!areValidRegexpFlags(flags.getString())) {
                error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags);
                return;
            }
            if (!areSafeFlagsToFold(flags.getString())) {
                return;
            }
            n.removeChild(flags);
            regexLiteral = new Node(Token.REGEXP, pattern, flags);
        }
        parent.replaceChild(n, regexLiteral);
        t.getCompiler().reportCodeChange();
    }
}","public void test101110() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nL3wO ok,;%KU?tj"");
    Node node1 = Node.newNumber((double) 33, 78, 27);
    Node node2 = new Node(113, node1, node1, node0, 31, 43);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldRegularExpressionConstructor(nodeTraversal0, node2, node2);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // node is not a child
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold a RegExp constructor to a regular expression literal.
 */"
"void tryFoldRegularExpressionConstructor(NodeTraversal t, Node n, Node parent) {
    Node constructor = n.getFirstChild();
    // e.g.  ^foobar$
    Node pattern = constructor.getNext();
    // e.g. gi
    Node flags = null != pattern ? pattern.getNext() : null;
    if (null == pattern || (null != flags && null != flags.getNext())) {
        // too few or too many arguments
        return;
    }
    if (// is pattern folded
    pattern.getType() == Token.STRING && // make sure empty pattern doesn't fold to //
    !"""".equals(pattern.getString()) && // NOTE(nicksantos): Make sure that the regexp isn't longer than
    // 100 chars, or it blows up the regexp parser in Opera 9.2.
    pattern.getString().length() < 100 && (null == flags || flags.getType() == Token.STRING) && // don't escape patterns with unicode escapes since Safari behaves badly
    // (read can't parse or crashes) on regex literals with unicode escapes
    !containsUnicodeEscape(pattern.getString())) {
        // Make sure that / is escaped, so that it will fit safely in /brackets/.
        // pattern is a string value with \\ and similar already escaped
        pattern = makeForwardSlashBracketSafe(pattern);
        Node regexLiteral;
        if (null == flags || """".equals(flags.getString())) {
            // fold to /foobar/
            regexLiteral = new Node(Token.REGEXP, pattern);
        } else {
            // fold to /foobar/gi
            if (!areValidRegexpFlags(flags.getString())) {
                error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags);
                return;
            }
            if (!areSafeFlagsToFold(flags.getString())) {
                return;
            }
            n.removeChild(flags);
            regexLiteral = new Node(Token.REGEXP, pattern, flags);
        }
        parent.replaceChild(n, regexLiteral);
        t.getCompiler().reportCodeChange();
    }
}","public void test102111() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newNumber((double) 704, 650, 650);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    Node node1 = compiler0.parseSyntheticCode(""$0"", ""$0"");
    Node node2 = Node.newString(""$0"");
    Node node3 = new Node(2, node0, node2, node1, 0, 20);
    foldConstants0.tryFoldRegularExpressionConstructor(nodeTraversal0, node3, node2);
    assertEquals((-2), Node.OBJECT_IDS_PROP);
}","/**
 * Try to fold a RegExp constructor to a regular expression literal.
 */"
"void tryFoldRegularExpressionConstructor(NodeTraversal t, Node n, Node parent) {
    Node constructor = n.getFirstChild();
    // e.g.  ^foobar$
    Node pattern = constructor.getNext();
    // e.g. gi
    Node flags = null != pattern ? pattern.getNext() : null;
    if (null == pattern || (null != flags && null != flags.getNext())) {
        // too few or too many arguments
        return;
    }
    if (// is pattern folded
    pattern.getType() == Token.STRING && // make sure empty pattern doesn't fold to //
    !"""".equals(pattern.getString()) && // NOTE(nicksantos): Make sure that the regexp isn't longer than
    // 100 chars, or it blows up the regexp parser in Opera 9.2.
    pattern.getString().length() < 100 && (null == flags || flags.getType() == Token.STRING) && // don't escape patterns with unicode escapes since Safari behaves badly
    // (read can't parse or crashes) on regex literals with unicode escapes
    !containsUnicodeEscape(pattern.getString())) {
        // Make sure that / is escaped, so that it will fit safely in /brackets/.
        // pattern is a string value with \\ and similar already escaped
        pattern = makeForwardSlashBracketSafe(pattern);
        Node regexLiteral;
        if (null == flags || """".equals(flags.getString())) {
            // fold to /foobar/
            regexLiteral = new Node(Token.REGEXP, pattern);
        } else {
            // fold to /foobar/gi
            if (!areValidRegexpFlags(flags.getString())) {
                error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags);
                return;
            }
            if (!areSafeFlagsToFold(flags.getString())) {
                return;
            }
            n.removeChild(flags);
            regexLiteral = new Node(Token.REGEXP, pattern, flags);
        }
        parent.replaceChild(n, regexLiteral);
        t.getCompiler().reportCodeChange();
    }
}","public void test103112() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0, (ScopeCreator) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType[] jSTypeArray0 = new JSType[4];
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    jSTypeArray0[3] = (JSType) objectType0;
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
    foldConstants0.tryFoldRegularExpressionConstructor(nodeTraversal0, node0, node0);
    assertEquals(49, Node.LAST_PROP);
}","/**
 * Try to fold a RegExp constructor to a regular expression literal.
 */"
"void tryFoldRegularExpressionConstructor(NodeTraversal t, Node n, Node parent) {
    Node constructor = n.getFirstChild();
    // e.g.  ^foobar$
    Node pattern = constructor.getNext();
    // e.g. gi
    Node flags = null != pattern ? pattern.getNext() : null;
    if (null == pattern || (null != flags && null != flags.getNext())) {
        // too few or too many arguments
        return;
    }
    if (// is pattern folded
    pattern.getType() == Token.STRING && // make sure empty pattern doesn't fold to //
    !"""".equals(pattern.getString()) && // NOTE(nicksantos): Make sure that the regexp isn't longer than
    // 100 chars, or it blows up the regexp parser in Opera 9.2.
    pattern.getString().length() < 100 && (null == flags || flags.getType() == Token.STRING) && // don't escape patterns with unicode escapes since Safari behaves badly
    // (read can't parse or crashes) on regex literals with unicode escapes
    !containsUnicodeEscape(pattern.getString())) {
        // Make sure that / is escaped, so that it will fit safely in /brackets/.
        // pattern is a string value with \\ and similar already escaped
        pattern = makeForwardSlashBracketSafe(pattern);
        Node regexLiteral;
        if (null == flags || """".equals(flags.getString())) {
            // fold to /foobar/
            regexLiteral = new Node(Token.REGEXP, pattern);
        } else {
            // fold to /foobar/gi
            if (!areValidRegexpFlags(flags.getString())) {
                error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags);
                return;
            }
            if (!areSafeFlagsToFold(flags.getString())) {
                return;
            }
            n.removeChild(flags);
            regexLiteral = new Node(Token.REGEXP, pattern, flags);
        }
        parent.replaceChild(n, regexLiteral);
        t.getCompiler().reportCodeChange();
    }
}","public void test104113() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = Node.newString(""nXvAuOQrc\""CY\""1#(nX*"");
    Node node1 = new Node(34, 11, 29);
    Node node2 = new Node(88, node0, node1, node1, 8, 0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryFoldRegularExpressionConstructor(nodeTraversal0, node2, node1);
    assertEquals(4, Node.DESCENDANTS_FLAG);
}","/**
 * Try to fold a RegExp constructor to a regular expression literal.
 */"
"void tryFoldRegularExpressionConstructor(NodeTraversal t, Node n, Node parent) {
    Node constructor = n.getFirstChild();
    // e.g.  ^foobar$
    Node pattern = constructor.getNext();
    // e.g. gi
    Node flags = null != pattern ? pattern.getNext() : null;
    if (null == pattern || (null != flags && null != flags.getNext())) {
        // too few or too many arguments
        return;
    }
    if (// is pattern folded
    pattern.getType() == Token.STRING && // make sure empty pattern doesn't fold to //
    !"""".equals(pattern.getString()) && // NOTE(nicksantos): Make sure that the regexp isn't longer than
    // 100 chars, or it blows up the regexp parser in Opera 9.2.
    pattern.getString().length() < 100 && (null == flags || flags.getType() == Token.STRING) && // don't escape patterns with unicode escapes since Safari behaves badly
    // (read can't parse or crashes) on regex literals with unicode escapes
    !containsUnicodeEscape(pattern.getString())) {
        // Make sure that / is escaped, so that it will fit safely in /brackets/.
        // pattern is a string value with \\ and similar already escaped
        pattern = makeForwardSlashBracketSafe(pattern);
        Node regexLiteral;
        if (null == flags || """".equals(flags.getString())) {
            // fold to /foobar/
            regexLiteral = new Node(Token.REGEXP, pattern);
        } else {
            // fold to /foobar/gi
            if (!areValidRegexpFlags(flags.getString())) {
                error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags);
                return;
            }
            if (!areSafeFlagsToFold(flags.getString())) {
                return;
            }
            n.removeChild(flags);
            regexLiteral = new Node(Token.REGEXP, pattern, flags);
        }
        parent.replaceChild(n, regexLiteral);
        t.getCompiler().reportCodeChange();
    }
}","public void test105114() throws Throwable {
    Compiler compiler0 = new Compiler();
    DeadAssignmentsElimination deadAssignmentsElimination0 = new DeadAssignmentsElimination(compiler0);
    Node node0 = Node.newString("""", (-2726), 22);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, deadAssignmentsElimination0);
    Node node1 = compiler0.parseSyntheticCode(""cKQ:d';dH@*"", """");
    Node node2 = new Node(1431655764, node1, node0, node0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    foldConstants0.tryFoldRegularExpressionConstructor(nodeTraversal0, node2, node2);
    assertEquals(30, Node.SKIP_INDEXES_PROP);
}","/**
 * Try to fold a RegExp constructor to a regular expression literal.
 */"
"void tryFoldRegularExpressionConstructor(NodeTraversal t, Node n, Node parent) {
    Node constructor = n.getFirstChild();
    // e.g.  ^foobar$
    Node pattern = constructor.getNext();
    // e.g. gi
    Node flags = null != pattern ? pattern.getNext() : null;
    if (null == pattern || (null != flags && null != flags.getNext())) {
        // too few or too many arguments
        return;
    }
    if (// is pattern folded
    pattern.getType() == Token.STRING && // make sure empty pattern doesn't fold to //
    !"""".equals(pattern.getString()) && // NOTE(nicksantos): Make sure that the regexp isn't longer than
    // 100 chars, or it blows up the regexp parser in Opera 9.2.
    pattern.getString().length() < 100 && (null == flags || flags.getType() == Token.STRING) && // don't escape patterns with unicode escapes since Safari behaves badly
    // (read can't parse or crashes) on regex literals with unicode escapes
    !containsUnicodeEscape(pattern.getString())) {
        // Make sure that / is escaped, so that it will fit safely in /brackets/.
        // pattern is a string value with \\ and similar already escaped
        pattern = makeForwardSlashBracketSafe(pattern);
        Node regexLiteral;
        if (null == flags || """".equals(flags.getString())) {
            // fold to /foobar/
            regexLiteral = new Node(Token.REGEXP, pattern);
        } else {
            // fold to /foobar/gi
            if (!areValidRegexpFlags(flags.getString())) {
                error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags);
                return;
            }
            if (!areSafeFlagsToFold(flags.getString())) {
                return;
            }
            n.removeChild(flags);
            regexLiteral = new Node(Token.REGEXP, pattern, flags);
        }
        parent.replaceChild(n, regexLiteral);
        t.getCompiler().reportCodeChange();
    }
}","public void test106115() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Sez'1M/_>]a"");
    Node node0 = Node.newString(""Sez'1M/_>]a"", 122, 122);
    Compiler compiler0 = new Compiler(mockPrintStream0);
    String string0 = ""v\\u%*[Ze$Si\\"";
    Node node1 = Node.newString(29, string0, 9, 29);
    Node node2 = new Node(30, node1, node1, node0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldRegularExpressionConstructor((NodeTraversal) null, node2, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Try to fold a RegExp constructor to a regular expression literal.
 */"
"static boolean containsUnicodeEscape(String s) {
    String esc = CodeGenerator.regexpEscape(s);
    for (int i = -1; (i = esc.indexOf(""\\u"", i + 1)) >= 0; ) {
        int nSlashes = 0;
        while (i - nSlashes > 0 && '\\' == esc.charAt(i - nSlashes - 1)) {
            ++nSlashes;
        }
        // if there are an even number of slashes before the \ u then it is a
        // unicode literal.
        if (0 == (nSlashes & 1)) {
            return true;
        }
    }
    return false;
}","public void test107116() throws Throwable {
    String string0 = ""\\u"";
    boolean boolean0 = FoldConstants.containsUnicodeEscape(string0);
    assertTrue(boolean0);
}","/**
 * true if the javascript string would contain a unicode escape when written
 * out as the body of a regular expression literal.
 */"
"void tryFoldWhile(NodeTraversal t, Node n, Node parent) {
    Preconditions.checkArgument(n.getType() == Token.WHILE);
    Node cond = NodeUtil.getConditionExpression(n);
    if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {
        return;
    }
    NodeUtil.redeclareVarsInsideBranch(n);
    NodeUtil.removeChild(parent, n);
    t.getCompiler().reportCodeChange();
}","public void test108117() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""nX%?OQrc\""CY\""1!(nX*"", ""nX%?OQrc\""CY\""1!(nX*"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldWhile(nodeTraversal0, node0, node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Removes WHILEs that always evaluate to false.
 */"
"public void visit(NodeTraversal t, Node n, Node parent) {
    int type = n.getType();
    if (type == Token.BLOCK) {
        tryFoldBlock(t, n, parent);
        return;
    }
    Node left = n.getFirstChild();
    if (left == null) {
        return;
    }
    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
        String newValue = null;
        switch(left.getType()) {
            case Token.STRING:
                newValue = ""string"";
                break;
            case Token.NUMBER:
                newValue = ""number"";
                break;
            case Token.TRUE:
            case Token.FALSE:
                newValue = ""boolean"";
                break;
            case Token.NULL:
            case Token.OBJECTLIT:
            case Token.ARRAYLIT:
                newValue = ""object"";
                break;
            case Token.NAME:
                // We assume here that programs don't change the value of the
                // keyword undefined to something other than the value undefined.
                if (""undefined"".equals(left.getString())) {
                    newValue = ""undefined"";
                }
                break;
        }
        if (newValue != null) {
            parent.replaceChild(n, Node.newString(newValue));
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
        Preconditions.checkState(n.hasOneChild());
        if (NodeUtil.isExpressionNode(parent)) {
            // If the value of the NOT isn't used, then just throw
            // away the operator
            parent.replaceChild(n, n.removeFirstChild());
            t.getCompiler().reportCodeChange();
            return;
        }
        // Try to mimize NOT nodes such as !(x==y) into x!=y.
        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
            return;
        }
        if (!NodeUtil.isLiteralValue(left)) {
            return;
        }
        switch(type) {
            case Token.NOT:
                int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
                parent.replaceChild(n, new Node(result));
                t.getCompiler().reportCodeChange();
                break;
            case Token.NEG:
                try {
                    if (left.getType() == Token.NAME) {
                        if (left.getString().equals(""Infinity"")) {
                            // ""-Infinity"" is valid and a literal, don't modify it.
                            return;
                        } else if (left.getString().equals(""NaN"")) {
                            // ""-NaN"" is ""NaN"".
                            n.removeChild(left);
                            parent.replaceChild(n, left);
                            t.getCompiler().reportCodeChange();
                            return;
                        }
                    }
                    double negNum = -left.getDouble();
                    parent.replaceChild(n, Node.newNumber(negNum));
                    t.getCompiler().reportCodeChange();
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
            case Token.BITNOT:
                try {
                    double val = left.getDouble();
                    if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                        int intVal = (int) val;
                        if (intVal == val) {
                            parent.replaceChild(n, Node.newNumber(~intVal));
                            t.getCompiler().reportCodeChange();
                        } else {
                            error(t, FRACTIONAL_BITWISE_OPERAND, left);
                        }
                    } else {
                        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
                    }
                } catch (UnsupportedOperationException ex) {
                    // left is not a number node, so do not replace, but warn the
                    // user because they can't be doing anything good
                    error(t, NEGATING_A_NON_NUMBER_ERROR, left);
                }
                break;
        }
        return;
    } else if (type == Token.NEW) {
        if (Token.NAME == left.getType()) {
            String className = left.getString();
            if (""RegExp"".equals(className)) {
                tryFoldRegularExpressionConstructor(t, n, parent);
            } else if (left.getNext() == null) {
                if (""Array"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.ARRAYLIT);
                } else if (""Object"".equals(className)) {
                    tryFoldLiteralConstructor(t, n, parent, className, Token.OBJECTLIT);
                }
            }
        }
    }
    if (type == Token.EXPR_RESULT) {
        tryMinimizeCondition(t, left, n);
        return;
    }
    if (type == Token.RETURN) {
        tryReduceReturn(t, n);
        return;
    }
    Node right = left.getNext();
    if (right == null) {
        return;
    }
    // TODO(johnlenz) Use type information if available to fold
    // instanceof.
    if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
        if (NodeUtil.isImmutableValue(left)) {
            // Non-object types are never instances.
            parent.replaceChild(n, new Node(Token.FALSE));
            t.getCompiler().reportCodeChange();
            return;
        }
        if (right.getType() == Token.NAME && ""Object"".equals(right.getString())) {
            parent.replaceChild(n, new Node(Token.TRUE));
            t.getCompiler().reportCodeChange();
            return;
        }
    }
    if (type == Token.IF || type == Token.HOOK) {
        tryMinimizeCondition(t, n.getFirstChild(), n);
        boolean changes = tryFoldHookIf(t, n, parent);
        // bad cascades can occur if we run the second round
        // of IF optimizations immediately
        if (type == Token.IF && !changes) {
            tryMinimizeIf(t, n, parent);
        }
        return;
    }
    if (type == Token.DO) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldDo(t, n, parent);
        return;
    }
    if (type == Token.WHILE) {
        tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
        tryFoldWhile(t, n, parent);
        return;
    }
    if (type == Token.FOR) {
        Node condition = NodeUtil.getConditionExpression(n);
        if (condition != null) {
            tryMinimizeCondition(t, condition, n);
            // The root condition node might have changed, get it again.
            condition = NodeUtil.getConditionExpression(n);
            this.tryFoldForCondition(condition, n);
        }
        tryFoldFor(t, n, parent);
        return;
    }
    if (type == Token.AND || type == Token.OR) {
        tryFoldAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.BITOR || type == Token.BITAND) {
        tryFoldBitAndOr(t, n, left, right, parent);
        return;
    }
    if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
        tryFoldShift(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETPROP) {
        tryFoldGetProp(t, n, left, right, parent);
        return;
    }
    if (type == Token.CALL) {
        tryFoldStringJoin(t, n, left, right, parent);
        tryFoldStringIndexOf(t, n, left, right, parent);
        return;
    }
    if (type == Token.ASSIGN) {
        tryFoldAssign(t, n, left, right);
    }
    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
        if (type == Token.ADD)
            tryFoldLeftChildAdd(t, n, left, right, parent);
        if (type == Token.LT || type == Token.GT) {
            tryFoldComparison(t, n, left, right, parent);
        }
        // The subsequent ops only work if the LHS & RHS are consts
        return;
    }
    if (type == Token.ADD) {
        tryFoldAdd(t, n, left, right, parent);
        return;
    }
    if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
        tryFoldArithmetic(t, n, left, right, parent);
        return;
    }
    if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
        tryFoldComparison(t, n, left, right, parent);
        return;
    }
    if (type == Token.GETELEM) {
        tryFoldGetElem(t, n, left, right, parent);
        return;
    }
    // other types aren't handled
}","public void test109118() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""4L1nLuwO ok,;%KU?tj"");
    Node node1 = compiler0.parseSyntheticCode(""4L1nL3wO ok,;%KU?tj"", ""4L1nLuwO ok,;%KU?tj"");
    Node node2 = new Node(113, node1, node1, node0, 31, 43);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.visit(nodeTraversal0, node2, node2);
    assertEquals(8, Node.CODEOFFSET_PROP);
}",""
"void tryFoldFor(NodeTraversal t, Node n, Node parent) {
    Preconditions.checkArgument(n.getType() == Token.FOR);
    // This is not a FOR-IN loop
    if (n.getChildCount() != 4)
        return;
    // There isn't an initializer
    if (n.getFirstChild().getType() != Token.EMPTY)
        return;
    Node cond = NodeUtil.getConditionExpression(n);
    if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {
        return;
    }
    NodeUtil.redeclareVarsInsideBranch(n);
    NodeUtil.removeChild(parent, n);
    t.getCompiler().reportCodeChange();
}","public void test110119() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""OBJECT_NUMBER_STRING_BOOLEAN"", ""OBJECT_NUMBER_STRING_BOOLEAN"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldFor(nodeTraversal0, node0, node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Removes FORs that always evaluate to false.
 */"
"void tryFoldDo(NodeTraversal t, Node n, Node parent) {
    Preconditions.checkArgument(n.getType() == Token.DO);
    Node cond = NodeUtil.getConditionExpression(n);
    if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {
        return;
    }
    // TODO(johnlenz): The do-while can be turned into a label with
    // named breaks and the label optimized away (maybe).
    if (hasBreakOrContinue(n)) {
        return;
    }
    Preconditions.checkState(NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild()));
    Node block = n.removeFirstChild();
    parent.replaceChild(n, block);
    t.getCompiler().reportCodeChange();
}","public void test111120() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(63, 63, 63);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldDo((NodeTraversal) null, node0, (Node) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Removes DOs that always evaluate to false. This leaves the
 * statements that were in the loop in a BLOCK node.
 * The block will be removed in a later pass, if possible.
 */"
"void tryFoldDo(NodeTraversal t, Node n, Node parent) {
    Preconditions.checkArgument(n.getType() == Token.DO);
    Node cond = NodeUtil.getConditionExpression(n);
    if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {
        return;
    }
    // TODO(johnlenz): The do-while can be turned into a label with
    // named breaks and the label optimized away (maybe).
    if (hasBreakOrContinue(n)) {
        return;
    }
    Preconditions.checkState(NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild()));
    Node block = n.removeFirstChild();
    parent.replaceChild(n, block);
    t.getCompiler().reportCodeChange();
}","public void test112121() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[0];
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    MethodCheck methodCheck0 = new MethodCheck((AbstractCompiler) null, checkLevel0);
    NodeTraversal.Callback nodeTraversal_Callback0 = methodCheck0.getActingCallback();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, nodeTraversal_Callback0);
    Node node1 = new Node(114);
    FoldConstants foldConstants0 = new FoldConstants((AbstractCompiler) null);
    // Undeclared exception!
    try {
        foldConstants0.tryFoldDo(nodeTraversal0, node1, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}","/**
 * Removes DOs that always evaluate to false. This leaves the
 * statements that were in the loop in a BLOCK node.
 * The block will be removed in a later pass, if possible.
 */"
"void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.NOT:
            Node first = n.getFirstChild();
            switch(first.getType()) {
                case Token.NOT:
                    {
                        Node newRoot = first.removeFirstChild();
                        parent.replaceChild(n, newRoot);
                        // continue from here.
                        n = newRoot;
                        t.getCompiler().reportCodeChange();
                        // The child has moved up, to minimize it recurse.
                        tryMinimizeCondition(t, n, parent);
                        return;
                    }
                case Token.AND:
                case Token.OR:
                    {
                        Node leftParent = first.getFirstChild();
                        Node rightParent = first.getLastChild();
                        if (leftParent.getType() != Token.NOT || rightParent.getType() != Token.NOT) {
                            // No NOTs to elminate.
                            break;
                        }
                        Node left = leftParent.removeFirstChild();
                        Node right = rightParent.removeFirstChild();
                        int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;
                        Node newRoot = new Node(newOp, left, right);
                        parent.replaceChild(n, newRoot);
                        // continue from here.
                        n = newRoot;
                        t.getCompiler().reportCodeChange();
                        // Unlike the NOT case above, we know that AND and OR are
                        // valid root to check minimize so just break out and check
                        // the children.
                    }
                    break;
            }
            break;
        case Token.OR:
        case Token.AND:
            // check the children.
            break;
        default:
            // if(true) --> if(1)
            if (NodeUtil.isLiteralValue(n)) {
                boolean result = NodeUtil.getBooleanValue(n);
                int equivalentResult = result ? 1 : 0;
                maybeReplaceChildWithNumber(t, n, parent, equivalentResult);
            }
            // We can't do anything else currently.
            return;
    }
    for (Node c = n.getFirstChild(); c != null; ) {
        // c may be removed.
        Node next = c.getNext();
        tryMinimizeCondition(t, c, n);
        c = next;
    }
}","public void test113122() throws Throwable {
    Compiler compiler0 = new Compiler();
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""OBJECT_NUMBER_STRING_BOOLEAN"", ""OBJECT_NUMBER_STRING_BOOLEAN"");
    Node node1 = new Node(100, node0, node0, node0, 9, 29);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, foldConstants0);
    foldConstants0.tryMinimizeCondition(nodeTraversal0, node1, node1);
    assertEquals(1, Node.DECR_FLAG);
}","/**
 * Try to minimize conditions expressions, as there are additional
 * assumptions that can be made when it is known that the final result
 * is a boolean.
 *
 * The following transformations are done recursively:
 *   !(x||y) --> !x&&!y
 *   !(x&&y) --> !x||!y
 *   !!x     --> x
 * Thus:
 *   !(x&&!y) --> !x||!!y --> !x||y
 */"
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test114123() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString("""");
    Node node1 = new Node(101, node0, node0, node0, 49, 42);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
    TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    foldConstants0.tryMinimizeCondition(nodeTraversal0, node1, node0);
    assertEquals(42, node1.getCharno());
}",""
"public int getLineno() {
    return extractLineno(sourcePosition);
}","public void test114124() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString("""");
    Node node1 = new Node(101, node0, node0, node0, 49, 42);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
    TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    foldConstants0.tryMinimizeCondition(nodeTraversal0, node1, node0);
    assertEquals(49, node1.getLineno());
}",""
"void tryMinimizeIf(NodeTraversal t, Node n, Node parent) {
    Node cond = n.getFirstChild();
    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();
    if (elseBranch == null) {
        if (isExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (isPropertyAssignmentInExpression(t, expr)) {
                // Keep opportunities for CollapseProperties such as
                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;
                return;
            }
            if (cond.getType() == Token.NOT) {
                // if(!x)bar(); -> x||bar();
                if (isLowerPrecedenceInExpression(t, cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(t, expr.getFirstChild(), OR_PRECEDENCE)) {
                    // It's not okay to add two sets of parentheses.
                    return;
                }
                Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild());
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                t.getCompiler().reportCodeChange();
                return;
            }
            // if(x)foo(); -> x&&foo();
            if (isLowerPrecedenceInExpression(t, cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(t, expr.getFirstChild(), AND_PRECEDENCE)) {
                // One additional set of parentheses isn't worth it.
                return;
            }
            n.removeChild(cond);
            Node and = new Node(Token.AND, cond, expr.removeFirstChild());
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    tryRemoveRepeatedStatements(t, n);
    // if(!x)foo();else bar(); -> if(x)bar();else foo();
    // An additional set of curly braces isn't worth it.
    if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        t.getCompiler().reportCodeChange();
        return;
    }
    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);
        thenExpr.detachFromParent();
        elseExpr.detachFromParent();
        // note - we ignore any cases with ""return;"", technically this
        // can be converted to ""return undefined;"" or some variant, but
        // that does not help code size.
        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
        Node returnNode = new Node(Token.RETURN, hookNode);
        parent.replaceChild(n, returnNode);
        t.getCompiler().reportCodeChange();
        return;
    }
    boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch);
    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType()) {
            // if(x)a=1;else a=2; -> a=x?1:2;
            if (NodeUtil.isAssignmentOp(thenOp)) {
                Node lhs = thenOp.getFirstChild();
                if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization
                // evaluates LHS before cond]
                // NOTE - there are some circumstances where we can
                // proceed even if there are side effects...
                !NodeUtil.mayEffectMutableState(lhs)) {
                    n.removeChild(cond);
                    Node assignName = thenOp.removeFirstChild();
                    Node thenExpr = thenOp.removeFirstChild();
                    Node elseExpr = elseOp.getLastChild();
                    elseOp.removeChild(elseExpr);
                    Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
                    Node assign = new Node(thenOp.getType(), assignName, hookNode);
                    Node expr = NodeUtil.newExpr(assign);
                    parent.replaceChild(n, expr);
                    t.getCompiler().reportCodeChange();
                }
            } else if (NodeUtil.isCall(thenOp)) {
                // if(x)foo();else bar(); -> x?foo():bar()
                n.removeChild(cond);
                thenOp.detachFromParent();
                elseOp.detachFromParent();
                Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp);
                Node expr = NodeUtil.newExpr(hookNode);
                parent.replaceChild(n, expr);
                t.getCompiler().reportCodeChange();
            }
        }
        return;
    }
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);
    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        Node name1 = var.getFirstChild();
        Node maybeName2 = elseAssign.getFirstChild();
        if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) {
            Node thenExpr = name1.removeChildren();
            Node elseExpr = elseAssign.getLastChild().detachFromParent();
            cond.detachFromParent();
            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
            var.detachFromParent();
            name1.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            t.getCompiler().reportCodeChange();
        }
        // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        Node maybeName1 = thenAssign.getFirstChild();
        Node name2 = var.getFirstChild();
        if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) {
            Node thenExpr = thenAssign.getLastChild().detachFromParent();
            Node elseExpr = name2.removeChildren();
            cond.detachFromParent();
            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
            var.detachFromParent();
            name2.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            t.getCompiler().reportCodeChange();
        }
    }
}","public void test115125() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""Bad LS for assignmen: "");
    Node node1 = Node.newString(""Bad LS for assignmen: "", 38, 13);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node2 = new Node(26, node1, node0, 48, 21);
    foldConstants0.tryMinimizeIf((NodeTraversal) null, node2, node0);
    assertEquals(35, Node.QUOTED_PROP);
}","/**
 * Try turning IF nodes into smaller HOOKs
 */"
"void tryMinimizeIf(NodeTraversal t, Node n, Node parent) {
    Node cond = n.getFirstChild();
    Node thenBranch = cond.getNext();
    Node elseBranch = thenBranch.getNext();
    if (elseBranch == null) {
        if (isExpressBlock(thenBranch)) {
            Node expr = getBlockExpression(thenBranch);
            if (isPropertyAssignmentInExpression(t, expr)) {
                // Keep opportunities for CollapseProperties such as
                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;
                return;
            }
            if (cond.getType() == Token.NOT) {
                // if(!x)bar(); -> x||bar();
                if (isLowerPrecedenceInExpression(t, cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(t, expr.getFirstChild(), OR_PRECEDENCE)) {
                    // It's not okay to add two sets of parentheses.
                    return;
                }
                Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild());
                Node newExpr = NodeUtil.newExpr(or);
                parent.replaceChild(n, newExpr);
                t.getCompiler().reportCodeChange();
                return;
            }
            // if(x)foo(); -> x&&foo();
            if (isLowerPrecedenceInExpression(t, cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(t, expr.getFirstChild(), AND_PRECEDENCE)) {
                // One additional set of parentheses isn't worth it.
                return;
            }
            n.removeChild(cond);
            Node and = new Node(Token.AND, cond, expr.removeFirstChild());
            Node newExpr = NodeUtil.newExpr(and);
            parent.replaceChild(n, newExpr);
            t.getCompiler().reportCodeChange();
        }
        return;
    }
    tryRemoveRepeatedStatements(t, n);
    // if(!x)foo();else bar(); -> if(x)bar();else foo();
    // An additional set of curly braces isn't worth it.
    if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {
        n.replaceChild(cond, cond.removeFirstChild());
        n.removeChild(thenBranch);
        n.addChildToBack(thenBranch);
        t.getCompiler().reportCodeChange();
        return;
    }
    // if(x)return 1;else return 2; -> return x?1:2;
    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
        Node thenExpr = getBlockReturnExpression(thenBranch);
        Node elseExpr = getBlockReturnExpression(elseBranch);
        n.removeChild(cond);
        thenExpr.detachFromParent();
        elseExpr.detachFromParent();
        // note - we ignore any cases with ""return;"", technically this
        // can be converted to ""return undefined;"" or some variant, but
        // that does not help code size.
        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
        Node returnNode = new Node(Token.RETURN, hookNode);
        parent.replaceChild(n, returnNode);
        t.getCompiler().reportCodeChange();
        return;
    }
    boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch);
    boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch);
    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
        Node thenOp = getBlockExpression(thenBranch).getFirstChild();
        Node elseOp = getBlockExpression(elseBranch).getFirstChild();
        if (thenOp.getType() == elseOp.getType()) {
            // if(x)a=1;else a=2; -> a=x?1:2;
            if (NodeUtil.isAssignmentOp(thenOp)) {
                Node lhs = thenOp.getFirstChild();
                if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization
                // evaluates LHS before cond]
                // NOTE - there are some circumstances where we can
                // proceed even if there are side effects...
                !NodeUtil.mayEffectMutableState(lhs)) {
                    n.removeChild(cond);
                    Node assignName = thenOp.removeFirstChild();
                    Node thenExpr = thenOp.removeFirstChild();
                    Node elseExpr = elseOp.getLastChild();
                    elseOp.removeChild(elseExpr);
                    Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
                    Node assign = new Node(thenOp.getType(), assignName, hookNode);
                    Node expr = NodeUtil.newExpr(assign);
                    parent.replaceChild(n, expr);
                    t.getCompiler().reportCodeChange();
                }
            } else if (NodeUtil.isCall(thenOp)) {
                // if(x)foo();else bar(); -> x?foo():bar()
                n.removeChild(cond);
                thenOp.detachFromParent();
                elseOp.detachFromParent();
                Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp);
                Node expr = NodeUtil.newExpr(hookNode);
                parent.replaceChild(n, expr);
                t.getCompiler().reportCodeChange();
            }
        }
        return;
    }
    boolean thenBranchIsVar = isVarBlock(thenBranch);
    boolean elseBranchIsVar = isVarBlock(elseBranch);
    // if(x)var y=1;else y=2  ->  var y=x?1:2
    if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {
        Node var = getBlockVar(thenBranch);
        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();
        Node name1 = var.getFirstChild();
        Node maybeName2 = elseAssign.getFirstChild();
        if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) {
            Node thenExpr = name1.removeChildren();
            Node elseExpr = elseAssign.getLastChild().detachFromParent();
            cond.detachFromParent();
            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
            var.detachFromParent();
            name1.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            t.getCompiler().reportCodeChange();
        }
        // if(x)y=1;else var y=2  ->  var y=x?1:2
    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {
        Node var = getBlockVar(elseBranch);
        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();
        Node maybeName1 = thenAssign.getFirstChild();
        Node name2 = var.getFirstChild();
        if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) {
            Node thenExpr = thenAssign.getLastChild().detachFromParent();
            Node elseExpr = name2.removeChildren();
            cond.detachFromParent();
            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);
            var.detachFromParent();
            name2.addChildrenToBack(hookNode);
            parent.replaceChild(n, var);
            t.getCompiler().reportCodeChange();
        }
    }
}","public void test116126() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""Bad LS for assignmen: "", ""Bad LS for assignmen: "");
    Node node1 = Node.newString(""Bad LS for assignmen: "", 38, 13);
    FoldConstants foldConstants0 = new FoldConstants(compiler0);
    Node node2 = new Node(26, node1, node0, 48, 21);
    node0.addChildrenToBack(node2);
    foldConstants0.tryMinimizeIf((NodeTraversal) null, node2, node0);
    assertEquals((-1), Node.CATCH_SCOPE_PROP);
}","/**
 * Try turning IF nodes into smaller HOOKs
 */"
