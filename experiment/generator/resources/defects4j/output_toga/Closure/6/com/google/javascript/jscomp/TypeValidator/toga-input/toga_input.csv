focal_method,test_prefix,docstring
"// All non-private methods should have the form:
// expectCondition(NodeTraversal t, Node n, ...);
// If there is a mismatch, the {@code expect} method should issue
// a warning and attempt to correct the mismatch, when possible.
void expectValidTypeofName(NodeTraversal t, Node n, String found) {
    report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found));
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.rhino.head.ast.XmlRef"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ClosureRewriteClass closureRewriteClass0 = new ClosureRewriteClass(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, closureRewriteClass0);
    typeValidator0.expectValidTypeofName(nodeTraversal0, node0, ""com.google.javascript.rhino.head.ast.XmlRef"");
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoType();
    VarCheck varCheck0 = new VarCheck(compiler0, true);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, varCheck0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, node0);
    typeValidator0.expectNumber(nodeTraversal0, node0, functionType0, ""<uFh0B%Mqok 5Qm'4g"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"InlineProperties(AbstractCompiler compiler) {
    this.compiler = compiler;
    buildInvalidatingTypeSet();
}","public void test022() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""s4A[XTD"");
    InlineProperties inlineProperties0 = new InlineProperties(compiler0);
}",""
"boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) {
    if (!type.matchesObjectContext()) {
        mismatch(t, n, msg, type, OBJECT_TYPE);
        return false;
    }
    return true;
}","public void test044() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""[n]A.97h/d,n"");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoType();
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, jSType0, ""Not declared as a constructor"");
    assertTrue(boolean0);
}","/**
 * Expect the type to be an object, or a type convertible to object. If the
 * expectation is not met, issue a warning at the provided node's source code
 * position.
 * @return True if there was no warning, false if there was a mismatch.
 */"
"boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) {
    if (!type.matchesObjectContext()) {
        mismatch(t, n, msg, type, OBJECT_TYPE);
        return false;
    }
    return true;
}","public void test055() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""#M!Td_9QdzpvwM;W[C"");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    // Undeclared exception!
    try {
        typeValidator0.expectObject((NodeTraversal) null, node0, jSType0, (String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect the type to be an object, or a type convertible to object. If the
 * expectation is not met, issue a warning at the provided node's source code
 * position.
 * @return True if there was no warning, false if there was a mismatch.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test066() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.rhino.head.ast.XmlRef"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    StrictModeCheck strictModeCheck0 = new StrictModeCheck(compiler0, true, true);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, strictModeCheck0);
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    typeValidator0.expectActualObject(nodeTraversal0, node0, jSType0, ""M^dJr9 2rjR"");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test077() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    typeValidator0.expectActualObject(nodeTraversal0, node0, jSType0, ""F~\""8!okd"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test088() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""(hH 20;-Q7>&-"");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoType();
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    EnumType enumType0 = jSTypeRegistry0.createEnumType((String) null, node0, jSType0);
    FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0);
    typeValidator0.expectAnyObject(nodeTraversal0, node0, enumType0, ""|Jf*"");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.rhino.head.ast.XmlRef"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    NoType noType0 = (NoType) modificationVisitor0.caseNoType();
    FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0);
    typeValidator0.expectAnyObject(nodeTraversal0, node0, noType0, ""Not declared as a constructor"");
    assertTrue(noType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1010() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    typeValidator0.expectAnyObject(nodeTraversal0, (Node) null, jSType0, ""Q#"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    typeValidator0.expectString(nodeTraversal0, node0, jSType0, ""Not declared as a type name"");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1212() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, node0);
    typeValidator0.expectString(nodeTraversal0, node0, functionType0, ""Not declared as a constructor"");
    assertTrue(functionType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1213() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, node0);
    typeValidator0.expectString(nodeTraversal0, node0, functionType0, ""Not declared as a constructor"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"void expectNumber(NodeTraversal t, Node n, JSType type, String msg) {
    if (!type.matchesNumberContext()) {
        mismatch(t, n, msg, type, NUMBER_TYPE);
    }
}","public void test1314() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    typeValidator0.expectNumber((NodeTraversal) null, node0, jSType0, ""Named type with empty name component"");
    assertEquals(1, Node.FLAG_GLOBAL_STATE_UNMODIFIED);
}","/**
 * Expect the type to be a number, or a type convertible to number. If the
 * expectation is not met, issue a warning at the provided node's source code
 * position.
 */"
"void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) {
    if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) {
        mismatch(t, n, msg, type, allValueTypes);
    }
}","public void test1415() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoType();
    typeValidator0.expectBitwiseable((NodeTraversal) null, node0, jSType0, ""Unknown class name"");
    assertEquals(0, JSType.NOT_ENUMDECL);
}","/**
 * Expect the type to be a valid operand to a bitwise operator. This includes
 * numbers, any type convertible to a number, or any other primitive type
 * (undefined|null|boolean|string).
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1516() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, node0);
    typeValidator0.expectBitwiseable(nodeTraversal0, node0, functionType0, ""{y7~Is4<)*NTI*"");
    assertTrue(functionType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1517() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, node0);
    typeValidator0.expectBitwiseable(nodeTraversal0, node0, functionType0, ""{y7~Is4<)*NTI*"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1618() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""(hH s0;Q7>&-"");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoType();
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSType jSType1 = jSTypeRegistry0.createOptionalType(jSType0);
    CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.brokenClosureRequiresLevel);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0, (ScopeCreator) null);
    typeValidator0.expectBitwiseable(nodeTraversal0, node0, jSType1, ""w!"");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test1719() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    InlineSimpleMethods inlineSimpleMethods0 = new InlineSimpleMethods(compiler0);
    NodeTraversal.Callback nodeTraversal_Callback0 = inlineSimpleMethods0.getActingCallback();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, nodeTraversal_Callback0);
    typeValidator0.expectStringOrNumber(nodeTraversal0, (Node) null, jSType0, ""Not declared as a type name"");
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test1820() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A [XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.RANGE_ERROR_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    typeValidator0.expectStringOrNumber(nodeTraversal0, node0, objectType0, ""Named type with empty name component"");
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1821() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A [XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.RANGE_ERROR_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    typeValidator0.expectStringOrNumber(nodeTraversal0, node0, objectType0, ""Named type with empty name component"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1922() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseAllType();
    typeValidator0.expectStringOrNumber(nodeTraversal0, node0, jSType0, ""~h._4LX.92H3-vo)4` "");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
    if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) {
        // There's one edge case right now that we don't handle well, and
        // that we don't want to warn about.
        // if (this.x == null) {
        //   this.initializeX();
        //   this.x.foo();
        // }
        // In this case, we incorrectly type x because of how we
        // infer properties locally. See issue 109.
        // http://code.google.com/p/closure-compiler/issues/detail?id=109
        //
        // We do not do this inference globally.
        if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) {
            return true;
        }
        mismatch(t, n, msg, type, expectedType);
        return false;
    }
    return true;
}","public void test2023() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""ohH 2;Q7>&-"");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoType();
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined((NodeTraversal) null, node0, jSType0, ""Named type with empty name component"", jSType0);
    assertTrue(boolean0);
}","/**
 * Expect the type to be anything but the null or void type. If the
 * expectation is not met, issue a warning at the provided node's
 * source code position. Note that a union type that includes the
 * void type and at least one other type meets the expectation.
 * @return Whether the expectation was met.
 */"
"boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
    if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) {
        // There's one edge case right now that we don't handle well, and
        // that we don't want to warn about.
        // if (this.x == null) {
        //   this.initializeX();
        //   this.x.foo();
        // }
        // In this case, we incorrectly type x because of how we
        // infer properties locally. See issue 109.
        // http://code.google.com/p/closure-compiler/issues/detail?id=109
        //
        // We do not do this inference globally.
        if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) {
            return true;
        }
        mismatch(t, n, msg, type, expectedType);
        return false;
    }
    return true;
}","public void test2124() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    NameReferenceGraph nameReferenceGraph0 = new NameReferenceGraph(compiler0);
    NameReferenceGraph.Name nameReferenceGraph_Name0 = nameReferenceGraph0.WINDOW;
    JSType jSType0 = nameReferenceGraph_Name0.getType();
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, ""|Tgv|~lM<z;x+Lk&ln"", jSType0);
    assertTrue(boolean0);
}","/**
 * Expect the type to be anything but the null or void type. If the
 * expectation is not met, issue a warning at the provided node's
 * source code position. Note that a union type that includes the
 * void type and at least one other type meets the expectation.
 * @return Whether the expectation was met.
 */"
"boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
    if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) {
        // There's one edge case right now that we don't handle well, and
        // that we don't want to warn about.
        // if (this.x == null) {
        //   this.initializeX();
        //   this.x.foo();
        // }
        // In this case, we incorrectly type x because of how we
        // infer properties locally. See issue 109.
        // http://code.google.com/p/closure-compiler/issues/detail?id=109
        //
        // We do not do this inference globally.
        if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) {
            return true;
        }
        mismatch(t, n, msg, type, expectedType);
        return false;
    }
    return true;
}","public void test2225() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""s4A[XTD"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, enumType0, ""Not declared as a constructor"", enumType0);
    assertTrue(boolean0);
}","/**
 * Expect the type to be anything but the null or void type. If the
 * expectation is not met, issue a warning at the provided node's
 * source code position. Note that a union type that includes the
 * void type and at least one other type meets the expectation.
 * @return Whether the expectation was met.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2326() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    JSType jSType1 = jSTypeRegistry0.createOptionalType(jSType0);
    JSType jSType2 = modificationVisitor0.caseBooleanType();
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType1, ""Unknown class name"", jSType2);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
    if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) {
        // There's one edge case right now that we don't handle well, and
        // that we don't want to warn about.
        // if (this.x == null) {
        //   this.initializeX();
        //   this.x.foo();
        // }
        // In this case, we incorrectly type x because of how we
        // infer properties locally. See issue 109.
        // http://code.google.com/p/closure-compiler/issues/detail?id=109
        //
        // We do not do this inference globally.
        if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) {
            return true;
        }
        mismatch(t, n, msg, type, expectedType);
        return false;
    }
    return true;
}","public void test2327() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    JSType jSType1 = jSTypeRegistry0.createOptionalType(jSType0);
    JSType jSType2 = modificationVisitor0.caseBooleanType();
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType1, ""Unknown class name"", jSType2);
    assertFalse(boolean0);
}","/**
 * Expect the type to be anything but the null or void type. If the
 * expectation is not met, issue a warning at the provided node's
 * source code position. Note that a union type that includes the
 * void type and at least one other type meets the expectation.
 * @return Whether the expectation was met.
 */"
"public boolean isConstructor() {
    return false;
}","public void test2428() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    InlineSimpleMethods inlineSimpleMethods0 = new InlineSimpleMethods(compiler0);
    NodeTraversal.Callback nodeTraversal_Callback0 = inlineSimpleMethods0.getActingCallback();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, nodeTraversal_Callback0);
    typeValidator0.expectSwitchMatchesCase(nodeTraversal0, (Node) null, jSType0, jSType0);
    assertFalse(jSType0.isConstructor());
}","/**
 * Whether this type is a {@link FunctionType} that is a constructor or a
 * named type that points to such a type.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2529() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""s4A[XTD"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, jSType0, enumType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2630() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    JSType jSType1 = jSTypeRegistry0.createOptionalType(jSType0);
    JSType jSType2 = modificationVisitor0.caseBooleanType();
    typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, jSType1, jSType2);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work OK.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            // Do not type-check interface methods, because we expect that
            // they will have dummy implementations that do not match the type
            // annotations.
            JSType ownerType = getJSType(owner);
            if (ownerType.isFunctionPrototypeType()) {
                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
                    return true;
                }
            }
            mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test2731() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoType();
    FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, jSType0, jSType0, node0, ""Unknown class name"");
    assertTrue(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work OK.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            // Do not type-check interface methods, because we expect that
            // they will have dummy implementations that do not match the type
            // annotations.
            JSType ownerType = getJSType(owner);
            if (ownerType.isFunctionPrototypeType()) {
                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
                    return true;
                }
            }
            mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test2832() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""sA[XD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, jSType0, jSType0, node0, ""Not declared as a constructor"");
    assertTrue(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test2933() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.rhino.head.ast.XmlRef"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null, (ScopeCreator) null);
    JSType[] jSTypeArray0 = new JSType[7];
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType(jSType0, false, jSTypeArray0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, jSType0, functionType0, node0, ""Unknown class name"");
    assertTrue(functionType0.hasCachedValues());
}",""
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work OK.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            // Do not type-check interface methods, because we expect that
            // they will have dummy implementations that do not match the type
            // annotations.
            JSType ownerType = getJSType(owner);
            if (ownerType.isFunctionPrototypeType()) {
                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
                    return true;
                }
            }
            mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test2934() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.rhino.head.ast.XmlRef"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null, (ScopeCreator) null);
    JSType[] jSTypeArray0 = new JSType[7];
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType(jSType0, false, jSTypeArray0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, jSType0, functionType0, node0, ""Unknown class name"");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test3035() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, jSType0, enumType0, node0, ""Named type with empty name component"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work OK.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            // Do not type-check interface methods, because we expect that
            // they will have dummy implementations that do not match the type
            // annotations.
            JSType ownerType = getJSType(owner);
            if (ownerType.isFunctionPrototypeType()) {
                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
                    return true;
                }
            }
            mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test3036() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, jSType0, enumType0, node0, ""Named type with empty name component"");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work OK.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            // Do not type-check interface methods, because we expect that
            // they will have dummy implementations that do not match the type
            // annotations.
            JSType ownerType = getJSType(owner);
            if (ownerType.isFunctionPrototypeType()) {
                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
                    return true;
                }
            }
            mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test3137() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""4\"">e:P9G%oD*"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    EnumType enumType1 = jSTypeRegistry0.createEnumType(""4\"">e:P9G%oD*"", node0, jSType0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, enumType1, enumType0, node0, """");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test3138() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""4\"">e:P9G%oD*"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    EnumType enumType1 = jSTypeRegistry0.createEnumType(""4\"">e:P9G%oD*"", node0, jSType0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, enumType1, enumType0, node0, """");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            mismatch(t, n, msg, rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test3239() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, jSType0, jSType0, ""Not declared as a constructor"");
    assertTrue(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test3340() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s`4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Named type with empty name component"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, enumType0, jSType0, ""Not declared as a constructor"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            mismatch(t, n, msg, rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test3341() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s`4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Named type with empty name component"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, enumType0, jSType0, ""Not declared as a constructor"");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test3442() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, jSType0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, jSType0, enumType0, """");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            mismatch(t, n, msg, rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test3443() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, jSType0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, jSType0, enumType0, """");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test3544() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""(hH 20;-Q7>&-"");
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    NoType noType0 = (NoType) modificationVisitor0.caseNoType();
    NullType nullType0 = (NullType) modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""5_0^ EnV;"", node0, nullType0);
    GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, enumType0, noType0, ""Not declared as a type name"");
    assertTrue(noType0.hasCachedValues());
}",""
"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            mismatch(t, n, msg, rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test3545() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""(hH 20;-Q7>&-"");
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    NoType noType0 = (NoType) modificationVisitor0.caseNoType();
    NullType nullType0 = (NullType) modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""5_0^ EnV;"", node0, nullType0);
    GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, enumType0, noType0, ""Not declared as a type name"");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */"
"public int getLineNumber() {
    Node cur = curNode;
    while (cur != null) {
        int line = cur.getLineno();
        if (line >= 0) {
            return line;
        }
        cur = cur.getParent();
    }
    return 0;
}","public void test3646() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, node0, jSType0, jSType0, node0, 40);
    assertEquals(0, nodeTraversal0.getLineNumber());
}","/**
 * Gets the current line number, or zero if it cannot be determined. The line
 * number is retrieved lazily as a running time optimization.
 */"
"void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) {
    if (!argType.canAssignTo(paramType)) {
        mismatch(t, n, String.format(""actual parameter %d of %s does not match "" + ""formal parameter"", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType);
    }
}","public void test3747() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""ohH 2;Q7>&-"");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    JSType jSType1 = modificationVisitor0.caseNoType();
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
    // Undeclared exception!
    try {
        typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, node0, jSType0, jSType1, node0, 1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect that the type of an argument matches the type of the parameter
 * that it's fulfilling.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param argType The type of the argument.
 * @param paramType The type of the parameter.
 * @param callNode The call node, to help with the warning message.
 * @param ordinal The argument ordinal, to help with the warning message.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test3848() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    typeValidator0.expectCanOverride(nodeTraversal0, node0, jSType0, jSType0, ""Z\""]|+*^8;"", jSType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test3949() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    InlineSimpleMethods inlineSimpleMethods0 = new InlineSimpleMethods(compiler0);
    NodeTraversal.Callback nodeTraversal_Callback0 = inlineSimpleMethods0.getActingCallback();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, nodeTraversal_Callback0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (Node) null);
    typeValidator0.expectCanOverride(nodeTraversal0, (Node) null, functionType0, jSType0, ""variable {0} redefined with type {1}, original definition at {2}:{3} with type {4}"", functionType0);
    assertTrue(functionType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test3950() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    InlineSimpleMethods inlineSimpleMethods0 = new InlineSimpleMethods(compiler0);
    NodeTraversal.Callback nodeTraversal_Callback0 = inlineSimpleMethods0.getActingCallback();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, nodeTraversal_Callback0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (Node) null);
    typeValidator0.expectCanOverride(nodeTraversal0, (Node) null, functionType0, jSType0, ""variable {0} redefined with type {1}, original definition at {2}:{3} with type {4}"", functionType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test4051() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A [XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.RANGE_ERROR_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    typeValidator0.expectSuperType(nodeTraversal0, node0, objectType0, objectType0);
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test4052() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A [XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0, typedScopeCreator0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.RANGE_ERROR_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    typeValidator0.expectSuperType(nodeTraversal0, node0, objectType0, objectType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) {
    FunctionType subCtor = subObject.getConstructor();
    ObjectType implicitProto = subObject.getImplicitPrototype();
    ObjectType declaredSuper = implicitProto == null ? null : implicitProto.getImplicitPrototype();
    if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) {
        if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) {
            registerMismatch(superObject, declaredSuper, report(t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())));
        } else {
            mismatch(t.getSourceName(), n, ""mismatch in declaration of superclass type"", superObject, declaredSuper);
        }
        // Correct the super type.
        if (!subCtor.hasCachedValues()) {
            subCtor.setPrototypeBasedOn(superObject);
        }
    }
}","public void test4153() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""ohH 2;Q7>&-"");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    NoType noType0 = (NoType) modificationVisitor0.caseNoType();
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0, typedScopeCreator0);
    typeValidator0.expectSuperType(nodeTraversal0, node0, noType0, noType0);
    assertEquals(43, Node.IS_CONSTANT_NAME);
}","/**
 * Expect that the first type is the direct superclass of the second type.
 *
 * @param t The node traversal.
 * @param n The node where warnings should point to.
 * @param superObject The expected super instance type.
 * @param subObject The sub instance type.
 */"
"void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) {
    FunctionType subCtor = subObject.getConstructor();
    ObjectType implicitProto = subObject.getImplicitPrototype();
    ObjectType declaredSuper = implicitProto == null ? null : implicitProto.getImplicitPrototype();
    if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) {
        if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) {
            registerMismatch(superObject, declaredSuper, report(t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())));
        } else {
            mismatch(t.getSourceName(), n, ""mismatch in declaration of superclass type"", superObject, declaredSuper);
        }
        // Correct the super type.
        if (!subCtor.hasCachedValues()) {
            subCtor.setPrototypeBasedOn(superObject);
        }
    }
}","public void test4254() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""#M!Td_9QdzpvwM;W[C"");
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""unknown type: {0}"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeNative jSTypeNative0 = JSTypeNative.UNKNOWN_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    typeValidator0.expectSuperType(nodeTraversal0, node0, objectType0, enumType0);
    assertEquals(53, Node.INPUT_ID);
}","/**
 * Expect that the first type is the direct superclass of the second type.
 *
 * @param t The node traversal.
 * @param n The node where warnings should point to.
 * @param superObject The expected super instance type.
 * @param subObject The sub instance type.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test4355() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    typeValidator0.expectSuperType(nodeTraversal0, node0, objectType0, objectType0);
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test4356() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    typeValidator0.expectSuperType(nodeTraversal0, node0, objectType0, objectType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) {
    castType = castType.restrictByNotNullOrUndefined();
    type = type.restrictByNotNullOrUndefined();
    if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {
        registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST, castType.toString(), type.toString())));
    }
}","public void test4457() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    typeValidator0.expectCanCast(nodeTraversal0, node0, enumType0, enumType0);
    assertEquals(2, Node.POST_FLAG);
}","/**
 * Expect that the first type can be cast to the second type. The first type
 * should be either a subtype or supertype of the second.
 *
 * @param t The node traversal.
 * @param n The node where warnings should point.
 * @param type The type being cast from.
 * @param castType The type being cast to.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test4558() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    typeValidator0.expectCanCast(nodeTraversal0, node0, enumType0, jSType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test4659() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Named type with empty name component"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType((JSDocInfo) null);
    typeValidator0.expectCanCast(nodeTraversal0, node0, enumType0, objectType0);
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test4660() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Named type with empty name component"", node0, jSType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType((JSDocInfo) null);
    typeValidator0.expectCanCast(nodeTraversal0, node0, enumType0, objectType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"Var expectUndeclaredVariable(String sourceName, CompilerInput input, Node n, Node parent, Var var, String variableName, JSType newType) {
    Var newVar = var;
    boolean allowDupe = false;
    if (n.isGetProp() || NodeUtil.isObjectLitKey(n, parent)) {
        JSDocInfo info = n.getJSDocInfo();
        if (info == null) {
            info = parent.getJSDocInfo();
        }
        allowDupe = info != null && info.getSuppressions().contains(""duplicate"");
    }
    JSType varType = var.getType();
    // Only report duplicate declarations that have types. Other duplicates
    // will be reported by the syntactic scope creator later in the
    // compilation process.
    if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
        // If there are two typed declarations of the same variable, that
        // is an error and the second declaration is ignored, except in the
        // case of native types. A null input type means that the declaration
        // was made in TypedScopeCreator#createInitialScope and is a
        // native type. We should redeclare it at the new input site.
        if (var.input == null) {
            Scope s = var.getScope();
            s.undeclare(var);
            newVar = s.declare(variableName, n, varType, input, false);
            n.setJSType(varType);
            if (parent.isVar()) {
                if (n.getFirstChild() != null) {
                    n.getFirstChild().setJSType(varType);
                }
            } else {
                Preconditions.checkState(parent.isFunction());
                parent.setJSType(varType);
            }
        } else {
            // Always warn about duplicates if the overridden type does not
            // match the original type.
            //
            // If the types match, suppress the warning iff there was a @suppress
            // tag, or if the original declaration was a stub.
            if (!(allowDupe || var.getParentNode().isExprResult()) || !newType.isEquivalentTo(varType)) {
                report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString()));
            }
        }
    }
    return newVar;
}","public void test4761() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.rhino.head.ast.XmlRef"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.STRING_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    InputId inputId0 = node0.getInputId();
    CompilerInput compilerInput0 = compiler0.getInput(inputId0);
    Scope.Var scope_Var0 = mock(Scope.Var.class, new ViolatedAssumptionAnswer());
    doReturn((Scope) null).when(scope_Var0).getScope();
    doReturn(jSType0).when(scope_Var0).getType();
    // Undeclared exception!
    try {
        typeValidator0.expectUndeclaredVariable(""Named type with empty name component"", compilerInput0, node0, node0, scope_Var0, ""Not declared as a constructor"", jSType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect that the given variable has not been declared with a type.
 *
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just here
 *     for the benefit of the warning.
 * @return The variable we end up with. Most of the time, this will just
 *     be {@code var}, but in some rare cases we will need to declare
 *     a new var with new source info.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test5064() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.rhino.head.ast.XmlRef"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null, (ScopeCreator) null);
    JSType[] jSTypeArray0 = new JSType[7];
    jSTypeArray0[0] = jSType0;
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType(jSType0, false, jSTypeArray0);
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, jSType0, ""g}anvg/coPorL5"");
    assertTrue(functionType0.hasCachedValues());
}",""
"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            mismatch(t, n, msg, rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test5065() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.rhino.head.ast.XmlRef"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null, (ScopeCreator) null);
    JSType[] jSTypeArray0 = new JSType[7];
    jSTypeArray0[0] = jSType0;
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType(jSType0, false, jSTypeArray0);
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, jSType0, ""g}anvg/coPorL5"");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */"
"String getReadableJSTypeName(Node n, boolean dereference) {
    // If we're analyzing a GETPROP, the property may be inherited by the
    // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {
                objectType = FunctionType.getTopDefiningInterface(objectType, propName);
            } else {
                // classes
                while (objectType != null && !objectType.hasOwnProperty(propName)) {
                    objectType = objectType.getImplicitPrototype();
                }
            }
            // Don't show complex function names or anonymous types.
            // Instead, try to get a human-readable type name.
            if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }
    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    String qualifiedName = n.getQualifiedName();
    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    } else if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        // Don't show complex function names.
        return ""function"";
    } else {
        return type.toString();
    }
}","public void test5166() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.rhino.head.ast.XmlRef"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    String string0 = typeValidator0.getReadableJSTypeName(node0, false);
    assertEquals(""?"", string0);
}","/**
 * Given a node, get a human-readable name for the type of that node so
 * that will be easy for the programmer to find the original declaration.
 *
 * For example, if SubFoo's property ""bar"" might have the human-readable
 * name ""Foo.prototype.bar"".
 *
 * @param n The node.
 * @param dereference If true, the type of the node will be dereferenced
 *     to an Object type, if possible.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test5267() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    InlineSimpleMethods inlineSimpleMethods0 = new InlineSimpleMethods(compiler0);
    NodeTraversal.Callback nodeTraversal_Callback0 = inlineSimpleMethods0.getActingCallback();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, nodeTraversal_Callback0);
    typeValidator0.setShouldReport(false);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (Node) null);
    JSType jSType1 = jSTypeRegistry0.createOptionalType(jSType0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, (Node) null, functionType0, jSType1, node0, ""e1!r`,AKpl?T"");
    assertTrue(functionType0.hasCachedValues());
}",""
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work OK.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
            registerMismatch(rightType, leftType, null);
        } else {
            // Do not type-check interface methods, because we expect that
            // they will have dummy implementations that do not match the type
            // annotations.
            JSType ownerType = getJSType(owner);
            if (ownerType.isFunctionPrototypeType()) {
                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
                    return true;
                }
            }
            mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test5268() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    InlineSimpleMethods inlineSimpleMethods0 = new InlineSimpleMethods(compiler0);
    NodeTraversal.Callback nodeTraversal_Callback0 = inlineSimpleMethods0.getActingCallback();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, nodeTraversal_Callback0);
    typeValidator0.setShouldReport(false);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (Node) null);
    JSType jSType1 = jSTypeRegistry0.createOptionalType(jSType0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, (Node) null, functionType0, jSType1, node0, ""e1!r`,AKpl?T"");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test5672() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, jSType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    String[] stringArray0 = new String[8];
    JSError jSError0 = JSError.make(node0, compiler0.OPTIMIZE_LOOP_ERROR, stringArray0);
    TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(enumElementType0, jSType0, jSError0);
    TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(enumElementType0, enumType0, jSError0);
    boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test5774() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""s4A[XTD"");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, jSType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    String[] stringArray0 = new String[8];
    JSError jSError0 = JSError.make(node0, compiler0.OPTIMIZE_LOOP_ERROR, stringArray0);
    TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(enumElementType0, jSType0, jSError0);
    TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(enumElementType0, enumElementType0, jSError0);
    boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
