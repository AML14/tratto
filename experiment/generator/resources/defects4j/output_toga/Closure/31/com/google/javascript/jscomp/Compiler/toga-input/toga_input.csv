focal_method,test_prefix,docstring
"public <T extends SourceFile> Result compileModules(List<T> externs, List<JSModule> modules, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        initModules(externs, modules, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test0000() throws Throwable {
    Compiler compiler0 = new Compiler();
    LinkedList<SourceFile> linkedList0 = new LinkedList<SourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile((List<SourceFile>) linkedList0, (List<SourceFile>) linkedList0, compilerOptions0);
    ArrayList<JSModule> arrayList0 = new ArrayList<JSModule>();
    // Undeclared exception!
    try {
        compiler0.compileModules((List<SourceFile>) linkedList0, (List<JSModule>) arrayList0, compilerOptions0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Compiles a list of modules.
 */"
"public String toSource(final JSModule module) {
    return runInCompilerThread(new Callable<String>() {

        @Override
        public String call() throws Exception {
            List<CompilerInput> inputs = module.getInputs();
            int numInputs = inputs.size();
            if (numInputs == 0) {
                return """";
            }
            CodeBuilder cb = new CodeBuilder();
            for (int i = 0; i < numInputs; i++) {
                Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);
                if (scriptNode == null) {
                    throw new IllegalArgumentException(""Bad module: "" + module.getName());
                }
                toSource(cb, i, scriptNode);
            }
            return cb.toString();
        }
    });
}","public void test0011() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.toSource((JSModule) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Converts the parse tree for a module back to js code.
 */"
"public String[] toSourceArray() {
    return runInCompilerThread(new Callable<String[]>() {

        @Override
        public String[] call() throws Exception {
            Tracer tracer = newTracer(""toSourceArray"");
            try {
                int numInputs = inputs.size();
                String[] sources = new String[numInputs];
                CodeBuilder cb = new CodeBuilder();
                for (int i = 0; i < numInputs; i++) {
                    Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);
                    cb.reset();
                    toSource(cb, i, scriptNode);
                    sources[i] = cb.toString();
                }
                return sources;
            } finally {
                stopTracer(tracer, ""toSourceArray"");
            }
        }
    });
}","public void test0022() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.toSourceArray();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Converts the parse tree for each input back to js code.
 */"
"//------------------------------------------------------------------------
// Convert back to source code
//------------------------------------------------------------------------
/**
 * Converts the main parse tree back to js code.
 */
public String toSource() {
    return runInCompilerThread(new Callable<String>() {

        @Override
        public String call() throws Exception {
            Tracer tracer = newTracer(""toSource"");
            try {
                CodeBuilder cb = new CodeBuilder();
                if (jsRoot != null) {
                    int i = 0;
                    for (Node scriptNode = jsRoot.getFirstChild(); scriptNode != null; scriptNode = scriptNode.getNext()) {
                        toSource(cb, i++, scriptNode);
                    }
                }
                return cb.toString();
            } finally {
                stopTracer(tracer, ""toSource"");
            }
        }
    });
}","public void test0033() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.toSource();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {
    runInCompilerThread(new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            if (options.printInputDelimiter) {
                if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
                    // Make sure that the label starts on a new line
                    cb.append(""\n"");
                }
                Preconditions.checkState(root.isScript());
                String delimiter = options.inputDelimiter;
                String inputName = root.getInputId().getIdName();
                String sourceName = root.getSourceFileName();
                Preconditions.checkState(sourceName != null);
                Preconditions.checkState(!sourceName.isEmpty());
                delimiter = delimiter.replaceAll(""%name%"", Matcher.quoteReplacement(inputName)).replaceAll(""%num%"", String.valueOf(inputSeqNum));
                cb.append(delimiter).append(""\n"");
            }
            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {
                cb.append(""/*\n"").append(root.getJSDocInfo().getLicense()).append(""*/\n"");
            }
            // If there is a valid source map, then indicate to it that the current
            // root node's mappings are offset by the given string builder buffer.
            if (options.sourceMapOutputPath != null) {
                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());
            }
            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
            // for the first input file
            String code = toSource(root, sourceMap, inputSeqNum == 0);
            if (!code.isEmpty()) {
                cb.append(code);
                // In order to avoid parse ambiguity when files are concatenated
                // together, all files should end in a semi-colon. Do a quick
                // heuristic check if there's an obvious semi-colon already there.
                int length = code.length();
                char lastChar = code.charAt(length - 1);
                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0';
                boolean hasSemiColon = lastChar == ';' || (lastChar == '\n' && secondLastChar == ';');
                if (!hasSemiColon) {
                    cb.append("";"");
                }
            }
            return null;
        }
    });
}","public void test0044() throws Throwable {
    Compiler compiler0 = new Compiler();
    Compiler.CodeBuilder compiler_CodeBuilder0 = new Compiler.CodeBuilder();
    Node node0 = Node.newString(""P\""DXNvWV_57W"");
    // Undeclared exception!
    try {
        compiler0.toSource(compiler_CodeBuilder0, 1459, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Writes out js code from a root node. If printing input delimiters, this
 * method will attach a comment to the start of the text indicating which
 * input the output derived from. If there were any preserve annotations
 * within the root's source, they will also be printed in a block comment
 * at the beginning of the output.
 */"
"public String[] toSourceArray(final JSModule module) {
    return runInCompilerThread(new Callable<String[]>() {

        @Override
        public String[] call() throws Exception {
            List<CompilerInput> inputs = module.getInputs();
            int numInputs = inputs.size();
            if (numInputs == 0) {
                return new String[0];
            }
            String[] sources = new String[numInputs];
            CodeBuilder cb = new CodeBuilder();
            for (int i = 0; i < numInputs; i++) {
                Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);
                if (scriptNode == null) {
                    throw new IllegalArgumentException(""Bad module input: "" + inputs.get(i).getName());
                }
                cb.reset();
                toSource(cb, i, scriptNode);
                sources[i] = cb.toString();
            }
            return sources;
        }
    });
}","public void test0055() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.toSourceArray((JSModule) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Converts the parse tree for each input in a module back to js code.
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test0066() throws Throwable {
    Compiler compiler0 = new Compiler();
    LinkedList<SourceFile> linkedList0 = new LinkedList<SourceFile>();
    compiler0.disableThreads();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test0067() throws Throwable {
    Compiler compiler0 = new Compiler();
    LinkedList<SourceFile> linkedList0 = new LinkedList<SourceFile>();
    compiler0.disableThreads();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile((List<SourceFile>) linkedList0, (List<SourceFile>) linkedList0, compilerOptions0);
    assertEquals(1.0, compiler0.getProgress(), 0.01);
}",""
"public void init(JSSourceFile[] externs, JSModule[] modules, CompilerOptions options) {
    initModules(Lists.<SourceFile>newArrayList(externs), Lists.<JSModule>newArrayList(modules), options);
}","public void test0078() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSModule[] jSModuleArray0 = new JSModule[0];
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    // Undeclared exception!
    try {
        compiler0.init((JSSourceFile[]) null, jSModuleArray0, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Initializes the instance state needed for a compile job if the sources
 * are in modules.
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test0089() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.resetUniqueNameId();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
CssRenamingMap getCssRenamingMap() {
    return options.cssRenamingMap;
}","public void test01011() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getCssRenamingMap();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
boolean hasRegExpGlobalReferences() {
    return hasRegExpGlobalReferences;
}","public void test01112() throws Throwable {
    Compiler compiler0 = new Compiler();
    boolean boolean0 = compiler0.hasRegExpGlobalReferences();
    assertTrue(boolean0);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test01113() throws Throwable {
    Compiler compiler0 = new Compiler();
    boolean boolean0 = compiler0.hasRegExpGlobalReferences();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test01214() throws Throwable {
    Compiler compiler0 = new Compiler();
    Compiler.IntermediateState compiler_IntermediateState0 = compiler0.getState();
    compiler0.setState(compiler_IntermediateState0);
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"public void init(JSSourceFile[] externs, JSSourceFile[] inputs, CompilerOptions options) {
    init(Lists.<JSSourceFile>newArrayList(externs), Lists.<JSSourceFile>newArrayList(inputs), options);
}","public void test01315() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    // Undeclared exception!
    try {
        compiler0.init((JSSourceFile[]) null, (JSSourceFile[]) null, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Initializes the instance state needed for a compile job.
 */"
"public void rebuildInputsFromModules() {
    inputs = getAllInputsFromModules(modules);
    initInputsByIdMap();
}","public void test01517() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.rebuildInputsFromModules();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Rebuilds the internal list of inputs by iterating over all modules.
 * This is necessary if inputs have been added to or removed from a module
 * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.
 */"
"ControlFlowGraph<Node> computeCFG() {
    logger.fine(""Computing Control Flow Graph"");
    Tracer tracer = newTracer(""computeCFG"");
    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);
    process(cfa);
    stopTracer(tracer, ""computeCFG"");
    return cfa.getCfg();
}","public void test01618() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.computeCFG();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Control Flow Analysis.
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test01719() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getPropertyMap();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"public void processDefines() {
    (new DefaultPassConfig(options)).processDefines.create(this).process(externsRoot, jsRoot);
}","public void test01820() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.processDefines();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.DefaultPassConfig"", e);
    }
}","/**
 * Reprocesses the current defines over the AST.  This is used by GwtCompiler
 * to generate N outputs for different targets from the same (checked) AST.
 * For each target, we apply the target-specific defines by calling
 * {@code processDefines} and then {@code optimize} to optimize the AST
 * specifically for that target.
 */"
"static <T> T runCallableWithLargeStack(final Callable<T> callable) {
    return runCallable(callable, true, false);
}","public void test01921() throws Throwable {
    // Undeclared exception!
    try {
        Compiler.runCallableWithLargeStack((Callable<Scope.Var>) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.lang.NullPointerException
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public LanguageMode languageMode() {
    return options.getLanguageIn();
}","public void test02022() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.languageMode();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
void setCssRenamingMap(CssRenamingMap map) {
    options.cssRenamingMap = map;
}","public void test02123() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.setCssRenamingMap((CssRenamingMap) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test02224() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getWarningCount();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the number of warnings.
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test02325() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getVariableMap();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test02426() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getFunctionalInformationMap();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"void recordFunctionInformation() {
    logger.fine(""Recording function information"");
    startPass(""recordFunctionInformation"");
    RecordFunctionInformation recordFunctionInfoPass = new RecordFunctionInformation(this, getPassConfig().getIntermediateState().functionNames);
    process(recordFunctionInfoPass);
    functionInformationMap = recordFunctionInfoPass.getMap();
    endPass();
}","public void test02527() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.recordFunctionInformation();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test02628() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test02629() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    compiler0.getAstDotGraph();
    assertEquals(1.0, compiler0.getProgress(), 0.01);
}",""
"public Result compile(SourceFile extern, JSSourceFile[] input, CompilerOptions options) {
    return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);
}","public void test02730() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""N.R"", ""PassConfigs must eventually delegate to the DefaultPassConfig"");
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[2];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    // Undeclared exception!
    try {
        compiler0.compile((SourceFile) jSSourceFile0, jSSourceFileArray0, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test02831() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getModuleGraph();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"public Result compile(SourceFile extern, SourceFile input, CompilerOptions options) {
    return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);
}","public void test02932() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    // Undeclared exception!
    try {
        compiler0.compile((SourceFile) null, (SourceFile) null, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test03033() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getSourceMap();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test03134() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.isTypeCheckingEnabled();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test03235() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getInputsForTesting();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test03336() throws Throwable {
    Compiler compiler0 = new Compiler();
    CodeChangeHandler.RecentChange codeChangeHandler_RecentChange0 = new CodeChangeHandler.RecentChange();
    compiler0.removeChangeHandler(codeChangeHandler_RecentChange0);
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"public Map<InputId, CompilerInput> getInputsById() {
    return Collections.unmodifiableMap(inputsById);
}","public void test03437() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getInputsById();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Collections$UnmodifiableMap"", e);
    }
}","/**
 * Returns an unmodifiable view of the compiler inputs indexed by id.
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test03538() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.setHasRegExpGlobalReferences(true);
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"public Compiler(ErrorManager errorManager) {
    this();
    setErrorManager(errorManager);
}","public void test03639() throws Throwable {
    Compiler compiler0 = null;
    try {
        compiler0 = new Compiler((ErrorManager) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // the error manager cannot be null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates a Compiler that uses a custom error manager.
 */"
"public Result compile(JSSourceFile extern, JSModule[] modules, CompilerOptions options) {
    return compileModules(Lists.newArrayList(extern), Lists.newArrayList(modules), options);
}","public void test03740() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    // Undeclared exception!
    try {
        compiler0.compile((JSSourceFile) null, (JSModule[]) null, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"public JSError[] getMessages() {
    return getErrors();
}","public void test03841() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getMessages();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Returns an array constructed from errors + temporary warnings.
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test03942() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getExternsForTesting();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"void removeTryCatchFinally() {
    logger.fine(""Remove try/catch/finally"");
    startPass(""removeTryCatchFinally"");
    RemoveTryCatch r = new RemoveTryCatch(this);
    process(r);
    endPass();
}","public void test04043() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.removeTryCatchFinally();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Removes try/catch/finally statements for easier debugging.
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test04144() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getTopScope();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test04750() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    compiler0.parseTestCode("""");
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    assertEquals(1.0, compiler0.getProgress(), 0.01);
}",""
"public String getSourceFileName() {
    StaticSourceFile file = getStaticSourceFile();
    return file == null ? null : file.getName();
}","public void test04851() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""!(L6"");
    Compiler compiler0 = new Compiler(mockPrintStream0);
    Node node0 = compiler0.parseSyntheticCode(""base"", ""base"");
    assertEquals(""base"", node0.getSourceFileName());
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test04852() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""!(L6"");
    Compiler compiler0 = new Compiler(mockPrintStream0);
    Node node0 = compiler0.parseSyntheticCode(""base"", ""base"");
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test04853() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""!(L6"");
    Compiler compiler0 = new Compiler(mockPrintStream0);
    Node node0 = compiler0.parseSyntheticCode(""base"", ""base"");
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test04954() throws Throwable {
    Compiler compiler0 = new Compiler();
    Vector<SourceFile> vector0 = new Vector<SourceFile>();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    compilerOptions0.checkGlobalThisLevel = checkLevel0;
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test04955() throws Throwable {
    Compiler compiler0 = new Compiler();
    Vector<SourceFile> vector0 = new Vector<SourceFile>();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    compilerOptions0.checkGlobalThisLevel = checkLevel0;
    compiler0.compile((List<SourceFile>) vector0, (List<SourceFile>) vector0, compilerOptions0);
    assertEquals(1.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test05056() throws Throwable {
    Compiler compiler0 = new Compiler();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test05057() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Stack<SourceFile> stack0 = new Stack<SourceFile>();
    compilerOptions0.sourceMapOutputPath = ""com.google.javascript.jscomp.Compiler$IntermediateState"";
    compiler0.compile((List<SourceFile>) stack0, (List<SourceFile>) stack0, compilerOptions0);
    assertEquals(1.0, compiler0.getProgress(), 0.01);
}",""
"public <T1 extends SourceFile, T2 extends SourceFile> Result compile(List<T1> externs, List<T2> inputs, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        init(externs, inputs, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test05158() throws Throwable {
    Compiler compiler0 = new Compiler();
    Stack<SourceFile> stack0 = new Stack<SourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile((List<SourceFile>) stack0, (List<SourceFile>) stack0, compilerOptions0);
    // Undeclared exception!
    try {
        compiler0.compile((List<SourceFile>) stack0, (List<SourceFile>) stack0, compilerOptions0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Compiles a list of inputs.
 */"
"@Override
Node ensureLibraryInjected(String resourceName) {
    if (injectedLibraries.containsKey(resourceName)) {
        return null;
    }
    // All libraries depend on js/base.js
    boolean isBase = ""base"".equals(resourceName);
    if (!isBase) {
        ensureLibraryInjected(""base"");
    }
    Node firstChild = loadLibraryCode(resourceName).removeChildren();
    Node lastChild = firstChild.getLastSibling();
    Node parent = getNodeForCodeInsertion(null);
    if (isBase) {
        parent.addChildrenToFront(firstChild);
    } else {
        parent.addChildrenAfter(firstChild, injectedLibraries.get(""base""));
    }
    reportCodeChange();
    injectedLibraries.put(resourceName, lastChild);
    return lastChild;
}","public void test05259() throws Throwable {
    Compiler compiler0 = new Compiler();
    ArrayList<JSModule> arrayList0 = new ArrayList<JSModule>();
    JSModule jSModule0 = new JSModule(""-0CBeX'"");
    arrayList0.add(jSModule0);
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    Stack<SourceFile> stack0 = new Stack<SourceFile>();
    compiler0.compileModules((List<SourceFile>) stack0, (List<JSModule>) arrayList0, compilerOptions0);
    // Undeclared exception!
    try {
        compiler0.ensureLibraryInjected((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.io.Reader"", e);
    }
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test05360() throws Throwable {
    Compiler compiler0 = new Compiler();
    Vector<SourceFile> vector0 = new Vector<SourceFile>();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    LinkedList<JSModule> linkedList0 = new LinkedList<JSModule>();
    compiler0.compileModules((List<SourceFile>) vector0, (List<JSModule>) linkedList0, compilerOptions0);
    compiler0.parseInputs();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@SuppressWarnings(""unchecked"")
static <T> T runCallable(final Callable<T> callable, boolean useLargeStackThread, boolean trace) {
    // Under JRE 1.6, the jscompiler overflows the stack when running on some
    // large or complex js code. Here we start a new thread with a larger
    // stack in order to let the compiler do its thing, without having to
    // increase the stack size for *every* thread (which is what -Xss does).
    // Might want to add thread pool support for clients that compile a lot.
    final boolean dumpTraceReport = trace;
    final Object[] result = new Object[1];
    final Throwable[] exception = new Throwable[1];
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            try {
                if (dumpTraceReport) {
                    Tracer.initCurrentThreadTrace();
                }
                result[0] = callable.call();
            } catch (Throwable e) {
                exception[0] = e;
            } finally {
                if (dumpTraceReport) {
                    Tracer.logAndClearCurrentThreadTrace();
                }
            }
        }
    };
    if (useLargeStackThread) {
        Thread th = new Thread(null, runnable, ""jscompiler"", COMPILER_STACK_SIZE);
        th.start();
        while (true) {
            try {
                th.join();
                break;
            } catch (InterruptedException ignore) {
                // ignore
            }
        }
    } else {
        runnable.run();
    }
    // Pass on any exception caught by the runnable object.
    if (exception[0] != null) {
        throw new RuntimeException(exception[0]);
    }
    return (T) result[0];
}","public void test05461() throws Throwable {
    // Undeclared exception!
    try {
        Compiler.runCallable((Callable<AnalyzePrototypeProperties>) null, false, true);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.lang.NullPointerException
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
static <T> T runCallable(final Callable<T> callable, boolean useLargeStackThread, boolean trace) {
    // Under JRE 1.6, the jscompiler overflows the stack when running on some
    // large or complex js code. Here we start a new thread with a larger
    // stack in order to let the compiler do its thing, without having to
    // increase the stack size for *every* thread (which is what -Xss does).
    // Might want to add thread pool support for clients that compile a lot.
    final boolean dumpTraceReport = trace;
    final Object[] result = new Object[1];
    final Throwable[] exception = new Throwable[1];
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            try {
                if (dumpTraceReport) {
                    Tracer.initCurrentThreadTrace();
                }
                result[0] = callable.call();
            } catch (Throwable e) {
                exception[0] = e;
            } finally {
                if (dumpTraceReport) {
                    Tracer.logAndClearCurrentThreadTrace();
                }
            }
        }
    };
    if (useLargeStackThread) {
        Thread th = new Thread(null, runnable, ""jscompiler"", COMPILER_STACK_SIZE);
        th.start();
        while (true) {
            try {
                th.join();
                break;
            } catch (InterruptedException ignore) {
                // ignore
            }
        }
    } else {
        runnable.run();
    }
    // Pass on any exception caught by the runnable object.
    if (exception[0] != null) {
        throw new RuntimeException(exception[0]);
    }
    return (T) result[0];
}","public void test05562() throws Throwable {
    Callable<AnalyzePrototypeProperties> callable0 = (Callable<AnalyzePrototypeProperties>) mock(Callable.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(callable0).call();
    AnalyzePrototypeProperties analyzePrototypeProperties0 = Compiler.runCallable(callable0, false, true);
    assertNull(analyzePrototypeProperties0);
}",""
"@SuppressWarnings(""unchecked"")
static <T> T runCallable(final Callable<T> callable, boolean useLargeStackThread, boolean trace) {
    // Under JRE 1.6, the jscompiler overflows the stack when running on some
    // large or complex js code. Here we start a new thread with a larger
    // stack in order to let the compiler do its thing, without having to
    // increase the stack size for *every* thread (which is what -Xss does).
    // Might want to add thread pool support for clients that compile a lot.
    final boolean dumpTraceReport = trace;
    final Object[] result = new Object[1];
    final Throwable[] exception = new Throwable[1];
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            try {
                if (dumpTraceReport) {
                    Tracer.initCurrentThreadTrace();
                }
                result[0] = callable.call();
            } catch (Throwable e) {
                exception[0] = e;
            } finally {
                if (dumpTraceReport) {
                    Tracer.logAndClearCurrentThreadTrace();
                }
            }
        }
    };
    if (useLargeStackThread) {
        Thread th = new Thread(null, runnable, ""jscompiler"", COMPILER_STACK_SIZE);
        th.start();
        while (true) {
            try {
                th.join();
                break;
            } catch (InterruptedException ignore) {
                // ignore
            }
        }
    } else {
        runnable.run();
    }
    // Pass on any exception caught by the runnable object.
    if (exception[0] != null) {
        throw new RuntimeException(exception[0]);
    }
    return (T) result[0];
}","public void test05663() throws Throwable {
    // Undeclared exception!
    try {
        Compiler.runCallable((Callable<AnalyzePrototypeProperties>) null, false, false);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.lang.NullPointerException
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test05764() throws Throwable {
    Compiler compiler0 = new Compiler();
    CleanupPasses cleanupPasses0 = new CleanupPasses((CompilerOptions) null);
    compiler0.setPassConfig(cleanupPasses0);
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"public void setPassConfig(PassConfig passes) {
    // Important to check for null because if setPassConfig(null) is
    // called before this.passes is set, getPassConfig() will create a
    // new PassConfig object and use that, which is probably not what
    // the client wanted since he or she probably meant to use their
    // own PassConfig object.
    Preconditions.checkNotNull(passes);
    if (this.passes != null) {
        throw new IllegalStateException(""this.passes has already been assigned"");
    }
    this.passes = passes;
}","public void test05865() throws Throwable {
    Compiler compiler0 = new Compiler();
    PassConfig passConfig0 = compiler0.getPassConfig();
    // Undeclared exception!
    try {
        compiler0.setPassConfig(passConfig0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // this.passes has already been assigned
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * @param passes The PassConfig to use with this Compiler.
 * @throws NullPointerException if passes is null
 * @throws IllegalStateException if this.passes has already been assigned
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test05966() throws Throwable {
    Compiler compiler0 = new Compiler();
    SourceFile sourceFile0 = SourceFile.fromFile(""\""(|N@HT5v6B*(m$qj"");
    Vector<SourceFile> vector0 = new Vector<SourceFile>();
    vector0.add(sourceFile0);
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    compiler0.compile((List<SourceFile>) vector0, (List<SourceFile>) vector0, compilerOptions0);
    compiler0.parseInputs();
    compiler0.check();
    assertEquals(0.25, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test06067() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Stack<SourceFile> stack0 = new Stack<SourceFile>();
    compiler0.compile((List<SourceFile>) stack0, (List<SourceFile>) stack0, compilerOptions0);
    assertEquals(1.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test06068() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Stack<SourceFile> stack0 = new Stack<SourceFile>();
    compiler0.compile((List<SourceFile>) stack0, (List<SourceFile>) stack0, compilerOptions0);
    compiler0.stripCode(compilerOptions0.stripTypePrefixes, compilerOptions0.stripNamePrefixes, compilerOptions0.stripNamePrefixes, compilerOptions0.stripNameSuffixes);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"//------------------------------------------------------------------------
// Optimizations
//------------------------------------------------------------------------
public void optimize() {
    // Ideally, this pass should be the first pass run, however:
    // 1) VariableReferenceCheck reports unexpected warnings if Normalize
    // is done first.
    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on
    // unmodified local names.
    normalize();
    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);
    if (options.devMode == DevMode.EVERY_PASS) {
        phaseOptimizer.setSanityCheck(sanityCheck);
    }
    phaseOptimizer.consume(getPassConfig().getOptimizations());
    phaseOptimizer.process(externsRoot, jsRoot);
    if (hasErrors()) {
        return;
    }
}","public void test06169() throws Throwable {
    Compiler compiler0 = new Compiler();
    Vector<SourceFile> vector0 = new Vector<SourceFile>();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    ArrayList<JSModule> arrayList0 = new ArrayList<JSModule>();
    compiler0.compileModules((List<SourceFile>) vector0, (List<JSModule>) arrayList0, compilerOptions0);
    compiler0.startPass(""Dp4}"");
    // Undeclared exception!
    try {
        compiler0.optimize();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"void endPass() {
    Preconditions.checkState(currentTracer != null, ""Tracer should not be null at the end of a pass."");
    stopTracer(currentTracer, currentPassName);
    String passToCheck = currentPassName;
    currentPassName = null;
    currentTracer = null;
    maybeSanityCheck();
}","public void test06270() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.endPass();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Tracer should not be null at the end of a pass.
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Marks the end of a pass.
 */"
"void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes, Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {
    logger.fine(""Strip code"");
    startPass(""stripCode"");
    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes, stripTypePrefixes, stripNamePrefixes);
    if (options.getTweakProcessing().shouldStrip()) {
        r.enableTweakStripping();
    }
    process(r);
    endPass();
}","public void test06371() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.reportCodeChange();
    // Undeclared exception!
    try {
        compiler0.stripCode(compilerOptions0.stripTypes, compilerOptions0.stripNamePrefixes, compilerOptions0.stripNameSuffixes, compilerOptions0.stripNamePrefixes);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Strips code for smaller compiled code. This is useful for removing debug
 * statements to prevent leaking them publicly.
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test06472() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""JSC_OPTIMIZE_LOOP_ERROR"");
    compiler0.areNodesEqualForInlining(node0, node0);
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test06473() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""JSC_OPTIMIZE_LOOP_ERROR"");
    compiler0.areNodesEqualForInlining(node0, node0);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"protected void removeExternInput(InputId id) {
    CompilerInput input = getInput(id);
    if (input == null) {
        return;
    }
    Preconditions.checkState(input.isExtern(), ""Not an extern input: %s"", input.getName());
    inputsById.remove(id);
    externs.remove(input);
    Node root = input.getAstRoot(this);
    if (root != null) {
        root.detachFromParent();
    }
}","public void test06574() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""gq*rw<"");
    InputId inputId0 = node0.getInputId();
    // Undeclared exception!
    try {
        compiler0.removeExternInput(inputId0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Not an extern input: [testcode]
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Removes an input file from AST.
 * @param id The id of the input to be removed.
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test06675() throws Throwable {
    Compiler compiler0 = new Compiler();
    ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
    assertEquals(1.0, compiler0.getProgress(), 0.01);
}",""
"public boolean isExtern() {
    if (ast == null || ast.getSourceFile() == null) {
        return false;
    }
    return ast.getSourceFile().isExtern();
}","public void test06676() throws Throwable {
    Compiler compiler0 = new Compiler();
    ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
    compiler0.getSynthesizedExternsInput();
    CompilerInput compilerInput0 = compiler0.getSynthesizedExternsInput();
    assertTrue(compilerInput0.isExtern());
}",""
"void addIncrementalSourceAst(JsAst ast) {
    InputId id = ast.getInputId();
    Preconditions.checkState(getInput(id) == null, ""Duplicate input %s"", id.getIdName());
    putCompilerInput(id, new CompilerInput(ast));
}","public void test06777() throws Throwable {
    Compiler compiler0 = new Compiler();
    File file0 = MockFile.createTempFile(""yG0aF>#M}rSP y"", ""yG0aF>#M}rSP y"");
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[3];
    SourceFile.Generator sourceFile_Generator0 = mock(SourceFile.Generator.class, new ViolatedAssumptionAnswer());
    JSSourceFile jSSourceFile0 = JSSourceFile.fromGenerator(""yG0aF>#M}rSP y"", sourceFile_Generator0);
    jSSourceFileArray0[0] = jSSourceFile0;
    jSSourceFileArray0[1] = jSSourceFile0;
    Charset charset0 = Charset.defaultCharset();
    JSSourceFile jSSourceFile1 = JSSourceFile.fromFile(file0, charset0);
    jSSourceFileArray0[2] = jSSourceFile1;
    JSModule[] jSModuleArray0 = new JSModule[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSModuleArray0, compilerOptions0);
    SourceFile sourceFile0 = SourceFile.fromFile(file0, charset0);
    JsAst jsAst0 = new JsAst(sourceFile0);
    // Undeclared exception!
    try {
        compiler0.addIncrementalSourceAst(jsAst0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Duplicate input /var/folders/vv/c7q6vm8920vc7d5p_87011w40000gn/T/yG0aF>#M}rSP y0yG0aF>#M}rSP y
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Add a source input dynamically. Intended for incremental compilation.
 */"
"public void addNewScript(JsAst ast) {
    if (!addNewSourceAst(ast)) {
        return;
    }
    Node emptyScript = new Node(Token.SCRIPT);
    InputId inputId = ast.getInputId();
    emptyScript.setInputId(inputId);
    emptyScript.setStaticSourceFile(SourceFile.fromCode(inputId.getIdName(), """"));
    processNewScript(ast, emptyScript);
}","public void test06878() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""ye=Tg(?A|a\""?3!9"");
    File file0 = MockFile.createTempFile(""ye=Tg(?A|a\""?3!9"", ""ye=Tg(?A|a\""?3!9"");
    Charset charset0 = Charset.defaultCharset();
    SourceFile sourceFile0 = SourceFile.fromFile(file0, charset0);
    JsAst jsAst0 = new JsAst(sourceFile0);
    compiler0.addIncrementalSourceAst(jsAst0);
    // Undeclared exception!
    try {
        compiler0.addNewScript(jsAst0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Input already exists: /var/folders/vv/c7q6vm8920vc7d5p_87011w40000gn/T/ye=Tg(?A|a\""?3!90ye=Tg(?A|a\""?3!9
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Adds a new Script AST to the compile state. If a script for the same file
 * already exists the script will not be added, instead a call to
 * #replaceScript should be used.
 *
 * @param ast the ast of the new file
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test06979() throws Throwable {
    Compiler compiler0 = new Compiler();
    ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
    Charset charset0 = Charset.defaultCharset();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""com.google.javascript.jscomp.Compiler$2"", charset0);
    JsAst jsAst0 = new JsAst(jSSourceFile0);
    compiler0.addNewScript(jsAst0);
    JsAst jsAst1 = new JsAst(jSSourceFile0);
    compiler0.replaceScript(jsAst1);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"JSModuleGraph getDegenerateModuleGraph() {
    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;
}","public void test07080() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getDegenerateModuleGraph();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.JSModuleGraph"", e);
    }
}","/**
 * Gets a module graph. This will always return a module graph, even
 * in the degenerate case when there's only one module.
 */"
"public String getSourceFileName() {
    StaticSourceFile file = getStaticSourceFile();
    return file == null ? null : file.getName();
}","public void test07181() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("")/?cz%S:D+^?uv"", "")/?cz%S:D+^?uv"");
    assertEquals("")/?cz%S:D+^?uv"", node0.getSourceFileName());
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test07182() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("")/?cz%S:D+^?uv"", "")/?cz%S:D+^?uv"");
    compiler0.getReverseAbstractInterpreter();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public ReverseAbstractInterpreter getReverseAbstractInterpreter() {
    if (abstractInterpreter == null) {
        ChainableReverseAbstractInterpreter interpreter = new SemanticReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry());
        if (options.closurePass) {
            interpreter = new ClosureReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry()).append(interpreter).getFirst();
        }
        abstractInterpreter = interpreter;
    }
    return abstractInterpreter;
}","public void test07183() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("")/?cz%S:D+^?uv"", "")/?cz%S:D+^?uv"");
    compiler0.getReverseAbstractInterpreter();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    assertNotNull(reverseAbstractInterpreter0);
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test07184() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("")/?cz%S:D+^?uv"", "")/?cz%S:D+^?uv"");
    compiler0.getReverseAbstractInterpreter();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test07185() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("")/?cz%S:D+^?uv"", "")/?cz%S:D+^?uv"");
    compiler0.getReverseAbstractInterpreter();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"@Override
TypeValidator getTypeValidator() {
    if (typeValidator == null) {
        typeValidator = new TypeValidator(this);
    }
    return typeValidator;
}","public void test07286() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getTypeValidator();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test07387() throws Throwable {
    Compiler compiler0 = new Compiler();
    LinkedList<SourceFile> linkedList0 = new LinkedList<SourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile((List<SourceFile>) linkedList0, (List<SourceFile>) linkedList0, compilerOptions0);
    compiler0.parseInputs();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test07488() throws Throwable {
    Compiler compiler0 = new Compiler();
    Vector<SourceFile> vector0 = new Vector<SourceFile>();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test07489() throws Throwable {
    Compiler compiler0 = new Compiler();
    Vector<SourceFile> vector0 = new Vector<SourceFile>();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    compiler0.compile((List<SourceFile>) vector0, (List<SourceFile>) vector0, compilerOptions0);
    compiler0.processAMDAndCommonJSModules();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test07590() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""q5"");
    compiler0.parseTestCode(""q5"");
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test07591() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""q5"");
    compiler0.parseTestCode(""q5"");
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test08096() throws Throwable {
    Compiler compiler0 = new Compiler();
    SourceFile sourceFile0 = SourceFile.fromFile(""\""(|N@HT5v6B*(m$qj"");
    Vector<SourceFile> vector0 = new Vector<SourceFile>();
    vector0.add(sourceFile0);
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    compiler0.compile((List<SourceFile>) vector0, (List<SourceFile>) vector0, compilerOptions0);
    compiler0.parseInputs();
    compiler0.optimize();
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test08197() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""u?/=="");
    boolean boolean0 = compiler0.isInliningForbidden();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test08198() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""u?/=="");
    boolean boolean0 = compiler0.isInliningForbidden();
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test08199() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""u?/=="");
    boolean boolean0 = compiler0.isInliningForbidden();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"boolean isInliningForbidden() {
    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC || options.propertyRenaming == PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;
}","public void test081100() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""u?/=="");
    boolean boolean0 = compiler0.isInliningForbidden();
    assertFalse(boolean0);
}",""
"@Override
public boolean acceptEcmaScript5() {
    switch(options.getLanguageIn()) {
        case ECMASCRIPT5:
        case ECMASCRIPT5_STRICT:
            return true;
    }
    return false;
}","public void test082102() throws Throwable {
    Compiler compiler0 = new Compiler();
    Vector<SourceFile> vector0 = new Vector<SourceFile>();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    compiler0.compile((List<SourceFile>) vector0, (List<SourceFile>) vector0, compilerOptions0);
    boolean boolean0 = compiler0.acceptEcmaScript5();
    assertFalse(boolean0);
}",""
"@Override
public Node getAstRoot(AbstractCompiler compiler) {
    if (root == null) {
        parse(compiler);
        root.setInputId(inputId);
    }
    return root;
}","public void test083103() throws Throwable {
    Compiler compiler0 = new Compiler();
    Charset charset0 = Charset.defaultCharset();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""msg.no.bracket.arg"", charset0);
    JsAst jsAst0 = new JsAst(jSSourceFile0);
    // Undeclared exception!
    try {
        jsAst0.getAstRoot(compiler0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test084104() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""k9YE}RV!ie:u;R\"""");
    Stack<NodeTraversal.Callback> stack0 = new Stack<NodeTraversal.Callback>();
    CombinedCompilerPass combinedCompilerPass0 = new CombinedCompilerPass(compiler0, stack0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, combinedCompilerPass0);
    CheckLevel checkLevel0 = CheckLevel.OFF;
    String[] stringArray0 = new String[2];
    JSError jSError0 = nodeTraversal0.makeError(node0, checkLevel0, compiler0.OPTIMIZE_LOOP_ERROR, stringArray0);
    compiler0.report(jSError0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test084105() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""k9YE}RV!ie:u;R\"""");
    Stack<NodeTraversal.Callback> stack0 = new Stack<NodeTraversal.Callback>();
    CombinedCompilerPass combinedCompilerPass0 = new CombinedCompilerPass(compiler0, stack0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, combinedCompilerPass0);
    CheckLevel checkLevel0 = CheckLevel.OFF;
    String[] stringArray0 = new String[2];
    JSError jSError0 = nodeTraversal0.makeError(node0, checkLevel0, compiler0.OPTIMIZE_LOOP_ERROR, stringArray0);
    compiler0.report(jSError0);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test084106() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""k9YE}RV!ie:u;R\"""");
    Stack<NodeTraversal.Callback> stack0 = new Stack<NodeTraversal.Callback>();
    CombinedCompilerPass combinedCompilerPass0 = new CombinedCompilerPass(compiler0, stack0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, combinedCompilerPass0);
    CheckLevel checkLevel0 = CheckLevel.OFF;
    String[] stringArray0 = new String[2];
    JSError jSError0 = nodeTraversal0.makeError(node0, checkLevel0, compiler0.OPTIMIZE_LOOP_ERROR, stringArray0);
    compiler0.report(jSError0);
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
void throwInternalError(String message, Exception cause) {
    String finalMessage = ""INTERNAL COMPILER ERROR.\n"" + ""Please report this problem.\n"" + message;
    RuntimeException e = new RuntimeException(finalMessage, cause);
    if (cause != null) {
        e.setStackTrace(cause.getStackTrace());
    }
    throw e;
}","public void test085107() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.throwInternalError(""JSC_DUPLICATE_EXTERN_INPUT"", (Exception) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // JSC_DUPLICATE_EXTERN_INPUT
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Report an internal error.
 */"
"public void check() {
    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);
    // We are currently only interested in check-passes for progress reporting
    // as it is used for IDEs, that's why the maximum progress is set to 1.0.
    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, new PhaseOptimizer.ProgressRange(getProgress(), 1.0));
    if (options.devMode == DevMode.EVERY_PASS) {
        phaseOptimizer.setSanityCheck(sanityCheck);
    }
    phaseOptimizer.consume(getPassConfig().getChecks());
    phaseOptimizer.process(externsRoot, jsRoot);
    if (hasErrors()) {
        return;
    }
    // TODO(nicksantos): clean this up. The flow here is too hard to follow.
    if (options.nameAnonymousFunctionsOnly) {
        return;
    }
    if (options.removeTryCatchFinally) {
        removeTryCatchFinally();
    }
    if (options.getTweakProcessing().shouldStrip() || !options.stripTypes.isEmpty() || !options.stripNameSuffixes.isEmpty() || !options.stripTypePrefixes.isEmpty() || !options.stripNamePrefixes.isEmpty()) {
        stripCode(options.stripTypes, options.stripNameSuffixes, options.stripTypePrefixes, options.stripNamePrefixes);
    }
    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);
}","public void test086108() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""computeCFG"");
    // Undeclared exception!
    try {
        compiler0.check();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test087110() throws Throwable {
    Compiler compiler0 = new Compiler();
    LinkedList<SourceFile> linkedList0 = new LinkedList<SourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setIdeMode(true);
    compiler0.compile((List<SourceFile>) linkedList0, (List<SourceFile>) linkedList0, compilerOptions0);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test088111() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getSourceLine((String) null, 30);
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test089112() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""I$Mkr9p qGlln"");
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[3];
    SourceFile.Generator sourceFile_Generator0 = mock(SourceFile.Generator.class, new ViolatedAssumptionAnswer());
    JSSourceFile jSSourceFile0 = JSSourceFile.fromGenerator(""yG0aF>#M}rSP y"", sourceFile_Generator0);
    jSSourceFileArray0[0] = jSSourceFile0;
    jSSourceFileArray0[1] = jSSourceFile0;
    jSSourceFileArray0[2] = jSSourceFileArray0[1];
    JSModule[] jSModuleArray0 = new JSModule[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSModuleArray0, compilerOptions0);
    assertEquals(3, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public <T1 extends SourceFile, T2 extends SourceFile> Result compile(List<T1> externs, List<T2> inputs, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        init(externs, inputs, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test090113() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""RT-"");
    CompilerOptions compilerOptions0 = compiler0.options;
    // Undeclared exception!
    try {
        compiler0.compile((List<SourceFile>) null, (List<SourceFile>) null, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Compiles a list of inputs.
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test091114() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getSourceRegion(""only arrays or objects can be accessed"", (-1));
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test092115() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""ye=Tg(?A|a\""?3!9"");
    compiler0.getSourceRegion(""externExports"", 37);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test092116() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""ye=Tg(?A|a\""?3!9"");
    compiler0.getSourceRegion(""externExports"", 37);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test092117() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""ye=Tg(?A|a\""?3!9"");
    compiler0.getSourceRegion(""externExports"", 37);
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test093118() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""y1e=Tg(?A|a\""?3!9"");
    Charset charset0 = Charset.defaultCharset();
    SourceFile sourceFile0 = SourceFile.fromFile("" a?C~,+xZNxDR96r"", charset0);
    JsAst jsAst0 = new JsAst(sourceFile0);
    compiler0.addIncrementalSourceAst(jsAst0);
    compiler0.getSourceRegion("" a?C~,+xZNxDR96r"", 29);
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test093119() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""y1e=Tg(?A|a\""?3!9"");
    Charset charset0 = Charset.defaultCharset();
    SourceFile sourceFile0 = SourceFile.fromFile("" a?C~,+xZNxDR96r"", charset0);
    JsAst jsAst0 = new JsAst(sourceFile0);
    compiler0.addIncrementalSourceAst(jsAst0);
    compiler0.getSourceRegion("" a?C~,+xZNxDR96r"", 29);
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test093120() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""y1e=Tg(?A|a\""?3!9"");
    Charset charset0 = Charset.defaultCharset();
    SourceFile sourceFile0 = SourceFile.fromFile("" a?C~,+xZNxDR96r"", charset0);
    JsAst jsAst0 = new JsAst(sourceFile0);
    compiler0.addIncrementalSourceAst(jsAst0);
    compiler0.getSourceRegion("" a?C~,+xZNxDR96r"", 29);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"//------------------------------------------------------------------------
// Package-private helpers
//------------------------------------------------------------------------
@Override
Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
        if (inputs.isEmpty()) {
            throw new IllegalStateException(""No inputs"");
        }
        return inputs.get(0).getAstRoot(this);
    }
    List<CompilerInput> moduleInputs = module.getInputs();
    if (moduleInputs.size() > 0) {
        return moduleInputs.get(0).getAstRoot(this);
    }
    throw new IllegalStateException(""Root module has no inputs"");
}","public void test094121() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSModule jSModule0 = new JSModule("".\""(jp%ACHm7%:3oY]"");
    // Undeclared exception!
    try {
        compiler0.getNodeForCodeInsertion(jSModule0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Root module has no inputs
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
Node ensureLibraryInjected(String resourceName) {
    if (injectedLibraries.containsKey(resourceName)) {
        return null;
    }
    // All libraries depend on js/base.js
    boolean isBase = ""base"".equals(resourceName);
    if (!isBase) {
        ensureLibraryInjected(""base"");
    }
    Node firstChild = loadLibraryCode(resourceName).removeChildren();
    Node lastChild = firstChild.getLastSibling();
    Node parent = getNodeForCodeInsertion(null);
    if (isBase) {
        parent.addChildrenToFront(firstChild);
    } else {
        parent.addChildrenAfter(firstChild, injectedLibraries.get(""base""));
    }
    reportCodeChange();
    injectedLibraries.put(resourceName, lastChild);
    return lastChild;
}","public void test095122() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""RnC"");
    // Undeclared exception!
    try {
        compiler0.ensureLibraryInjected(""RnC"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"//------------------------------------------------------------------------
// Package-private helpers
//------------------------------------------------------------------------
@Override
Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
        if (inputs.isEmpty()) {
            throw new IllegalStateException(""No inputs"");
        }
        return inputs.get(0).getAstRoot(this);
    }
    List<CompilerInput> moduleInputs = module.getInputs();
    if (moduleInputs.size() > 0) {
        return moduleInputs.get(0).getAstRoot(this);
    }
    throw new IllegalStateException(""Root module has no inputs"");
}","public void test096123() throws Throwable {
    Compiler compiler0 = new Compiler();
    LinkedList<SourceFile> linkedList0 = new LinkedList<SourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    LinkedList<JSModule> linkedList1 = new LinkedList<JSModule>();
    compiler0.compileModules((List<SourceFile>) linkedList0, (List<JSModule>) linkedList1, compilerOptions0);
    // Undeclared exception!
    try {
        compiler0.getNodeForCodeInsertion((JSModule) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // No inputs
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"//------------------------------------------------------------------------
// Package-private helpers
//------------------------------------------------------------------------
@Override
Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
        if (inputs.isEmpty()) {
            throw new IllegalStateException(""No inputs"");
        }
        return inputs.get(0).getAstRoot(this);
    }
    List<CompilerInput> moduleInputs = module.getInputs();
    if (moduleInputs.size() > 0) {
        return moduleInputs.get(0).getAstRoot(this);
    }
    throw new IllegalStateException(""Root module has no inputs"");
}","public void test097124() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSModule jSModule0 = new JSModule(""Km}F{qw=jI#5'G*L"");
    File file0 = MockFile.createTempFile(""Km}F{qw=jI#5'G*L"", ""recordFunctionInformation"");
    Charset charset0 = Charset.defaultCharset();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(file0, charset0);
    CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, true);
    jSModule0.addFirst(compilerInput0);
    // Undeclared exception!
    try {
        compiler0.getNodeForCodeInsertion(jSModule0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test098125() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getAstDotGraph();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"int getErrorCount();","public void test099126() throws Throwable {
    Compiler compiler0 = new Compiler();
    ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
    ErrorManager errorManager0 = compiler0.getErrorManager();
    assertEquals(0, errorManager0.getErrorCount());
}","/**
 * Gets the number of reported errors.
 */"
"@Override
public ErrorManager getErrorManager() {
    if (options == null) {
        initOptions(newCompilerOptions());
    }
    return errorManager;
}","public void test100127() throws Throwable {
    Compiler compiler0 = new Compiler();
    ErrorManager errorManager0 = compiler0.getErrorManager();
    assertNotNull(errorManager0);
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test100128() throws Throwable {
    Compiler compiler0 = new Compiler();
    ErrorManager errorManager0 = compiler0.getErrorManager();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test100129() throws Throwable {
    Compiler compiler0 = new Compiler();
    ErrorManager errorManager0 = compiler0.getErrorManager();
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch, Node collectionRoot) {
    Preconditions.checkState(collectionRoot.isScript() || collectionRoot.isBlock());
    if (globalRefMap == null) {
        globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(), getExternsInOrder());
    }
    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);
}","public void test101130() throws Throwable {
    Compiler compiler0 = new Compiler();
    HashMap<Scope.Var, ReferenceCollectingCallback.ReferenceCollection> hashMap0 = new HashMap<Scope.Var, ReferenceCollectingCallback.ReferenceCollection>();
    SyntheticAst syntheticAst0 = new SyntheticAst(""Tn'EF,tKqF)"");
    Node node0 = syntheticAst0.getAstRoot(compiler0);
    // Undeclared exception!
    try {
        compiler0.updateGlobalVarReferences(hashMap0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Collections$UnmodifiableCollection"", e);
    }
}",""
"@Override
void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch, Node collectionRoot) {
    Preconditions.checkState(collectionRoot.isScript() || collectionRoot.isBlock());
    if (globalRefMap == null) {
        globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(), getExternsInOrder());
    }
    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);
}","public void test102131() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) 32, 32, 32);
    // Undeclared exception!
    try {
        compiler0.updateGlobalVarReferences((Map<Scope.Var, ReferenceCollectingCallback.ReferenceCollection>) null, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test103133() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.setProgress(271.7341093);
    assertEquals(1.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public double getProgress() {
    return progress;
}","public void test104134() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.setProgress((-2.147483648E9));
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
