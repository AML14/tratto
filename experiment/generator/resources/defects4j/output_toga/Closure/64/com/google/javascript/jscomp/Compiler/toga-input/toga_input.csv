focal_method,test_prefix,docstring
"public Result compile(List<JSSourceFile> externs, List<JSSourceFile> inputs, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        init(externs, inputs, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test0000() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>();
    compiler0.compile((List<JSSourceFile>) arrayList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
    // Undeclared exception!
    try {
        compiler0.compile((List<JSSourceFile>) arrayList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Compiles a list of inputs.
 */"
"public String toSource(final JSModule module) {
    return runInCompilerThread(new Callable<String>() {

        public String call() throws Exception {
            List<CompilerInput> inputs = module.getInputs();
            int numInputs = inputs.size();
            if (numInputs == 0) {
                return """";
            }
            CodeBuilder cb = new CodeBuilder();
            for (int i = 0; i < numInputs; i++) {
                Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);
                if (scriptNode == null) {
                    throw new IllegalArgumentException(""Bad module: "" + module.getName());
                }
                toSource(cb, i, scriptNode);
            }
            return cb.toString();
        }
    });
}","public void test0011() throws Throwable {
    Compiler compiler0 = new Compiler((PrintStream) null);
    JSModule jSModule0 = new JSModule(""stripCode"");
    // Undeclared exception!
    try {
        compiler0.toSource(jSModule0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Converts the parse tree for a module back to js code.
 */"
"public String[] toSourceArray() {
    return runInCompilerThread(new Callable<String[]>() {

        public String[] call() throws Exception {
            Tracer tracer = newTracer(""toSourceArray"");
            try {
                int numInputs = inputs.size();
                String[] sources = new String[numInputs];
                CodeBuilder cb = new CodeBuilder();
                for (int i = 0; i < numInputs; i++) {
                    Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);
                    cb.reset();
                    toSource(cb, i, scriptNode);
                    sources[i] = cb.toString();
                }
                return sources;
            } finally {
                stopTracer(tracer, ""toSourceArray"");
            }
        }
    });
}","public void test0022() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.toSourceArray();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Converts the parse tree for each input back to js code.
 */"
"//------------------------------------------------------------------------
// Convert back to source code
//------------------------------------------------------------------------
/**
 * Converts the main parse tree back to js code.
 */
public String toSource() {
    return runInCompilerThread(new Callable<String>() {

        public String call() throws Exception {
            Tracer tracer = newTracer(""toSource"");
            try {
                CodeBuilder cb = new CodeBuilder();
                if (jsRoot != null) {
                    int i = 0;
                    for (Node scriptNode = jsRoot.getFirstChild(); scriptNode != null; scriptNode = scriptNode.getNext()) {
                        toSource(cb, i++, scriptNode);
                    }
                }
                return cb.toString();
            } finally {
                stopTracer(tracer, ""toSource"");
            }
        }
    });
}","public void test0033() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.toSource();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {
    runInCompilerThread(new Callable<Void>() {

        public Void call() throws Exception {
            if (options.printInputDelimiter) {
                if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
                    // Make sure that the label starts on a new line
                    cb.append(""\n"");
                }
                Preconditions.checkState(root.getType() == Token.SCRIPT);
                String delimiter = options.inputDelimiter;
                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);
                Preconditions.checkState(sourceName != null);
                Preconditions.checkState(!sourceName.isEmpty());
                delimiter = delimiter.replaceAll(""%name%"", sourceName).replaceAll(""%num%"", String.valueOf(inputSeqNum));
                cb.append(delimiter).append(""\n"");
            }
            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {
                cb.append(""/*\n"").append(root.getJSDocInfo().getLicense()).append(""*/\n"");
            }
            // If there is a valid source map, then indicate to it that the current
            // root node's mappings are offset by the given string builder buffer.
            if (options.sourceMapOutputPath != null) {
                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());
            }
            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
            // for the first input file
            String code = toSource(root, sourceMap);
            if (!code.isEmpty()) {
                cb.append(code);
                // In order to avoid parse ambiguity when files are concatenated
                // together, all files should end in a semi-colon. Do a quick
                // heuristic check if there's an obvious semi-colon already there.
                int length = code.length();
                char lastChar = code.charAt(length - 1);
                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0';
                boolean hasSemiColon = lastChar == ';' || (lastChar == '\n' && secondLastChar == ';');
                if (!hasSemiColon) {
                    cb.append("";"");
                }
            }
            return null;
        }
    });
}","public void test0044() throws Throwable {
    Compiler compiler0 = new Compiler();
    Compiler.CodeBuilder compiler_CodeBuilder0 = new Compiler.CodeBuilder();
    // Undeclared exception!
    try {
        compiler0.toSource(compiler_CodeBuilder0, (-2192), (Node) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Writes out js code from a root node. If printing input delimiters, this
 * method will attach a comment to the start of the text indicating which
 * input the output derived from. If there were any preserve annotations
 * within the root's source, they will also be printed in a block comment
 * at the beginning of the output.
 */"
"public String[] toSourceArray(final JSModule module) {
    return runInCompilerThread(new Callable<String[]>() {

        public String[] call() throws Exception {
            List<CompilerInput> inputs = module.getInputs();
            int numInputs = inputs.size();
            if (numInputs == 0) {
                return new String[0];
            }
            String[] sources = new String[numInputs];
            CodeBuilder cb = new CodeBuilder();
            for (int i = 0; i < numInputs; i++) {
                Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);
                if (scriptNode == null) {
                    throw new IllegalArgumentException(""Bad module input: "" + inputs.get(i).getName());
                }
                cb.reset();
                toSource(cb, i, scriptNode);
                sources[i] = cb.toString();
            }
            return sources;
        }
    });
}","public void test0055() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.toSourceArray((JSModule) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Converts the parse tree for each input in a module back to js code.
 */"
"public void init(JSSourceFile[] externs, JSModule[] modules, CompilerOptions options) {
    initModules(Lists.<JSSourceFile>newArrayList(externs), Lists.<JSModule>newArrayList(modules), options);
}","public void test0066() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[7];
    JSModule[] jSModuleArray0 = new JSModule[0];
    // Undeclared exception!
    try {
        compiler0.init(jSSourceFileArray0, jSModuleArray0, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.JsAst"", e);
    }
}","/**
 * Initializes the instance state needed for a compile job if the sources
 * are in modules.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test0077() throws Throwable {
    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((PrintStream) null);
    Compiler compiler0 = new Compiler(printStreamErrorManager0);
    compiler0.resetUniqueNameId();
    assertEquals(0, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
CssRenamingMap getCssRenamingMap() {
    return options.cssRenamingMap;
}","public void test0099() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getCssRenamingMap();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
boolean hasRegExpGlobalReferences() {
    return hasRegExpGlobalReferences;
}","public void test01010() throws Throwable {
    Compiler compiler0 = new Compiler();
    boolean boolean0 = compiler0.hasRegExpGlobalReferences();
    assertTrue(boolean0);
}",""
"public void setState(IntermediateState state) {
    externsRoot = state.externsRoot;
    jsRoot = state.jsRoot;
    externs = state.externs;
    inputs = state.inputs;
    modules = state.modules;
    passes = createPassConfigInternal();
    getPassConfig().setIntermediateState(state.passConfigState);
    typeRegistry = state.typeRegistry;
    setLifeCycleStage(state.lifeCycleStage);
}","public void test01111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Compiler.IntermediateState compiler_IntermediateState0 = compiler0.getState();
    compiler0.setState(compiler_IntermediateState0);
}","/**
 * Sets the internal state to the capture given.  Note that this assumes that
 * the input files are already set up.
 */"
"CompilerOptions getOptions() {
    return options;
}","public void test01212() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = compiler0.getOptions();
    assertNull(compilerOptions0);
}",""
"public void rebuildInputsFromModules() {
    inputs = getAllInputsFromModules(modules);
    initInputsByNameMap();
}","public void test01313() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.rebuildInputsFromModules();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Rebuilds the internal list of inputs by iterating over all modules.
 * This is necessary if inputs have been added to or removed from a module
 * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.
 */"
"ControlFlowGraph<Node> computeCFG() {
    logger.info(""Computing Control Flow Graph"");
    Tracer tracer = newTracer(""computeCFG"");
    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);
    process(cfa);
    stopTracer(tracer, ""computeCFG"");
    return cfa.getCfg();
}","public void test01414() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.computeCFG();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Control Flow Analysis.
 */"
"VariableMap getPropertyMap() {
    return getPassConfig().getIntermediateState().propertyMap;
}","public void test01515() throws Throwable {
    Compiler compiler0 = new Compiler();
    VariableMap variableMap0 = compiler0.getPropertyMap();
    assertNull(variableMap0);
}",""
"@Override
ScopeCreator getTypedScopeCreator() {
    return getPassConfig().getTypedScopeCreator();
}","public void test01616() throws Throwable {
    Compiler compiler0 = new Compiler();
    ScopeCreator scopeCreator0 = compiler0.getTypedScopeCreator();
    assertNull(scopeCreator0);
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test01717() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""// Input %num%"");
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.parseInputs();
    compiler0.check();
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
Node parseSyntheticCode(String js) {
    CompilerInput input = new CompilerInput(JSSourceFile.fromCode("" [synthetic] "", js));
    inputsByName.put(input.getName(), input);
    return input.getAstRoot(this);
}","public void test01818() throws Throwable {
    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((PrintStream) null);
    Compiler compiler0 = new Compiler(printStreamErrorManager0);
    // Undeclared exception!
    try {
        compiler0.parseSyntheticCode((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public void processDefines() {
    (new DefaultPassConfig(options)).processDefines.create(this).process(externsRoot, jsRoot);
}","public void test01919() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.processDefines();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.DefaultPassConfig"", e);
    }
}","/**
 * Reprocesses the current defines over the AST.  This is used by GwtCompiler
 * to generate N outputs for different targets from the same (checked) AST.
 * For each target, we apply the target-specific defines by calling
 * {@code processDefines} and then {@code optimize} to optimize the AST
 * specifically for that target.
 */"
"static <T> T runCallableWithLargeStack(final Callable<T> callable) {
    return runCallable(callable, true, false);
}","public void test02020() throws Throwable {
    // Undeclared exception!
    try {
        Compiler.runCallableWithLargeStack((Callable<TightenTypes>) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.lang.NullPointerException
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public LanguageMode languageMode() {
    return options.getLanguageIn();
}","public void test02121() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.languageMode();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
void setCssRenamingMap(CssRenamingMap map) {
    options.cssRenamingMap = map;
}","public void test02222() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.setCssRenamingMap((CssRenamingMap) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test02323() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getWarningCount();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the number of warnings.
 */"
"VariableMap getVariableMap() {
    return getPassConfig().getIntermediateState().variableMap;
}","public void test02424() throws Throwable {
    Compiler compiler0 = new Compiler();
    VariableMap variableMap0 = compiler0.getVariableMap();
    assertNull(variableMap0);
}",""
"FunctionInformationMap getFunctionalInformationMap() {
    return functionInformationMap;
}","public void test02525() throws Throwable {
    Compiler compiler0 = new Compiler();
    FunctionInformationMap functionInformationMap0 = compiler0.getFunctionalInformationMap();
    assertNull(functionInformationMap0);
}",""
"@Override
Supplier<String> getUniqueNameIdSupplier() {
    final Compiler self = this;
    return new Supplier<String>() {

        public String get() {
            return String.valueOf(self.nextUniqueNameId());
        }
    };
}","public void test02626() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    assertNotNull(supplier0);
}",""
"void recordFunctionInformation() {
    logger.info(""Recording function information"");
    startPass(""recordFunctionInformation"");
    RecordFunctionInformation recordFunctionInfoPass = new RecordFunctionInformation(this, getPassConfig().getIntermediateState().functionNames);
    process(recordFunctionInfoPass);
    functionInformationMap = recordFunctionInfoPass.getMap();
    endPass();
}","public void test02727() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.recordFunctionInformation();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
String toSource(Node n) {
    initCompilerOptionsIfTesting();
    return toSource(n, null);
}","public void test02828() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.toSource((Node) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Cannot build without root node being specified
        //
        verifyException(""com.google.javascript.jscomp.CodePrinter$Builder"", e);
    }
}","/**
 * Generates JavaScript source code for an AST, doesn't generate source
 * map info.
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test02929() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""DWdf3"", ""DWdf3"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.ideMode = true;
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.optimize();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test02930() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""DWdf3"", ""DWdf3"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.ideMode = true;
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.optimize();
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public SourceMap getSourceMap() {
    return sourceMap;
}","public void test03031() throws Throwable {
    Compiler compiler0 = new Compiler();
    SourceMap sourceMap0 = compiler0.getSourceMap();
    assertNull(sourceMap0);
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test03132() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.isTypeCheckingEnabled();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public Node getRoot() {
    return externAndJsRoot;
}","public void test03233() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.getRoot();
    assertNull(node0);
}",""
"@VisibleForTesting
List<CompilerInput> getInputsForTesting() {
    return inputs;
}","public void test03334() throws Throwable {
    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((PrintStream) null);
    Compiler compiler0 = new Compiler(printStreamErrorManager0);
    List<CompilerInput> list0 = compiler0.getInputsForTesting();
    assertNull(list0);
}",""
"@Override
void removeChangeHandler(CodeChangeHandler handler) {
    codeChangeHandlers.remove(handler);
}","public void test03435() throws Throwable {
    Compiler compiler0 = new Compiler();
    CodeChangeHandler.ForbiddenChange codeChangeHandler_ForbiddenChange0 = new CodeChangeHandler.ForbiddenChange();
    compiler0.removeChangeHandler(codeChangeHandler_ForbiddenChange0);
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test03536() throws Throwable {
    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((PrintStream) null);
    Compiler compiler0 = new Compiler(printStreamErrorManager0);
    compiler0.setHasRegExpGlobalReferences(false);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public Result compile(JSSourceFile extern, JSModule[] modules, CompilerOptions options) {
    return compile(new JSSourceFile[] { extern }, modules, options);
}","public void test03637() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    // Undeclared exception!
    try {
        compiler0.compile((JSSourceFile) null, (JSModule[]) null, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"public JSError[] getMessages() {
    return getErrors();
}","public void test03738() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getMessages();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Returns an array constructed from errors + temporary warnings.
 */"
"@VisibleForTesting
List<CompilerInput> getExternsForTesting() {
    return externs;
}","public void test03839() throws Throwable {
    MockFile mockFile0 = new MockFile(""1f :5WD-yg@*Yk8"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    Compiler compiler0 = new Compiler(mockPrintStream0);
    List<CompilerInput> list0 = compiler0.getExternsForTesting();
    assertNull(list0);
}",""
"void removeTryCatchFinally() {
    logger.info(""Remove try/catch/finally"");
    startPass(""removeTryCatchFinally"");
    RemoveTryCatch r = new RemoveTryCatch(this);
    process(r);
    endPass();
}","public void test03940() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.removeTryCatchFinally();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Removes try/catch/finally statements for easier debugging.
 */"
"@Override
public Scope getTopScope() {
    return getPassConfig().getTopScope();
}","public void test04041() throws Throwable {
    Compiler compiler0 = new Compiler();
    Scope scope0 = compiler0.getTopScope();
    assertNull(scope0);
}",""
"@Override
void addToDebugLog(String str) {
    debugLog.append(str);
    debugLog.append('\n');
    logger.fine(str);
}","public void test04142() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.addToDebugLog(""?t-K@#<(?lUG"");
}","/**
 * Called from the compiler passes, adds debug info
 */"
"@Override
ReferenceMap getGlobalVarReferences() {
    return globalRefMap;
}","public void test04243() throws Throwable {
    Compiler compiler0 = new Compiler();
    ReferenceCollectingCallback.ReferenceMap referenceCollectingCallback_ReferenceMap0 = compiler0.getGlobalVarReferences();
    assertNull(referenceCollectingCallback_ReferenceMap0);
}",""
"//------------------------------------------------------------------------
// Parsing
//------------------------------------------------------------------------
/**
 * Parses the externs and main inputs.
 *
 * @return A synthetic root node whose two children are the externs root
 *     and the main root
 */
Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;
    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }
    // Parse main js sources.
    jsRoot = new Node(Token.BLOCK);
    jsRoot.setIsSyntheticBlock(true);
    externsRoot = new Node(Token.BLOCK);
    externsRoot.setIsSyntheticBlock(true);
    externAndJsRoot = new Node(Token.BLOCK, externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);
    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer == TracerMode.ALL);
        addChangeHandler(tracker.getCodeChangeHandler());
    }
    Tracer tracer = newTracer(""parseInputs"");
    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }
        // Check if the sources need to be re-ordered.
        if (options.manageClosureDependencies) {
            for (CompilerInput input : inputs) {
                input.setCompiler(this);
                // Forward-declare all the provided types, so that they
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }
            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.manageClosureDependenciesEntryPoints, inputs);
            } catch (CircularDependencyException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                return null;
            } catch (MissingProvideException e) {
                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));
                return null;
            }
        }
        // Check if inputs need to be rebuilt from modules.
        boolean staleInputs = false;
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            // Inputs can have a null AST during initial parse.
            if (n == null) {
                continue;
            }
            if (n.getJSDocInfo() != null) {
                JSDocInfo info = n.getJSDocInfo();
                if (info.isExterns()) {
                    // If the input file is explicitly marked as an externs file, then
                    // assume the programmer made a mistake and throw it into
                    // the externs pile anyways.
                    externsRoot.addChildToBack(n);
                    input.setIsExtern(true);
                    input.getModule().remove(input);
                    externs.add(input);
                    staleInputs = true;
                } else if (info.isNoCompile()) {
                    input.getModule().remove(input);
                    staleInputs = true;
                }
            }
        }
        if (staleInputs) {
            fillEmptyModules(modules);
            rebuildInputsFromModules();
        }
        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }
            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }
            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }
            jsRoot.addChildToBack(n);
        }
        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}","public void test04849() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""KLv{ih+iw>:|$A@"");
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    CompilerOptions compilerOptions0 = compiler0.options;
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    Node node0 = compiler0.parseInputs();
    assertNull(node0);
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test04850() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""KLv{ih+iw>:|$A@"");
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    CompilerOptions compilerOptions0 = compiler0.options;
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    Node node0 = compiler0.parseInputs();
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
        if (outStream == null) {
            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));
        } else {
            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);
            printer.setSummaryDetailLevel(options.summaryDetailLevel);
            setErrorManager(printer);
        }
    }
    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
        options.checkTypes = false;
    } else if (!options.checkTypes) {
        // If DiagnosticGroups did not override the plain checkTypes
        // option, and checkTypes is enabled, then turn off the
        // parser type warnings.
        options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);
    }
    if (options.checkGlobalThisLevel.isOn()) {
        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);
    }
    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());
    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);
    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }
    this.warningsGuard = composedGuards;
}","public void test04951() throws Throwable {
    MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("";{XKm^MP3)|n`KzC"");
    BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(mockFileOutputStream0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(bufferedOutputStream0);
    Compiler compiler0 = new Compiler(mockPrintStream0);
    // Undeclared exception!
    try {
        compiler0.initOptions((CompilerOptions) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Initialize the compiler options. Only necessary if you're not doing
 * a normal compile() job.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test05052() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""5"", ""5"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CheckLevel checkLevel0 = CheckLevel.ERROR;
    compilerOptions0.checkGlobalThisLevel = checkLevel0;
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public Result compile(JSSourceFile extern, JSSourceFile input, CompilerOptions options) {
    return compile(extern, new JSSourceFile[] { input }, options);
}","public void test05053() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""5"", ""5"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CheckLevel checkLevel0 = CheckLevel.ERROR;
    compilerOptions0.checkGlobalThisLevel = checkLevel0;
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    assertFalse(compilerOptions0.checkTypes);
}",""
"//------------------------------------------------------------------------
// Parsing
//------------------------------------------------------------------------
/**
 * Parses the externs and main inputs.
 *
 * @return A synthetic root node whose two children are the externs root
 *     and the main root
 */
Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;
    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
        externsRoot.detachChildren();
    }
    if (jsRoot != null) {
        jsRoot.detachChildren();
    }
    // Parse main js sources.
    jsRoot = new Node(Token.BLOCK);
    jsRoot.setIsSyntheticBlock(true);
    externsRoot = new Node(Token.BLOCK);
    externsRoot.setIsSyntheticBlock(true);
    externAndJsRoot = new Node(Token.BLOCK, externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);
    if (options.tracer.isOn()) {
        tracker = new PerformanceTracker(jsRoot, options.tracer == TracerMode.ALL);
        addChangeHandler(tracker.getCodeChangeHandler());
    }
    Tracer tracer = newTracer(""parseInputs"");
    try {
        // Parse externs sources.
        for (CompilerInput input : externs) {
            Node n = input.getAstRoot(this);
            if (hasErrors()) {
                return null;
            }
            externsRoot.addChildToBack(n);
        }
        // Check if the sources need to be re-ordered.
        if (options.manageClosureDependencies) {
            for (CompilerInput input : inputs) {
                input.setCompiler(this);
                // Forward-declare all the provided types, so that they
                // are not flagged even if they are dropped from the process.
                for (String provide : input.getProvides()) {
                    getTypeRegistry().forwardDeclareType(provide);
                }
            }
            try {
                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.manageClosureDependenciesEntryPoints, inputs);
            } catch (CircularDependencyException e) {
                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
                return null;
            } catch (MissingProvideException e) {
                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));
                return null;
            }
        }
        // Check if inputs need to be rebuilt from modules.
        boolean staleInputs = false;
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            // Inputs can have a null AST during initial parse.
            if (n == null) {
                continue;
            }
            if (n.getJSDocInfo() != null) {
                JSDocInfo info = n.getJSDocInfo();
                if (info.isExterns()) {
                    // If the input file is explicitly marked as an externs file, then
                    // assume the programmer made a mistake and throw it into
                    // the externs pile anyways.
                    externsRoot.addChildToBack(n);
                    input.setIsExtern(true);
                    input.getModule().remove(input);
                    externs.add(input);
                    staleInputs = true;
                } else if (info.isNoCompile()) {
                    input.getModule().remove(input);
                    staleInputs = true;
                }
            }
        }
        if (staleInputs) {
            fillEmptyModules(modules);
            rebuildInputsFromModules();
        }
        // Build the AST.
        for (CompilerInput input : inputs) {
            Node n = input.getAstRoot(this);
            if (n == null) {
                continue;
            }
            if (devMode) {
                runSanityCheck();
                if (hasErrors()) {
                    return null;
                }
            }
            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
                // Annotate the nodes in the tree with information from the
                // input file. This information is used to construct the SourceMap.
                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
                NodeTraversal.traverse(this, n, sia);
            }
            jsRoot.addChildToBack(n);
        }
        if (hasErrors()) {
            return null;
        }
        return externAndJsRoot;
    } finally {
        stopTracer(tracer, ""parseInputs"");
    }
}","public void test05154() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.sourceMapOutputPath = """";
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    Node node0 = compiler0.parseInputs();
    assertNotNull(node0);
}",""
"public boolean isSyntheticBlock() {
    return getBooleanProp(SYNTHETIC_BLOCK_PROP);
}","public void test05155() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.sourceMapOutputPath = """";
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    Node node0 = compiler0.parseInputs();
    assertTrue(node0.isSyntheticBlock());
}","/**
 * Returns whether this is a synthetic block that should not be considered
 * a real source block.
 */"
"public int getType() {
    return type;
}","public void test05156() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.sourceMapOutputPath = """";
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    Node node0 = compiler0.parseInputs();
    assertEquals(125, node0.getType());
}",""
"public void init(JSSourceFile[] externs, JSSourceFile[] inputs, CompilerOptions options) {
    init(Lists.<JSSourceFile>newArrayList(externs), Lists.<JSSourceFile>newArrayList(inputs), options);
}","public void test05257() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""p(LGM#\""#FgRE`M$K3G"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[5];
    jSSourceFileArray0[0] = jSSourceFile0;
    jSSourceFileArray0[1] = jSSourceFile0;
    jSSourceFileArray0[2] = jSSourceFile0;
    jSSourceFileArray0[3] = jSSourceFile0;
    jSSourceFileArray0[4] = jSSourceFile0;
    compiler0.init(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    assertFalse(compilerOptions0.checkTypes);
}","/**
 * Initializes the instance state needed for a compile job.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test05258() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""p(LGM#\""#FgRE`M$K3G"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[5];
    jSSourceFileArray0[0] = jSSourceFile0;
    jSSourceFileArray0[1] = jSSourceFile0;
    jSSourceFileArray0[2] = jSSourceFile0;
    jSSourceFileArray0[3] = jSSourceFile0;
    jSSourceFileArray0[4] = jSSourceFile0;
    compiler0.init(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public Result compileModules(List<JSSourceFile> externs, List<JSModule> modules, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        initModules(externs, modules, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test05359() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    Stack<JSModule> stack0 = new Stack<JSModule>();
    // Undeclared exception!
    try {
        compiler0.compileModules(vector0, stack0, compilerOptions0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Compiles a list of modules.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test05460() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    LinkedList<JSModule> linkedList0 = new LinkedList<JSModule>();
    LinkedList<JSSourceFile> linkedList1 = new LinkedList<JSSourceFile>();
    JSModule jSModule0 = new JSModule("""");
    linkedList0.offer(jSModule0);
    compiler0.compileModules(linkedList1, linkedList0, compilerOptions0);
    assertFalse(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public Result compileModules(List<JSSourceFile> externs, List<JSModule> modules, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        initModules(externs, modules, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test05461() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    LinkedList<JSModule> linkedList0 = new LinkedList<JSModule>();
    LinkedList<JSSourceFile> linkedList1 = new LinkedList<JSSourceFile>();
    JSModule jSModule0 = new JSModule("""");
    linkedList0.offer(jSModule0);
    compiler0.compileModules(linkedList1, linkedList0, compilerOptions0);
    assertFalse(compilerOptions0.checkTypes);
}","/**
 * Compiles a list of modules.
 */"
"void startPass(String passName) {
    Preconditions.checkState(currentTracer == null);
    currentPassName = passName;
    currentTracer = newTracer(passName);
}","public void test05562() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>();
    LinkedList<JSModule> linkedList0 = new LinkedList<JSModule>();
    compiler0.compileModules(arrayList0, linkedList0, compilerOptions0);
    compiler0.startPass((String) null);
    // Undeclared exception!
    try {
        compiler0.startPass((String) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Marks the beginning of a pass.
 */"
"@SuppressWarnings(""unchecked"")
static <T> T runCallable(final Callable<T> callable, boolean useLargeStackThread, boolean trace) {
    // Under JRE 1.6, the jscompiler overflows the stack when running on some
    // large or complex js code. Here we start a new thread with a larger
    // stack in order to let the compiler do its thing, without having to
    // increase the stack size for *every* thread (which is what -Xss does).
    // Might want to add thread pool support for clients that compile a lot.
    final boolean dumpTraceReport = trace;
    final Object[] result = new Object[1];
    final Throwable[] exception = new Throwable[1];
    Runnable runnable = new Runnable() {

        public void run() {
            try {
                if (dumpTraceReport) {
                    Tracer.initCurrentThreadTrace();
                }
                result[0] = callable.call();
            } catch (Throwable e) {
                exception[0] = e;
            } finally {
                if (dumpTraceReport) {
                    Tracer.logAndClearCurrentThreadTrace();
                }
            }
        }
    };
    if (useLargeStackThread) {
        Thread th = new Thread(null, runnable, ""jscompiler"", COMPILER_STACK_SIZE);
        th.start();
        while (true) {
            try {
                th.join();
                break;
            } catch (InterruptedException ignore) {
                // ignore
            }
        }
    } else {
        runnable.run();
    }
    // Pass on any exception caught by the runnable object.
    if (exception[0] != null) {
        throw new RuntimeException(exception[0]);
    }
    return (T) result[0];
}","public void test05663() throws Throwable {
    Compiler compiler0 = new Compiler();
    OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
    Callable<OptimizeArgumentsArray> callable0 = (Callable<OptimizeArgumentsArray>) mock(Callable.class, new ViolatedAssumptionAnswer());
    doReturn(optimizeArgumentsArray0).when(callable0).call();
    OptimizeArgumentsArray optimizeArgumentsArray1 = Compiler.runCallable(callable0, false, true);
    assertSame(optimizeArgumentsArray1, optimizeArgumentsArray0);
}",""
"@SuppressWarnings(""unchecked"")
static <T> T runCallable(final Callable<T> callable, boolean useLargeStackThread, boolean trace) {
    // Under JRE 1.6, the jscompiler overflows the stack when running on some
    // large or complex js code. Here we start a new thread with a larger
    // stack in order to let the compiler do its thing, without having to
    // increase the stack size for *every* thread (which is what -Xss does).
    // Might want to add thread pool support for clients that compile a lot.
    final boolean dumpTraceReport = trace;
    final Object[] result = new Object[1];
    final Throwable[] exception = new Throwable[1];
    Runnable runnable = new Runnable() {

        public void run() {
            try {
                if (dumpTraceReport) {
                    Tracer.initCurrentThreadTrace();
                }
                result[0] = callable.call();
            } catch (Throwable e) {
                exception[0] = e;
            } finally {
                if (dumpTraceReport) {
                    Tracer.logAndClearCurrentThreadTrace();
                }
            }
        }
    };
    if (useLargeStackThread) {
        Thread th = new Thread(null, runnable, ""jscompiler"", COMPILER_STACK_SIZE);
        th.start();
        while (true) {
            try {
                th.join();
                break;
            } catch (InterruptedException ignore) {
                // ignore
            }
        }
    } else {
        runnable.run();
    }
    // Pass on any exception caught by the runnable object.
    if (exception[0] != null) {
        throw new RuntimeException(exception[0]);
    }
    return (T) result[0];
}","public void test05764() throws Throwable {
    // Undeclared exception!
    try {
        Compiler.runCallable((Callable<OptimizeArgumentsArray>) null, false, false);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.lang.NullPointerException
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
static <T> T runCallable(final Callable<T> callable, boolean useLargeStackThread, boolean trace) {
    // Under JRE 1.6, the jscompiler overflows the stack when running on some
    // large or complex js code. Here we start a new thread with a larger
    // stack in order to let the compiler do its thing, without having to
    // increase the stack size for *every* thread (which is what -Xss does).
    // Might want to add thread pool support for clients that compile a lot.
    final boolean dumpTraceReport = trace;
    final Object[] result = new Object[1];
    final Throwable[] exception = new Throwable[1];
    Runnable runnable = new Runnable() {

        public void run() {
            try {
                if (dumpTraceReport) {
                    Tracer.initCurrentThreadTrace();
                }
                result[0] = callable.call();
            } catch (Throwable e) {
                exception[0] = e;
            } finally {
                if (dumpTraceReport) {
                    Tracer.logAndClearCurrentThreadTrace();
                }
            }
        }
    };
    if (useLargeStackThread) {
        Thread th = new Thread(null, runnable, ""jscompiler"", COMPILER_STACK_SIZE);
        th.start();
        while (true) {
            try {
                th.join();
                break;
            } catch (InterruptedException ignore) {
                // ignore
            }
        }
    } else {
        runnable.run();
    }
    // Pass on any exception caught by the runnable object.
    if (exception[0] != null) {
        throw new RuntimeException(exception[0]);
    }
    return (T) result[0];
}","public void test05865() throws Throwable {
    // Undeclared exception!
    try {
        Compiler.runCallable((Callable<OptimizeArgumentsArray>) null, false, true);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // java.lang.NullPointerException
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public void setPassConfig(PassConfig passes) {
    // Important to check for null because if setPassConfig(null) is
    // called before this.passes is set, getPassConfig() will create a
    // new PassConfig object and use that, which is probably not what
    // the client wanted since he or she probably meant to use their
    // own PassConfig object.
    Preconditions.checkNotNull(passes);
    if (this.passes != null) {
        throw new IllegalStateException(""this.passes has already been assigned"");
    }
    this.passes = passes;
}","public void test05966() throws Throwable {
    Compiler compiler0 = new Compiler();
    DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig((CompilerOptions) null);
    compiler0.setPassConfig(defaultPassConfig0);
}","/**
 * @param passes The PassConfig to use with this Compiler.
 * @throws NullPointerException if passes is null
 * @throws IllegalStateException if this.passes has already been assigned
 */"
"public void setPassConfig(PassConfig passes) {
    // Important to check for null because if setPassConfig(null) is
    // called before this.passes is set, getPassConfig() will create a
    // new PassConfig object and use that, which is probably not what
    // the client wanted since he or she probably meant to use their
    // own PassConfig object.
    Preconditions.checkNotNull(passes);
    if (this.passes != null) {
        throw new IllegalStateException(""this.passes has already been assigned"");
    }
    this.passes = passes;
}","public void test06067() throws Throwable {
    Compiler compiler0 = new Compiler();
    PassConfig passConfig0 = compiler0.getPassConfig();
    // Undeclared exception!
    try {
        compiler0.setPassConfig(passConfig0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // this.passes has already been assigned
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * @param passes The PassConfig to use with this Compiler.
 * @throws NullPointerException if passes is null
 * @throws IllegalStateException if this.passes has already been assigned
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test06168() throws Throwable {
    Compiler compiler0 = new Compiler();
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    assertFalse(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes, Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {
    logger.info(""Strip code"");
    startPass(""stripCode"");
    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes, stripTypePrefixes, stripNamePrefixes);
    if (options.getTweakProcessing().shouldStrip()) {
        r.enableTweakStripping();
    }
    process(r);
    endPass();
}","public void test06169() throws Throwable {
    Compiler compiler0 = new Compiler();
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    compiler0.stripCode(compilerOptions0.stripTypes, compilerOptions0.stripNamePrefixes, compilerOptions0.stripTypes, compilerOptions0.stripNameSuffixes);
    assertFalse(compilerOptions0.checkTypes);
}","/**
 * Strips code for smaller compiled code. This is useful for removing debug
 * statements to prevent leaking them publicly.
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test06170() throws Throwable {
    Compiler compiler0 = new Compiler();
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    compiler0.stripCode(compilerOptions0.stripTypes, compilerOptions0.stripNamePrefixes, compilerOptions0.stripTypes, compilerOptions0.stripNameSuffixes);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"void endPass() {
    Preconditions.checkState(currentTracer != null, ""Tracer should not be null at the end of a pass."");
    stopTracer(currentTracer, currentPassName);
    String passToCheck = currentPassName;
    currentPassName = null;
    currentTracer = null;
    maybeSanityCheck();
}","public void test06271() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.endPass();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Tracer should not be null at the end of a pass.
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Marks the end of a pass.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test06372() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""D"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    CompilerOptions.TracerMode compilerOptions_TracerMode0 = CompilerOptions.TracerMode.FAST;
    compilerOptions0.tracer = compilerOptions_TracerMode0;
    compiler0.parseInputs();
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test06473() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Can't negate non-numeric value: {0}"");
    compiler0.areNodesEqualForInlining(node0, node0);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"protected void removeInput(String name) {
    CompilerInput input = getInput(name);
    if (input == null) {
        return;
    }
    inputsByName.remove(name);
    Node root = input.getAstRoot(this);
    if (root != null) {
        root.detachFromParent();
    }
}","public void test06574() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""f#;"", ""f#;"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    // Undeclared exception!
    try {
        compiler0.removeInput(""f#;"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Removes an input file from AST.
 * @param name The name of the file to be removed.
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test06675() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""x0<D.~TXd;W"");
    compiler0.removeInput(""x0<D.~TXd;W"");
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test06776() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""f#;"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.removeInput(""f#;"");
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
public CompilerInput newExternInput(String name) {
    if (inputsByName.containsKey(name)) {
        throw new IllegalArgumentException(""Conflicting externs name: "" + name);
    }
    SourceAst ast = new SyntheticAst(name);
    CompilerInput input = new CompilerInput(ast, name, true);
    inputsByName.put(name, input);
    externsRoot.addChildToFront(ast.getAstRoot(this));
    return input;
}","public void test06877() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""x0<D./~TXd;W"");
    // Undeclared exception!
    try {
        compiler0.newExternInput(""x0<D./~TXd;W"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
public CompilerInput newExternInput(String name) {
    if (inputsByName.containsKey(name)) {
        throw new IllegalArgumentException(""Conflicting externs name: "" + name);
    }
    SourceAst ast = new SyntheticAst(name);
    CompilerInput input = new CompilerInput(ast, name, true);
    inputsByName.put(name, input);
    externsRoot.addChildToFront(ast.getAstRoot(this));
    return input;
}","public void test06978() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""Invalid token: "");
    // Undeclared exception!
    try {
        compiler0.newExternInput("" [testcode] "");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Conflicting externs name:  [testcode]
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"void addIncrementalSourceAst(JsAst ast) {
    String sourceName = ast.getSourceFile().getName();
    Preconditions.checkState(getInput(sourceName) == null, ""Duplicate input of name "" + sourceName);
    inputsByName.put(sourceName, new CompilerInput(ast));
}","public void test07079() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""p(LGM#\""#FgRE`M$K3G"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    JsAst jsAst0 = new JsAst(jSSourceFile0);
    // Undeclared exception!
    try {
        compiler0.addIncrementalSourceAst(jsAst0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Duplicate input of name p(LGM#\""#FgRE`M$K3G
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Add a source input dynamically. Intended for incremental compilation.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test07180() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""d8zVMy"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    SourceFile.Preloaded sourceFile_Preloaded0 = new SourceFile.Preloaded("" [synthetic] "", (String) null);
    JsAst jsAst0 = new JsAst(sourceFile_Preloaded0);
    compiler0.addIncrementalSourceAst(jsAst0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test07181() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""d8zVMy"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    SourceFile.Preloaded sourceFile_Preloaded0 = new SourceFile.Preloaded("" [synthetic] "", (String) null);
    JsAst jsAst0 = new JsAst(sourceFile_Preloaded0);
    compiler0.addIncrementalSourceAst(jsAst0);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test07282() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""// Input %num%"");
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    JsAst jsAst0 = new JsAst(jSSourceFile0);
    boolean boolean0 = compiler0.replaceIncrementalSourceAst(jsAst0);
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"boolean replaceIncrementalSourceAst(JsAst ast) {
    String sourceName = ast.getSourceFile().getName();
    CompilerInput oldInput = Preconditions.checkNotNull(getInput(sourceName), ""No input to replace: "" + sourceName);
    Node newRoot = ast.getAstRoot(this);
    if (newRoot == null) {
        return false;
    }
    Node oldRoot = oldInput.getAstRoot(this);
    if (oldRoot != null) {
        oldRoot.getParent().replaceChild(oldRoot, newRoot);
    } else {
        getRoot().getLastChild().addChildToBack(newRoot);
    }
    CompilerInput newInput = new CompilerInput(ast);
    inputsByName.put(sourceName, newInput);
    JSModule module = oldInput.getModule();
    if (module != null) {
        module.addAfter(newInput, oldInput);
        module.remove(oldInput);
    }
    return true;
}","public void test07283() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""// Input %num%"");
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    JsAst jsAst0 = new JsAst(jSSourceFile0);
    boolean boolean0 = compiler0.replaceIncrementalSourceAst(jsAst0);
    assertFalse(boolean0);
}","/**
 * Replace a source input dynamically. Intended for incremental
 * re-compilation.
 *
 * If the new source input doesn't parse, then keep the old input
 * in the AST and return false.
 *
 * @return Whether the new AST was attached successfully.
 */"
"boolean replaceIncrementalSourceAst(JsAst ast) {
    String sourceName = ast.getSourceFile().getName();
    CompilerInput oldInput = Preconditions.checkNotNull(getInput(sourceName), ""No input to replace: "" + sourceName);
    Node newRoot = ast.getAstRoot(this);
    if (newRoot == null) {
        return false;
    }
    Node oldRoot = oldInput.getAstRoot(this);
    if (oldRoot != null) {
        oldRoot.getParent().replaceChild(oldRoot, newRoot);
    } else {
        getRoot().getLastChild().addChildToBack(newRoot);
    }
    CompilerInput newInput = new CompilerInput(ast);
    inputsByName.put(sourceName, newInput);
    JSModule module = oldInput.getModule();
    if (module != null) {
        module.addAfter(newInput, oldInput);
        module.remove(oldInput);
    }
    return true;
}","public void test07384() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""DWdf3"", ""DWdf3"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.ideMode = true;
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    JsAst jsAst0 = new JsAst(jSSourceFile0);
    boolean boolean0 = compiler0.replaceIncrementalSourceAst(jsAst0);
    assertTrue(boolean0);
}","/**
 * Replace a source input dynamically. Intended for incremental
 * re-compilation.
 *
 * If the new source input doesn't parse, then keep the old input
 * in the AST and return false.
 *
 * @return Whether the new AST was attached successfully.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test07385() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""DWdf3"", ""DWdf3"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.ideMode = true;
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    JsAst jsAst0 = new JsAst(jSSourceFile0);
    boolean boolean0 = compiler0.replaceIncrementalSourceAst(jsAst0);
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test07486() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""J*dYUPT&tcqx"", ""com.google.javascript.jscomp.PeepholeFoldWithTypes"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    JSSourceFile jSSourceFile1 = JSSourceFile.fromInputStream(""$7"", (InputStream) sequenceInputStream0);
    compiler0.compile(jSSourceFile0, jSSourceFile1, compilerOptions0);
    JsAst jsAst0 = new JsAst(jSSourceFile1);
    compiler0.replaceIncrementalSourceAst(jsAst0);
    assertFalse(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"@Override
public ReverseAbstractInterpreter getReverseAbstractInterpreter() {
    if (abstractInterpreter == null) {
        ChainableReverseAbstractInterpreter interpreter = new SemanticReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry());
        if (options.closurePass) {
            interpreter = new ClosureReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry()).append(interpreter).getFirst();
        }
        abstractInterpreter = interpreter;
    }
    return abstractInterpreter;
}","public void test07587() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""Mmo$/E+*"");
    compiler0.getReverseAbstractInterpreter();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    assertNotNull(reverseAbstractInterpreter0);
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test07588() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""Mmo$/E+*"");
    compiler0.getReverseAbstractInterpreter();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test07689() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""p(LGM#\""#FgRE`M$K3G"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test07690() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""p(LGM#\""#FgRE`M$K3G"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test07791() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CompilerOptions.DevMode compilerOptions_DevMode0 = CompilerOptions.DevMode.START_AND_END;
    compilerOptions0.devMode = compilerOptions_DevMode0;
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""// Input %num%"");
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.parseInputs();
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public int getType() {
    return type;
}","public void test07892() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    Node node0 = compiler0.parseInputs();
    assertEquals(125, node0.getType());
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test07893() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    Node node0 = compiler0.parseInputs();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"public boolean isSyntheticBlock() {
    return getBooleanProp(SYNTHETIC_BLOCK_PROP);
}","public void test07894() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Vector<JSSourceFile> vector0 = new Vector<JSSourceFile>();
    compiler0.compile((List<JSSourceFile>) vector0, (List<JSSourceFile>) vector0, compilerOptions0);
    Node node0 = compiler0.parseInputs();
    assertTrue(node0.isSyntheticBlock());
}","/**
 * Returns whether this is a synthetic block that should not be considered
 * a real source block.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test07995() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""DWdf3"", ""DWdf3"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    CompilerOptions.TracerMode compilerOptions_TracerMode0 = CompilerOptions.TracerMode.ALL;
    compilerOptions0.tracer = compilerOptions_TracerMode0;
    compiler0.parseInputs();
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test07996() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""DWdf3"", ""DWdf3"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    CompilerOptions.TracerMode compilerOptions_TracerMode0 = CompilerOptions.TracerMode.ALL;
    compilerOptions0.tracer = compilerOptions_TracerMode0;
    compiler0.parseInputs();
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test07997() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""DWdf3"", ""DWdf3"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    CompilerOptions.TracerMode compilerOptions_TracerMode0 = CompilerOptions.TracerMode.ALL;
    compilerOptions0.tracer = compilerOptions_TracerMode0;
    compiler0.parseInputs();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test08098() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>();
    compiler0.compile((List<JSSourceFile>) arrayList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
    compiler0.parseTestCode(""H|D\""^(%5>3q-"");
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test085103() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""'joe[O([q5"", ""'joe[O([q5"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.parseInputs();
    compiler0.optimize();
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"boolean isInliningForbidden() {
    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC || options.propertyRenaming == PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;
}","public void test086104() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""6>%a$Ls>/r"");
    boolean boolean0 = compiler0.isInliningForbidden();
    assertFalse(boolean0);
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test086105() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""6>%a$Ls>/r"");
    boolean boolean0 = compiler0.isInliningForbidden();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"@Override
public void reportCodeChange() {
    for (CodeChangeHandler handler : codeChangeHandlers) {
        handler.reportChange();
    }
}","public void test087106() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.reportCodeChange();
}","/**
 * All passes should call reportCodeChange() when they alter
 * the JS tree structure. This is verified by CompilerTestCase.
 * This allows us to optimize to a fixed point.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test088107() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""f#;"", ""f#;"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    boolean boolean0 = compiler0.acceptEcmaScript5();
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
public boolean acceptEcmaScript5() {
    switch(options.getLanguageIn()) {
        case ECMASCRIPT5:
        case ECMASCRIPT5_STRICT:
            return true;
    }
    return false;
}","public void test088108() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""f#;"", ""f#;"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    boolean boolean0 = compiler0.acceptEcmaScript5();
    assertFalse(boolean0);
}",""
"public Result compile(List<JSSourceFile> externs, List<JSSourceFile> inputs, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        init(externs, inputs, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test089109() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.disableThreads();
    CompilerOptions.LanguageMode compilerOptions_LanguageMode0 = CompilerOptions.LanguageMode.ECMASCRIPT5;
    compilerOptions0.setLanguageIn(compilerOptions_LanguageMode0);
    ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>();
    Result result0 = compiler0.compile((List<JSSourceFile>) arrayList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
    assertTrue(result0.success);
}","/**
 * Compiles a list of inputs.
 */"
"@Override
public void report(JSError error) {
    CheckLevel level = error.level;
    if (warningsGuard != null) {
        CheckLevel newLevel = warningsGuard.level(error);
        if (newLevel != null) {
            level = newLevel;
        }
    }
    if (level.isOn()) {
        errorManager.report(level, error);
    }
}","public void test090110() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Compiler compiler0 = new Compiler();
    String[] stringArray0 = new String[1];
    JSError jSError0 = JSError.make((String) null, (-778), (-778), compilerOptions0.checkUnreachableCode, compiler0.MOTION_ITERATIONS_ERROR, stringArray0);
    compiler0.report(jSError0);
    assertEquals((-778), jSError0.lineNumber);
}",""
"@Override
void throwInternalError(String message, Exception cause) {
    String finalMessage = ""INTERNAL COMPILER ERROR.\n"" + ""Please report this problem.\n"" + message;
    RuntimeException e = new RuntimeException(finalMessage, cause);
    if (cause != null) {
        e.setStackTrace(cause.getStackTrace());
    }
    throw e;
}","public void test091111() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.throwInternalError(""JSC_EMPTY_MODULE_LIST_ERROR"", (Exception) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // JSC_EMPTY_MODULE_LIST_ERROR
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Report an internal error.
 */"
"public void check() {
    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);
    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);
    if (options.devMode == DevMode.EVERY_PASS) {
        phaseOptimizer.setSanityCheck(sanityCheck);
    }
    phaseOptimizer.consume(getPassConfig().getChecks());
    phaseOptimizer.process(externsRoot, jsRoot);
    if (hasErrors()) {
        return;
    }
    // TODO(nicksantos): clean this up. The flow here is too hard to follow.
    if (options.nameAnonymousFunctionsOnly) {
        return;
    }
    if (options.removeTryCatchFinally) {
        removeTryCatchFinally();
    }
    if (options.getTweakProcessing().shouldStrip() || !options.stripTypes.isEmpty() || !options.stripNameSuffixes.isEmpty() || !options.stripTypePrefixes.isEmpty() || !options.stripNamePrefixes.isEmpty()) {
        stripCode(options.stripTypes, options.stripNameSuffixes, options.stripTypePrefixes, options.stripNamePrefixes);
    }
    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);
}","public void test092112() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""// Input %num%"");
    // Undeclared exception!
    try {
        compiler0.check();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"public Region getSourceRegion(String sourceName, int lineNumber) {
    if (lineNumber < 1) {
        return null;
    }
    SourceFile input = getSourceFileByName(sourceName);
    if (input != null) {
        return input.getRegion(lineNumber);
    }
    return null;
}","public void test093113() throws Throwable {
    Compiler compiler0 = new Compiler();
    Region region0 = compiler0.getSourceRegion((String) null, (-1108));
    assertNull(region0);
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test094114() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""d8zVMy"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.getSourceRegion((String) null, 2148);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test095115() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""D"", ""D"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.getSourceRegion(""D"", 132);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test095116() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""D"", ""D"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.getSourceRegion(""D"", 132);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test095117() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""D"", ""D"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.getSourceRegion(""D"", 132);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"//------------------------------------------------------------------------
// Package-private helpers
//------------------------------------------------------------------------
@Override
Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
        if (inputs.isEmpty()) {
            throw new IllegalStateException(""No inputs"");
        }
        return inputs.get(0).getAstRoot(this);
    }
    List<CompilerInput> moduleInputs = module.getInputs();
    if (moduleInputs.size() > 0) {
        return moduleInputs.get(0).getAstRoot(this);
    }
    throw new IllegalStateException(""Root module has no inputs"");
}","public void test096118() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSModule jSModule0 = new JSModule(""!h8[tF![V[!{"");
    // Undeclared exception!
    try {
        compiler0.getNodeForCodeInsertion(jSModule0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Root module has no inputs
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test097119() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>();
    compiler0.compile((List<JSSourceFile>) arrayList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
    compiler0.getNodeForCodeInsertion((JSModule) null);
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"//------------------------------------------------------------------------
// Package-private helpers
//------------------------------------------------------------------------
@Override
Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
        if (inputs.isEmpty()) {
            throw new IllegalStateException(""No inputs"");
        }
        return inputs.get(0).getAstRoot(this);
    }
    List<CompilerInput> moduleInputs = module.getInputs();
    if (moduleInputs.size() > 0) {
        return moduleInputs.get(0).getAstRoot(this);
    }
    throw new IllegalStateException(""Root module has no inputs"");
}","public void test098120() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    LinkedList<JSModule> linkedList0 = new LinkedList<JSModule>();
    LinkedList<JSSourceFile> linkedList1 = new LinkedList<JSSourceFile>();
    compiler0.compileModules(linkedList1, linkedList0, compilerOptions0);
    // Undeclared exception!
    try {
        compiler0.getNodeForCodeInsertion((JSModule) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // No inputs
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"//------------------------------------------------------------------------
// Package-private helpers
//------------------------------------------------------------------------
@Override
Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
        if (inputs.isEmpty()) {
            throw new IllegalStateException(""No inputs"");
        }
        return inputs.get(0).getAstRoot(this);
    }
    List<CompilerInput> moduleInputs = module.getInputs();
    if (moduleInputs.size() > 0) {
        return moduleInputs.get(0).getAstRoot(this);
    }
    throw new IllegalStateException(""Root module has no inputs"");
}","public void test099121() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSModule jSModule0 = new JSModule(""@'`0Od|u.G9ftNKQ"");
    SourceFile.Generator sourceFile_Generator0 = mock(SourceFile.Generator.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(sourceFile_Generator0).getCode();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromGenerator(""@'`0Od|u.G9ftNKQ"", sourceFile_Generator0);
    jSModule0.addFirst(jSSourceFile0);
    // Undeclared exception!
    try {
        compiler0.getNodeForCodeInsertion(jSModule0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public String getAstDotGraph() throws IOException {
    if (jsRoot != null) {
        ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);
        cfa.process(null, jsRoot);
        return DotFormatter.toDot(jsRoot, cfa.getCfg());
    } else {
        return """";
    }
}","public void test100122() throws Throwable {
    Compiler compiler0 = new Compiler();
    String string0 = compiler0.getAstDotGraph();
    assertEquals("""", string0);
}","/**
 * Gets the DOT graph of the AST generated at the end of compilation.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test101123() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""f#;"", ""f#;"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.parseInputs();
    compiler0.getAstDotGraph();
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test102124() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""Can't negate non-numeric value: {0}"");
    compiler0.getErrorManager();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test103125() throws Throwable {
    Compiler compiler0 = new Compiler();
    ErrorManager errorManager0 = compiler0.getErrorManager();
    assertFalse(compiler0.isTypeCheckingEnabled());
}",""
"@Override
public ErrorManager getErrorManager() {
    if (options == null) {
        initOptions(new CompilerOptions());
    }
    return errorManager;
}","public void test103126() throws Throwable {
    Compiler compiler0 = new Compiler();
    ErrorManager errorManager0 = compiler0.getErrorManager();
    assertNotNull(errorManager0);
}",""
"@Override
void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch, Node collectionRoot) {
    Preconditions.checkState(collectionRoot.getType() == Token.SCRIPT || collectionRoot.getType() == Token.BLOCK);
    if (globalRefMap == null) {
        globalRefMap = new GlobalVarReferenceMap(getInputsInOrder());
    }
    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);
}","public void test104127() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""3"");
    HashMap<Scope.Var, ReferenceCollectingCallback.ReferenceCollection> hashMap0 = new HashMap<Scope.Var, ReferenceCollectingCallback.ReferenceCollection>();
    // Undeclared exception!
    try {
        compiler0.updateGlobalVarReferences(hashMap0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Collections$UnmodifiableCollection"", e);
    }
}",""
"@Override
void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch, Node collectionRoot) {
    Preconditions.checkState(collectionRoot.getType() == Token.SCRIPT || collectionRoot.getType() == Token.BLOCK);
    if (globalRefMap == null) {
        globalRefMap = new GlobalVarReferenceMap(getInputsInOrder());
    }
    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);
}","public void test105128() throws Throwable {
    Compiler compiler0 = new Compiler();
    HashMap<Scope.Var, ReferenceCollectingCallback.ReferenceCollection> hashMap0 = new HashMap<Scope.Var, ReferenceCollectingCallback.ReferenceCollection>();
    Node node0 = Node.newString(""GETPROP"");
    // Undeclared exception!
    try {
        compiler0.updateGlobalVarReferences(hashMap0, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch, Node collectionRoot) {
    Preconditions.checkState(collectionRoot.getType() == Token.SCRIPT || collectionRoot.getType() == Token.BLOCK);
    if (globalRefMap == null) {
        globalRefMap = new GlobalVarReferenceMap(getInputsInOrder());
    }
    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);
}","public void test106129() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""RE7V4W1:olT8;)VZH\"""");
    HashMap<Scope.Var, ReferenceCollectingCallback.ReferenceCollection> hashMap0 = new HashMap<Scope.Var, ReferenceCollectingCallback.ReferenceCollection>();
    // Undeclared exception!
    try {
        compiler0.updateGlobalVarReferences(hashMap0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Collections$UnmodifiableCollection"", e);
    }
}",""
