focal_method,test_prefix,docstring
"public boolean makesDicts() {
    if (!isConstructor()) {
        return false;
    }
    if (propAccess == PropAccess.DICT) {
        return true;
    }
    FunctionType superc = getSuperClassConstructor();
    if (superc != null && superc.makesDicts()) {
        setDict();
        return true;
    }
    return false;
}","public void test0000() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    errorFunctionType0.setDict();
    boolean boolean0 = errorFunctionType0.makesDicts();
    assertTrue(boolean0);
}","/**
 * When a class B inherits from A and A is annotated as a dict, then B
 * automatically gets the annotation, even if B's constructor is not
 * explicitly annotated.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test0001() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    errorFunctionType0.setDict();
    boolean boolean0 = errorFunctionType0.makesDicts();
    assertFalse(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test0002() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    errorFunctionType0.setDict();
    boolean boolean0 = errorFunctionType0.makesDicts();
    assertFalse(errorFunctionType0.isInterface());
}",""
"public boolean makesStructs() {
    if (!isConstructor()) {
        return false;
    }
    if (propAccess == PropAccess.STRUCT) {
        return true;
    }
    FunctionType superc = getSuperClassConstructor();
    if (superc != null && superc.makesStructs()) {
        setStruct();
        return true;
    }
    return false;
}","public void test0013() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.setStruct();
    boolean boolean0 = noResolvedType0.makesStructs();
    assertTrue(boolean0);
}","/**
 * When a class B inherits from A and A is annotated as a struct, then B
 * automatically gets the annotation, even if B's constructor is not
 * explicitly annotated.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test0014() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.setStruct();
    boolean boolean0 = noResolvedType0.makesStructs();
    assertFalse(noResolvedType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test0025() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(noResolvedType0, errorFunctionType0);
    modificationVisitor0.caseParameterizedType(parameterizedType0);
    assertFalse(errorFunctionType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test0026() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(noResolvedType0, errorFunctionType0);
    modificationVisitor0.caseParameterizedType(parameterizedType0);
    assertFalse(noResolvedType0.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test0037() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""bind"");
    FunctionType functionType0 = (FunctionType) errorFunctionType0.getPropertyType(""bind"");
    String string0 = functionType0.toStringHelper(false);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
String toStringHelper(boolean forAnnotations) {
    if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return ""Function"";
    }
    setPrettyPrint(false);
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType);
    if (hasKnownTypeOfThis) {
        if (isConstructor()) {
            b.append(""new:"");
        } else {
            b.append(""this:"");
        }
        b.append(typeOfThis.toStringHelper(forAnnotations));
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        appendArgString(b, p, forAnnotations);
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            appendArgString(b, p, forAnnotations);
            p = p.getNext();
        }
    }
    b.append(""): "");
    b.append(call.returnType.toStringHelper(forAnnotations));
    setPrettyPrint(true);
    return b.toString();
}","public void test0038() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""bind"");
    FunctionType functionType0 = (FunctionType) errorFunctionType0.getPropertyType(""bind"");
    String string0 = functionType0.toStringHelper(false);
    assertEquals(""function ((bind|null)=, *=, *=, *=): bind"", string0);
}","/**
 * Informally, a function is represented by
 * {@code function (params): returnType} where the {@code params} is a comma
 * separated list of types, the first one being a special
 * {@code this:T} if the function expects a known type for {@code this}.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test0049() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.hasEqualCallType(noResolvedType0);
    assertFalse(noResolvedType0.isInterface());
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test00510() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertTrue(functionType1.isOrdinaryFunction());
}",""
"FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {
    // NOTE(nicksantos): When we remove the unknown type, the function types
    // form a lattice with the universal constructor at the top of the lattice,
    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.
    //
    // When we introduce the unknown type, it's much more difficult to make
    // heads or tails of the partial ordering of types, because there's no
    // clear hierarchy between the different components (parameter types and
    // return types) in the ArrowType.
    //
    // Rather than make the situation more complicated by introducing new
    // types (like unions of functions), we just fallback on the simpler
    // approach of getting things right at the top and the bottom of the
    // lattice.
    //
    // If there are unknown parameters or return types making things
    // ambiguous, then sup(A, B) is always the top function type, and
    // inf(A, B) is always the bottom function type.
    Preconditions.checkNotNull(that);
    if (isEquivalentTo(that)) {
        return this;
    }
    // If these are ordinary functions, then merge them.
    // Don't do this if any of the params/return
    // values are unknown, because then there will be cycles in
    // their local lattice and they will merge in weird ways.
    if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) {
        // Check for the degenerate case, but double check
        // that there's not a cycle.
        boolean isSubtypeOfThat = this.isSubtype(that);
        boolean isSubtypeOfThis = that.isSubtype(this);
        if (isSubtypeOfThat && !isSubtypeOfThis) {
            return leastSuper ? that : this;
        } else if (isSubtypeOfThis && !isSubtypeOfThat) {
            return leastSuper ? this : that;
        }
        // Merge the two functions component-wise.
        FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);
        if (merged != null) {
            return merged;
        }
    }
    // The function instance type is a special case
    // that lives above the rest of the lattice.
    JSType functionInstance = registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
        return leastSuper ? that : this;
    } else if (functionInstance.isEquivalentTo(this)) {
        return leastSuper ? this : that;
    }
    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the
    // greatest function. In practice, we don't because it's way too
    // broad. The greatest function takes var_args None parameters, which
    // means that all parameters register a type warning.
    //
    // Instead, we use the U2U ctor type, which has unknown type args.
    FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
}","public void test00511() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertNotSame(functionType2, functionType1);
}","/**
 * Computes the supremum or infimum of two functions.
 * Because sup() and inf() share a lot of logic for functions, we use
 * a single helper.
 * @param leastSuper If true, compute the supremum of {@code this} with
 *     {@code that}. Otherwise, compute the infimum.
 * @return The least supertype or greatest subtype.
 */"
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test00512() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertFalse(functionType2.equals((Object) functionType1));
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test00513() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public boolean isReturnTypeInferred() {
    return call.returnTypeInferred;
}","public void test00514() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertFalse(functionType2.isReturnTypeInferred());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test00616() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) stringType0.autoboxesTo();
    JSType[] jSTypeArray0 = new JSType[5];
    jSTypeArray0[4] = (JSType) stringType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) instanceObjectType0, jSTypeArray0);
    functionType0.isReturnTypeInferred();
    assertTrue(instanceObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test00617() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) stringType0.autoboxesTo();
    JSType[] jSTypeArray0 = new JSType[5];
    jSTypeArray0[4] = (JSType) stringType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) instanceObjectType0, jSTypeArray0);
    functionType0.isReturnTypeInferred();
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test00618() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) stringType0.autoboxesTo();
    JSType[] jSTypeArray0 = new JSType[5];
    jSTypeArray0[4] = (JSType) stringType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) instanceObjectType0, jSTypeArray0);
    functionType0.isReturnTypeInferred();
    assertTrue(instanceObjectType0.hasCachedValues());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test00719() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    boolean boolean0 = errorFunctionType0.isInstanceType();
    assertFalse(errorFunctionType0.isInterface());
}",""
"@Override
public boolean isInstanceType() {
    // The universal constructor is its own instance, bizarrely.
    return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE));
}","public void test00720() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    boolean boolean0 = errorFunctionType0.isInstanceType();
    assertFalse(boolean0);
}",""
"@Override
public boolean canBeCalled() {
    return referencedType.canBeCalled();
}","public void test00821() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    boolean boolean0 = indexedType0.canBeCalled();
    assertTrue(boolean0);
}",""
"@Override
public boolean isInterface() {
    return referencedType.isInterface();
}","public void test00822() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    boolean boolean0 = indexedType0.canBeCalled();
    assertFalse(indexedType0.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test00923() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""\u06DD\u070F\u1680\u180E"", (Node) null);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType1 = functionType0.supAndInfHelper(noType0, false);
    boolean boolean0 = functionType1.isSubtype(functionType0);
    assertTrue(noType0.hasCachedValues());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    if (that.isFunctionType()) {
        FunctionType other = that.toMaybeFunctionType();
        if (other.isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        boolean treatThisTypesAsCovariant = // If either one of these is a ctor, skip 'this' checking.
        this.isConstructor() || other.isConstructor() || // An interface 'this'-type is non-restrictive.
        // In practical terms, if C implements I, and I has a method m,
        // then any m doesn't necessarily have to C#m's 'this'
        // type doesn't need to match I.
        (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || // If one of the 'this' types is covariant of the other,
        // then we'll treat them as covariant (see comment above).
        other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);
        return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test00924() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""\u06DD\u070F\u1680\u180E"", (Node) null);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType1 = functionType0.supAndInfHelper(noType0, false);
    boolean boolean0 = functionType1.isSubtype(functionType0);
    assertTrue(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test01025() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    noObjectType0.getExtendedInterfacesCount();
    assertFalse(noObjectType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test01126() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(noType0, noType0);
    assertFalse(functionType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test01227() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.getOwnImplementedInterfaces();
    assertFalse(noResolvedType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test01328() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoType noType0 = new NoType(jSTypeRegistry0);
    noType0.getSubTypes();
    assertFalse(noType0.isInterface());
}",""
"public FunctionType createConstructorType(String name, Node source, Node parameters, JSType returnType) {
    return new FunctionType(this, name, source, createArrowType(parameters, returnType), null, null, true, false);
}","public void test01429() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) noObjectType0, (JSType) noObjectType0, (JSType) noObjectType0, (JSType) noObjectType0);
    Node node0 = jSTypeRegistry0.createParameters((List<JSType>) immutableList0);
    // Undeclared exception!
    try {
        jSTypeRegistry0.createConstructorType(""Not declared as a constructor"", node0, node0, (JSType) noObjectType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates a constructor function type.
 * @param name the function's name or {@code null} to indicate that the
 *     function is anonymous.
 * @param source the node defining this function. Its type
 *     ({@link Node#getType()}) must be {@link Token#FUNCTION}.
 * @param parameters the function's parameters or {@code null}
 *     to indicate that the parameter types are unknown.
 * @param returnType the function's return type or {@code null} to indicate
 *     that the return type is unknown.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test01530() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""T8~oa`lyga#I_[-l\u0005"");
    Node node0 = Node.newNumber((double) 1);
    Node node1 = new Node(105, node0, node0, 36, 55);
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType(""Unknown class name"", node1, node0, (JSType) errorFunctionType0);
    assertFalse(functionType0.isInterface());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test01531() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""T8~oa`lyga#I_[-l\u0005"");
    Node node0 = Node.newNumber((double) 1);
    Node node1 = new Node(105, node0, node0, 36, 55);
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType(""Unknown class name"", node1, node0, (JSType) errorFunctionType0);
    assertTrue(functionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"public FunctionType createInterfaceType(String name, Node source) {
    return FunctionType.forInterface(this, name, source);
}","public void test01632() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newNumber((double) 0);
    // Undeclared exception!
    try {
        jSTypeRegistry0.createInterfaceType(""Not declared as a type name"", node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates an interface function type.
 * @param name the function's name
 * @param source the node defining this function. Its type
 *     ({@link Node#getType()}) must be {@link Token#FUNCTION}.
 */"
"static FunctionType forInterface(JSTypeRegistry registry, String name, Node source) {
    return new FunctionType(registry, name, source);
}","public void test01733() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    Node node0 = new Node(105, 105, 105);
    // Undeclared exception!
    try {
        FunctionType.forInterface(jSTypeRegistry0, (String) null, node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates an instance for a function that is an interface.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test01834() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.getBindReturnType(1);
    boolean boolean0 = functionType0.makesStructs();
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public boolean makesStructs() {
    if (!isConstructor()) {
        return false;
    }
    if (propAccess == PropAccess.STRUCT) {
        return true;
    }
    FunctionType superc = getSuperClassConstructor();
    if (superc != null && superc.makesStructs()) {
        setStruct();
        return true;
    }
    return false;
}","public void test01835() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.getBindReturnType(1);
    boolean boolean0 = functionType0.makesStructs();
    assertFalse(boolean0);
}","/**
 * When a class B inherits from A and A is annotated as a struct, then B
 * automatically gets the annotation, even if B's constructor is not
 * explicitly annotated.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test01936() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""jaz"");
    boolean boolean0 = errorFunctionType0.makesStructs();
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public boolean makesStructs() {
    if (!isConstructor()) {
        return false;
    }
    if (propAccess == PropAccess.STRUCT) {
        return true;
    }
    FunctionType superc = getSuperClassConstructor();
    if (superc != null && superc.makesStructs()) {
        setStruct();
        return true;
    }
    return false;
}","public void test01937() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""jaz"");
    boolean boolean0 = errorFunctionType0.makesStructs();
    assertFalse(boolean0);
}","/**
 * When a class B inherits from A and A is annotated as a struct, then B
 * automatically gets the annotation, even if B's constructor is not
 * explicitly annotated.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test02038() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, true);
    ArrowType arrowType0 = new ArrowType(jSTypeRegistry0, (Node) null, recordType0, true);
    ImmutableList<String> immutableList0 = ImmutableList.of(""com.googe.common.base.Predicates$1"", ""Named type with empty name component"", ""ef :rD"");
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, "",SbQzcT1f:31"", (Node) null, arrowType0, (ObjectType) null, immutableList0, false, false);
    boolean boolean0 = functionType0.makesDicts();
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public boolean makesDicts() {
    if (!isConstructor()) {
        return false;
    }
    if (propAccess == PropAccess.DICT) {
        return true;
    }
    FunctionType superc = getSuperClassConstructor();
    if (superc != null && superc.makesDicts()) {
        setDict();
        return true;
    }
    return false;
}","public void test02039() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, true);
    ArrowType arrowType0 = new ArrowType(jSTypeRegistry0, (Node) null, recordType0, true);
    ImmutableList<String> immutableList0 = ImmutableList.of(""com.googe.common.base.Predicates$1"", ""Named type with empty name component"", ""ef :rD"");
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, "",SbQzcT1f:31"", (Node) null, arrowType0, (ObjectType) null, immutableList0, false, false);
    boolean boolean0 = functionType0.makesDicts();
    assertFalse(boolean0);
}","/**
 * When a class B inherits from A and A is annotated as a dict, then B
 * automatically gets the annotation, even if B's constructor is not
 * explicitly annotated.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test02140() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ImmutableList<ObjectType> immutableList0 = ImmutableList.of((ObjectType) noResolvedType0);
    noResolvedType0.setImplementedInterfaces(immutableList0);
    boolean boolean0 = noResolvedType0.hasImplementedInterfaces();
    assertFalse(noResolvedType0.isInterface());
}",""
"public boolean hasImplementedInterfaces() {
    if (!implementedInterfaces.isEmpty()) {
        return true;
    }
    FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null;
    if (superCtor != null) {
        return superCtor.hasImplementedInterfaces();
    }
    return false;
}","public void test02141() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ImmutableList<ObjectType> immutableList0 = ImmutableList.of((ObjectType) noResolvedType0);
    noResolvedType0.setImplementedInterfaces(immutableList0);
    boolean boolean0 = noResolvedType0.hasImplementedInterfaces();
    assertTrue(boolean0);
}",""
"public boolean hasImplementedInterfaces() {
    if (!implementedInterfaces.isEmpty()) {
        return true;
    }
    FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null;
    if (superCtor != null) {
        return superCtor.hasImplementedInterfaces();
    }
    return false;
}","public void test02242() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a type name"", (Node) null);
    boolean boolean0 = functionType0.hasImplementedInterfaces();
    assertFalse(boolean0);
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test02243() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a type name"", (Node) null);
    boolean boolean0 = functionType0.hasImplementedInterfaces();
    assertTrue(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test02244() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a type name"", (Node) null);
    boolean boolean0 = functionType0.hasImplementedInterfaces();
    assertFalse(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test02345() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""<inRalid>"");
    boolean boolean0 = errorFunctionType0.hasImplementedInterfaces();
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public boolean hasImplementedInterfaces() {
    if (!implementedInterfaces.isEmpty()) {
        return true;
    }
    FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null;
    if (superCtor != null) {
        return superCtor.hasImplementedInterfaces();
    }
    return false;
}","public void test02346() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""<inRalid>"");
    boolean boolean0 = errorFunctionType0.hasImplementedInterfaces();
    assertFalse(boolean0);
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test02447() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    int int0 = errorFunctionType0.getMinArguments();
    assertFalse(errorFunctionType0.isInterface());
}",""
"public int getMinArguments() {
    // NOTE(nicksantos): There are some native functions that have optional
    // parameters before required parameters. This algorithm finds the position
    // of the last required parameter.
    int i = 0;
    int min = 0;
    for (Node n : getParameters()) {
        i++;
        if (!n.isOptionalArg() && !n.isVarArgs()) {
            min = i;
        }
    }
    return min;
}","public void test02448() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    int int0 = errorFunctionType0.getMinArguments();
    assertEquals(0, int0);
}","/**
 * Gets the minimum number of arguments that this function requires.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test02549() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""<inRalid>"");
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) errorFunctionType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) errorFunctionType0, (List<JSType>) immutableList0);
    int int0 = functionType0.getMinArguments();
    assertFalse(functionType0.isInterface());
}",""
"public int getMinArguments() {
    // NOTE(nicksantos): There are some native functions that have optional
    // parameters before required parameters. This algorithm finds the position
    // of the last required parameter.
    int i = 0;
    int min = 0;
    for (Node n : getParameters()) {
        i++;
        if (!n.isOptionalArg() && !n.isVarArgs()) {
            min = i;
        }
    }
    return min;
}","public void test02550() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""<inRalid>"");
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) errorFunctionType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) errorFunctionType0, (List<JSType>) immutableList0);
    int int0 = functionType0.getMinArguments();
    assertEquals(5, int0);
}","/**
 * Gets the minimum number of arguments that this function requires.
 */"
"public int getMinArguments() {
    // NOTE(nicksantos): There are some native functions that have optional
    // parameters before required parameters. This algorithm finds the position
    // of the last required parameter.
    int i = 0;
    int min = 0;
    for (Node n : getParameters()) {
        i++;
        if (!n.isOptionalArg() && !n.isVarArgs()) {
            min = i;
        }
    }
    return min;
}","public void test02651() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    int int0 = noResolvedType0.getMinArguments();
    assertEquals(0, int0);
}","/**
 * Gets the minimum number of arguments that this function requires.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test02652() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    int int0 = noResolvedType0.getMinArguments();
    assertFalse(noResolvedType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test02753() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    int int0 = noResolvedType0.getMaxArguments();
    assertFalse(noResolvedType0.isInterface());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test02754() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    int int0 = noResolvedType0.getMaxArguments();
    assertEquals(Integer.MAX_VALUE, int0);
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test02855() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseBooleanType();
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, jSTypeArray0);
    int int0 = functionType0.getMaxArguments();
    assertEquals(0, int0);
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test02856() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseBooleanType();
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, jSTypeArray0);
    int int0 = functionType0.getMaxArguments();
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test02957() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""c7q%Ww(q{jWk<kB"");
    int int0 = errorFunctionType0.getMaxArguments();
    assertEquals(3, int0);
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test02958() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""c7q%Ww(q{jWk<kB"");
    int int0 = errorFunctionType0.getMaxArguments();
    assertFalse(errorFunctionType0.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test03059() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""prototype"");
    errorFunctionType0.getPropertyType(""prototype"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test03160() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.makesDicts();
    noResolvedType0.getOwnPropertyNames();
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test03262() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    Set<String> set0 = noResolvedType0.getOwnPropertyNames();
    assertFalse(noResolvedType0.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test03363() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""{) 6?A[rZdD"");
    Node node0 = Node.newString(""Not declared as a constructor"");
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = errorFunctionType0.defineProperty(""prototype"", noResolvedType0, false, node0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) {
    if (""prototype"".equals(name)) {
        ObjectType objType = type.toObjectType();
        if (objType != null) {
            if (prototypeSlot != null && objType.isEquivalentTo(prototypeSlot.getType())) {
                return true;
            }
            this.setPrototypeBasedOn(objType, propertyNode);
            return true;
        } else {
            return false;
        }
    }
    return super.defineProperty(name, type, inferred, propertyNode);
}","public void test03364() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""{) 6?A[rZdD"");
    Node node0 = Node.newString(""Not declared as a constructor"");
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = errorFunctionType0.defineProperty(""prototype"", noResolvedType0, false, node0);
    assertTrue(boolean0);
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test03465() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a type name"", (Node) null);
    functionType0.setPrototypeBasedOn((ObjectType) indexedType0, (Node) null);
    assertTrue(functionType0.isInterface());
}",""
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test03466() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a type name"", (Node) null);
    functionType0.setPrototypeBasedOn((ObjectType) indexedType0, (Node) null);
    assertFalse(functionType0.isConstructor());
}",""
"boolean setPrototype(ObjectType prototype, Node propertyNode) {
    if (prototype == null) {
        return false;
    }
    // getInstanceType fails if the function is not a constructor
    if (isConstructor() && prototype == getInstanceType()) {
        return false;
    }
    return setPrototypeNoCheck(prototype, propertyNode);
}","public void test03567() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[1];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    boolean boolean0 = noResolvedType0.setPrototype((ObjectType) null, node0);
    assertFalse(boolean0);
}","/**
 * Sets the prototype.
 * @param prototype the prototype. If this value is {@code null} it will
 *        silently be discarded.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test03568() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[1];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    boolean boolean0 = noResolvedType0.setPrototype((ObjectType) null, node0);
    assertFalse(noResolvedType0.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test03669() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.cloneWithoutArrowType();
    assertFalse(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test03670() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.cloneWithoutArrowType();
    assertFalse(functionType0.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test03671() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.cloneWithoutArrowType();
    assertFalse(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test03772() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""{) 6?A[rZdD"");
    Node node0 = Node.newString(""Not declared as a constructor"");
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    errorFunctionType0.resolveInternal(simpleErrorReporter0, noResolvedType0);
    boolean boolean0 = errorFunctionType0.defineProperty(""prototype"", noResolvedType0, false, node0);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"@Override
boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) {
    if (""prototype"".equals(name)) {
        ObjectType objType = type.toObjectType();
        if (objType != null) {
            if (prototypeSlot != null && objType.isEquivalentTo(prototypeSlot.getType())) {
                return true;
            }
            this.setPrototypeBasedOn(objType, propertyNode);
            return true;
        } else {
            return false;
        }
    }
    return super.defineProperty(name, type, inferred, propertyNode);
}","public void test03773() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""{) 6?A[rZdD"");
    Node node0 = Node.newString(""Not declared as a constructor"");
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    errorFunctionType0.resolveInternal(simpleErrorReporter0, noResolvedType0);
    boolean boolean0 = errorFunctionType0.defineProperty(""prototype"", noResolvedType0, false, node0);
    assertTrue(boolean0);
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test03874() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    ImmutableList<ObjectType> immutableList0 = ImmutableList.of((ObjectType) noResolvedType0, (ObjectType) instanceObjectType0, (ObjectType) instanceObjectType0, (ObjectType) noResolvedType0);
    noResolvedType0.setImplementedInterfaces(immutableList0);
    noResolvedType0.getAllImplementedInterfaces();
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test03975() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""G}~ft9,r"", (Node) null);
    functionType0.getAllImplementedInterfaces();
    assertFalse(functionType0.hasCachedValues());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test03976() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""G}~ft9,r"", (Node) null);
    functionType0.getAllImplementedInterfaces();
    assertTrue(functionType0.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test04077() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""7 }FmY:i-Iix~1Q"");
    errorFunctionType0.getAllImplementedInterfaces();
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) {
    if (isConstructor()) {
        // Records this type for each implemented interface.
        for (ObjectType type : implementedInterfaces) {
            registry.registerTypeImplementingInterface(this, type);
        }
        this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces);
    } else {
        throw new UnsupportedOperationException();
    }
}","public void test04178() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.getBindReturnType(677);
    ImmutableList<ObjectType> immutableList0 = ImmutableList.of((ObjectType) noResolvedType0, (ObjectType) functionType0, (ObjectType) noResolvedType0, (ObjectType) noResolvedType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0);
    // Undeclared exception!
    try {
        functionType0.setImplementedInterfaces(immutableList0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.FunctionType"", e);
    }
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test04279() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.getAllExtendedInterfaces();
    assertFalse(noResolvedType0.isInterface());
}",""
"public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException {
    if (isInterface()) {
        this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces);
    } else {
        throw new UnsupportedOperationException();
    }
}","public void test04380() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    Vector<ObjectType> vector0 = new Vector<ObjectType>();
    try {
        noResolvedType0.setExtendedInterfaces(vector0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.FunctionType"", e);
    }
}",""
"public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException {
    if (isInterface()) {
        this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces);
    } else {
        throw new UnsupportedOperationException();
    }
}","public void test04481() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    // Undeclared exception!
    try {
        functionType0.setExtendedInterfaces((List<ObjectType>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.collect.ImmutableList"", e);
    }
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test04582() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""<inRalid>"");
    errorFunctionType0.defineProperty(""_`Y~<lc{"", errorFunctionType0, false, (Node) null);
    JSType jSType0 = errorFunctionType0.getPropertyType(""_`Y~<lc{"");
    assertFalse(errorFunctionType0.hasCachedValues());
}",""
"public boolean isInterface() {
    return false;
}","public void test04583() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""<inRalid>"");
    errorFunctionType0.defineProperty(""_`Y~<lc{"", errorFunctionType0, false, (Node) null);
    JSType jSType0 = errorFunctionType0.getPropertyType(""_`Y~<lc{"");
    assertFalse(jSType0.isInterface());
}","/**
 * Whether this type is a {@link FunctionType} that is an interface or a named
 * type that points to such a type.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test04684() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    errorFunctionType0.getPropertyType(""call"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test04785() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""apply"");
    errorFunctionType0.getPropertyType(""apply"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test04886() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.getBindReturnType((-1205374168));
    assertFalse(functionType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test04987() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    FunctionType functionType0 = errorFunctionType0.getBindReturnType(1685);
    assertFalse(functionType0.isInterface());
}",""
"@Override
boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) {
    if (""prototype"".equals(name)) {
        ObjectType objType = type.toObjectType();
        if (objType != null) {
            if (prototypeSlot != null && objType.isEquivalentTo(prototypeSlot.getType())) {
                return true;
            }
            this.setPrototypeBasedOn(objType, propertyNode);
            return true;
        } else {
            return false;
        }
    }
    return super.defineProperty(name, type, inferred, propertyNode);
}","public void test05088() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) numberType0, (Node) null);
    boolean boolean0 = functionType0.defineProperty(""prototype"", numberType0, true, (Node) null);
    assertFalse(boolean0);
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test05089() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) numberType0, (Node) null);
    boolean boolean0 = functionType0.defineProperty(""prototype"", numberType0, true, (Node) null);
    assertFalse(functionType0.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test05190() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.getBindReturnType(1);
    FunctionType functionType1 = functionType0.supAndInfHelper(noResolvedType0, false);
    functionType1.supAndInfHelper(functionType0, false);
    assertTrue(functionType0.hasCachedValues());
}",""
"FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {
    // NOTE(nicksantos): When we remove the unknown type, the function types
    // form a lattice with the universal constructor at the top of the lattice,
    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.
    //
    // When we introduce the unknown type, it's much more difficult to make
    // heads or tails of the partial ordering of types, because there's no
    // clear hierarchy between the different components (parameter types and
    // return types) in the ArrowType.
    //
    // Rather than make the situation more complicated by introducing new
    // types (like unions of functions), we just fallback on the simpler
    // approach of getting things right at the top and the bottom of the
    // lattice.
    //
    // If there are unknown parameters or return types making things
    // ambiguous, then sup(A, B) is always the top function type, and
    // inf(A, B) is always the bottom function type.
    Preconditions.checkNotNull(that);
    if (isEquivalentTo(that)) {
        return this;
    }
    // If these are ordinary functions, then merge them.
    // Don't do this if any of the params/return
    // values are unknown, because then there will be cycles in
    // their local lattice and they will merge in weird ways.
    if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) {
        // Check for the degenerate case, but double check
        // that there's not a cycle.
        boolean isSubtypeOfThat = this.isSubtype(that);
        boolean isSubtypeOfThis = that.isSubtype(this);
        if (isSubtypeOfThat && !isSubtypeOfThis) {
            return leastSuper ? that : this;
        } else if (isSubtypeOfThis && !isSubtypeOfThat) {
            return leastSuper ? this : that;
        }
        // Merge the two functions component-wise.
        FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);
        if (merged != null) {
            return merged;
        }
    }
    // The function instance type is a special case
    // that lives above the rest of the lattice.
    JSType functionInstance = registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
        return leastSuper ? that : this;
    } else if (functionInstance.isEquivalentTo(this)) {
        return leastSuper ? this : that;
    }
    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the
    // greatest function. In practice, we don't because it's way too
    // broad. The greatest function takes var_args None parameters, which
    // means that all parameters register a type warning.
    //
    // Instead, we use the U2U ctor type, which has unknown type args.
    FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
}","public void test05191() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.getBindReturnType(1);
    FunctionType functionType1 = functionType0.supAndInfHelper(noResolvedType0, false);
    functionType1.supAndInfHelper(functionType0, false);
    assertNotSame(functionType0, functionType1);
}","/**
 * Computes the supremum or infimum of two functions.
 * Because sup() and inf() share a lot of logic for functions, we use
 * a single helper.
 * @param leastSuper If true, compute the supremum of {@code this} with
 *     {@code that}. Otherwise, compute the infimum.
 * @return The least supertype or greatest subtype.
 */"
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test05292() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseVoidType();
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType0, jSType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (List<JSType>) immutableList0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
    FunctionType functionType1 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertTrue(functionType1.isOrdinaryFunction());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test05293() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseVoidType();
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType0, jSType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (List<JSType>) immutableList0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
    FunctionType functionType1 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertFalse(functionType2.equals((Object) functionType0));
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test05294() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseVoidType();
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType0, jSType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (List<JSType>) immutableList0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
    FunctionType functionType1 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {
    // NOTE(nicksantos): When we remove the unknown type, the function types
    // form a lattice with the universal constructor at the top of the lattice,
    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.
    //
    // When we introduce the unknown type, it's much more difficult to make
    // heads or tails of the partial ordering of types, because there's no
    // clear hierarchy between the different components (parameter types and
    // return types) in the ArrowType.
    //
    // Rather than make the situation more complicated by introducing new
    // types (like unions of functions), we just fallback on the simpler
    // approach of getting things right at the top and the bottom of the
    // lattice.
    //
    // If there are unknown parameters or return types making things
    // ambiguous, then sup(A, B) is always the top function type, and
    // inf(A, B) is always the bottom function type.
    Preconditions.checkNotNull(that);
    if (isEquivalentTo(that)) {
        return this;
    }
    // If these are ordinary functions, then merge them.
    // Don't do this if any of the params/return
    // values are unknown, because then there will be cycles in
    // their local lattice and they will merge in weird ways.
    if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) {
        // Check for the degenerate case, but double check
        // that there's not a cycle.
        boolean isSubtypeOfThat = this.isSubtype(that);
        boolean isSubtypeOfThis = that.isSubtype(this);
        if (isSubtypeOfThat && !isSubtypeOfThis) {
            return leastSuper ? that : this;
        } else if (isSubtypeOfThis && !isSubtypeOfThat) {
            return leastSuper ? this : that;
        }
        // Merge the two functions component-wise.
        FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);
        if (merged != null) {
            return merged;
        }
    }
    // The function instance type is a special case
    // that lives above the rest of the lattice.
    JSType functionInstance = registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
        return leastSuper ? that : this;
    } else if (functionInstance.isEquivalentTo(this)) {
        return leastSuper ? this : that;
    }
    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the
    // greatest function. In practice, we don't because it's way too
    // broad. The greatest function takes var_args None parameters, which
    // means that all parameters register a type warning.
    //
    // Instead, we use the U2U ctor type, which has unknown type args.
    FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
}","public void test05395() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry1.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, false);
    assertNotSame(functionType2, functionType1);
}","/**
 * Computes the supremum or infimum of two functions.
 * Because sup() and inf() share a lot of logic for functions, we use
 * a single helper.
 * @param leastSuper If true, compute the supremum of {@code this} with
 *     {@code that}. Otherwise, compute the infimum.
 * @return The least supertype or greatest subtype.
 */"
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test05396() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry1.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, false);
    assertTrue(functionType2.equals((Object) functionType1));
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test05497() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseVoidType();
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType0, jSType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (List<JSType>) immutableList0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType1 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertTrue(functionType1.isOrdinaryFunction());
}",""
"FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {
    // NOTE(nicksantos): When we remove the unknown type, the function types
    // form a lattice with the universal constructor at the top of the lattice,
    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.
    //
    // When we introduce the unknown type, it's much more difficult to make
    // heads or tails of the partial ordering of types, because there's no
    // clear hierarchy between the different components (parameter types and
    // return types) in the ArrowType.
    //
    // Rather than make the situation more complicated by introducing new
    // types (like unions of functions), we just fallback on the simpler
    // approach of getting things right at the top and the bottom of the
    // lattice.
    //
    // If there are unknown parameters or return types making things
    // ambiguous, then sup(A, B) is always the top function type, and
    // inf(A, B) is always the bottom function type.
    Preconditions.checkNotNull(that);
    if (isEquivalentTo(that)) {
        return this;
    }
    // If these are ordinary functions, then merge them.
    // Don't do this if any of the params/return
    // values are unknown, because then there will be cycles in
    // their local lattice and they will merge in weird ways.
    if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) {
        // Check for the degenerate case, but double check
        // that there's not a cycle.
        boolean isSubtypeOfThat = this.isSubtype(that);
        boolean isSubtypeOfThis = that.isSubtype(this);
        if (isSubtypeOfThat && !isSubtypeOfThis) {
            return leastSuper ? that : this;
        } else if (isSubtypeOfThis && !isSubtypeOfThat) {
            return leastSuper ? this : that;
        }
        // Merge the two functions component-wise.
        FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);
        if (merged != null) {
            return merged;
        }
    }
    // The function instance type is a special case
    // that lives above the rest of the lattice.
    JSType functionInstance = registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
        return leastSuper ? that : this;
    } else if (functionInstance.isEquivalentTo(this)) {
        return leastSuper ? this : that;
    }
    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the
    // greatest function. In practice, we don't because it's way too
    // broad. The greatest function takes var_args None parameters, which
    // means that all parameters register a type warning.
    //
    // Instead, we use the U2U ctor type, which has unknown type args.
    FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
}","public void test05498() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseVoidType();
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType0, jSType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (List<JSType>) immutableList0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType1 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertSame(functionType2, functionType0);
}","/**
 * Computes the supremum or infimum of two functions.
 * Because sup() and inf() share a lot of logic for functions, we use
 * a single helper.
 * @param leastSuper If true, compute the supremum of {@code this} with
 *     {@code that}. Otherwise, compute the infimum.
 * @return The least supertype or greatest subtype.
 */"
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test05599() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseVoidType();
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType0, jSType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (List<JSType>) immutableList0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType1 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, false);
    assertTrue(functionType2.isOrdinaryFunction());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test055100() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseVoidType();
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType0, jSType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (List<JSType>) immutableList0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType1 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, false);
    assertFalse(functionType2.equals((Object) functionType0));
}",""
"FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {
    // NOTE(nicksantos): When we remove the unknown type, the function types
    // form a lattice with the universal constructor at the top of the lattice,
    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.
    //
    // When we introduce the unknown type, it's much more difficult to make
    // heads or tails of the partial ordering of types, because there's no
    // clear hierarchy between the different components (parameter types and
    // return types) in the ArrowType.
    //
    // Rather than make the situation more complicated by introducing new
    // types (like unions of functions), we just fallback on the simpler
    // approach of getting things right at the top and the bottom of the
    // lattice.
    //
    // If there are unknown parameters or return types making things
    // ambiguous, then sup(A, B) is always the top function type, and
    // inf(A, B) is always the bottom function type.
    Preconditions.checkNotNull(that);
    if (isEquivalentTo(that)) {
        return this;
    }
    // If these are ordinary functions, then merge them.
    // Don't do this if any of the params/return
    // values are unknown, because then there will be cycles in
    // their local lattice and they will merge in weird ways.
    if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) {
        // Check for the degenerate case, but double check
        // that there's not a cycle.
        boolean isSubtypeOfThat = this.isSubtype(that);
        boolean isSubtypeOfThis = that.isSubtype(this);
        if (isSubtypeOfThat && !isSubtypeOfThis) {
            return leastSuper ? that : this;
        } else if (isSubtypeOfThis && !isSubtypeOfThat) {
            return leastSuper ? this : that;
        }
        // Merge the two functions component-wise.
        FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);
        if (merged != null) {
            return merged;
        }
    }
    // The function instance type is a special case
    // that lives above the rest of the lattice.
    JSType functionInstance = registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
        return leastSuper ? that : this;
    } else if (functionInstance.isEquivalentTo(this)) {
        return leastSuper ? this : that;
    }
    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the
    // greatest function. In practice, we don't because it's way too
    // broad. The greatest function takes var_args None parameters, which
    // means that all parameters register a type warning.
    //
    // Instead, we use the U2U ctor type, which has unknown type args.
    FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
}","public void test055101() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseVoidType();
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType0, jSType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (List<JSType>) immutableList0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType1 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, false);
    assertSame(functionType2, functionType1);
}","/**
 * Computes the supremum or infimum of two functions.
 * Because sup() and inf() share a lot of logic for functions, we use
 * a single helper.
 * @param leastSuper If true, compute the supremum of {@code this} with
 *     {@code that}. Otherwise, compute the infimum.
 * @return The least supertype or greatest subtype.
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test055102() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseVoidType();
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType0, jSType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType0, (List<JSType>) immutableList0);
    JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
    FunctionType functionType1 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, false);
    assertFalse(functionType2.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test056103() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) recordType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType0.supAndInfHelper(functionType1, false);
    assertTrue(recordType0.hasCachedValues());
}",""
"FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {
    // NOTE(nicksantos): When we remove the unknown type, the function types
    // form a lattice with the universal constructor at the top of the lattice,
    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.
    //
    // When we introduce the unknown type, it's much more difficult to make
    // heads or tails of the partial ordering of types, because there's no
    // clear hierarchy between the different components (parameter types and
    // return types) in the ArrowType.
    //
    // Rather than make the situation more complicated by introducing new
    // types (like unions of functions), we just fallback on the simpler
    // approach of getting things right at the top and the bottom of the
    // lattice.
    //
    // If there are unknown parameters or return types making things
    // ambiguous, then sup(A, B) is always the top function type, and
    // inf(A, B) is always the bottom function type.
    Preconditions.checkNotNull(that);
    if (isEquivalentTo(that)) {
        return this;
    }
    // If these are ordinary functions, then merge them.
    // Don't do this if any of the params/return
    // values are unknown, because then there will be cycles in
    // their local lattice and they will merge in weird ways.
    if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) {
        // Check for the degenerate case, but double check
        // that there's not a cycle.
        boolean isSubtypeOfThat = this.isSubtype(that);
        boolean isSubtypeOfThis = that.isSubtype(this);
        if (isSubtypeOfThat && !isSubtypeOfThis) {
            return leastSuper ? that : this;
        } else if (isSubtypeOfThis && !isSubtypeOfThat) {
            return leastSuper ? this : that;
        }
        // Merge the two functions component-wise.
        FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);
        if (merged != null) {
            return merged;
        }
    }
    // The function instance type is a special case
    // that lives above the rest of the lattice.
    JSType functionInstance = registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
        return leastSuper ? that : this;
    } else if (functionInstance.isEquivalentTo(this)) {
        return leastSuper ? this : that;
    }
    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the
    // greatest function. In practice, we don't because it's way too
    // broad. The greatest function takes var_args None parameters, which
    // means that all parameters register a type warning.
    //
    // Instead, we use the U2U ctor type, which has unknown type args.
    FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
}","public void test056104() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) recordType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType0.supAndInfHelper(functionType1, false);
    assertSame(functionType1, functionType2);
}","/**
 * Computes the supremum or infimum of two functions.
 * Because sup() and inf() share a lot of logic for functions, we use
 * a single helper.
 * @param leastSuper If true, compute the supremum of {@code this} with
 *     {@code that}. Otherwise, compute the infimum.
 * @return The least supertype or greatest subtype.
 */"
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test057105() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) recordType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType0.supAndInfHelper(functionType1, true);
    assertTrue(recordType0.hasCachedValues());
}",""
"FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {
    // NOTE(nicksantos): When we remove the unknown type, the function types
    // form a lattice with the universal constructor at the top of the lattice,
    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.
    //
    // When we introduce the unknown type, it's much more difficult to make
    // heads or tails of the partial ordering of types, because there's no
    // clear hierarchy between the different components (parameter types and
    // return types) in the ArrowType.
    //
    // Rather than make the situation more complicated by introducing new
    // types (like unions of functions), we just fallback on the simpler
    // approach of getting things right at the top and the bottom of the
    // lattice.
    //
    // If there are unknown parameters or return types making things
    // ambiguous, then sup(A, B) is always the top function type, and
    // inf(A, B) is always the bottom function type.
    Preconditions.checkNotNull(that);
    if (isEquivalentTo(that)) {
        return this;
    }
    // If these are ordinary functions, then merge them.
    // Don't do this if any of the params/return
    // values are unknown, because then there will be cycles in
    // their local lattice and they will merge in weird ways.
    if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) {
        // Check for the degenerate case, but double check
        // that there's not a cycle.
        boolean isSubtypeOfThat = this.isSubtype(that);
        boolean isSubtypeOfThis = that.isSubtype(this);
        if (isSubtypeOfThat && !isSubtypeOfThis) {
            return leastSuper ? that : this;
        } else if (isSubtypeOfThis && !isSubtypeOfThat) {
            return leastSuper ? this : that;
        }
        // Merge the two functions component-wise.
        FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);
        if (merged != null) {
            return merged;
        }
    }
    // The function instance type is a special case
    // that lives above the rest of the lattice.
    JSType functionInstance = registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
        return leastSuper ? that : this;
    } else if (functionInstance.isEquivalentTo(this)) {
        return leastSuper ? this : that;
    }
    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the
    // greatest function. In practice, we don't because it's way too
    // broad. The greatest function takes var_args None parameters, which
    // means that all parameters register a type warning.
    //
    // Instead, we use the U2U ctor type, which has unknown type args.
    FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
}","public void test057106() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0, (JSType) recordType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) recordType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType0.supAndInfHelper(functionType1, true);
    assertSame(functionType0, functionType2);
}","/**
 * Computes the supremum or infimum of two functions.
 * Because sup() and inf() share a lot of logic for functions, we use
 * a single helper.
 * @param leastSuper If true, compute the supremum of {@code this} with
 *     {@code that}. Otherwise, compute the infimum.
 * @return The least supertype or greatest subtype.
 */"
"FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {
    // NOTE(nicksantos): When we remove the unknown type, the function types
    // form a lattice with the universal constructor at the top of the lattice,
    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.
    //
    // When we introduce the unknown type, it's much more difficult to make
    // heads or tails of the partial ordering of types, because there's no
    // clear hierarchy between the different components (parameter types and
    // return types) in the ArrowType.
    //
    // Rather than make the situation more complicated by introducing new
    // types (like unions of functions), we just fallback on the simpler
    // approach of getting things right at the top and the bottom of the
    // lattice.
    //
    // If there are unknown parameters or return types making things
    // ambiguous, then sup(A, B) is always the top function type, and
    // inf(A, B) is always the bottom function type.
    Preconditions.checkNotNull(that);
    if (isEquivalentTo(that)) {
        return this;
    }
    // If these are ordinary functions, then merge them.
    // Don't do this if any of the params/return
    // values are unknown, because then there will be cycles in
    // their local lattice and they will merge in weird ways.
    if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) {
        // Check for the degenerate case, but double check
        // that there's not a cycle.
        boolean isSubtypeOfThat = this.isSubtype(that);
        boolean isSubtypeOfThis = that.isSubtype(this);
        if (isSubtypeOfThat && !isSubtypeOfThis) {
            return leastSuper ? that : this;
        } else if (isSubtypeOfThis && !isSubtypeOfThat) {
            return leastSuper ? this : that;
        }
        // Merge the two functions component-wise.
        FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);
        if (merged != null) {
            return merged;
        }
    }
    // The function instance type is a special case
    // that lives above the rest of the lattice.
    JSType functionInstance = registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
        return leastSuper ? that : this;
    } else if (functionInstance.isEquivalentTo(this)) {
        return leastSuper ? this : that;
    }
    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the
    // greatest function. In practice, we don't because it's way too
    // broad. The greatest function takes var_args None parameters, which
    // means that all parameters register a type warning.
    //
    // Instead, we use the U2U ctor type, which has unknown type args.
    FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
}","public void test058107() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    ImmutableList<JSType> immutableList1 = ImmutableList.of((JSType) voidType0, (JSType) functionType0, (JSType) functionType0, (JSType) voidType0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) immutableList1);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, false);
    assertNotSame(functionType2, functionType1);
}","/**
 * Computes the supremum or infimum of two functions.
 * Because sup() and inf() share a lot of logic for functions, we use
 * a single helper.
 * @param leastSuper If true, compute the supremum of {@code this} with
 *     {@code that}. Otherwise, compute the infimum.
 * @return The least supertype or greatest subtype.
 */"
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test058109() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    ImmutableList<JSType> immutableList1 = ImmutableList.of((JSType) voidType0, (JSType) functionType0, (JSType) functionType0, (JSType) voidType0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) immutableList1);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, false);
    assertTrue(functionType2.isOrdinaryFunction());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test059110() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    FunctionType functionType0 = errorFunctionType0.supAndInfHelper(noResolvedType0, true);
    errorFunctionType0.supAndInfHelper(functionType0, false);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test060111() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    FunctionType functionType0 = errorFunctionType0.supAndInfHelper(noResolvedType0, true);
    noResolvedType0.supAndInfHelper(functionType0, true);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test060112() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    FunctionType functionType0 = errorFunctionType0.supAndInfHelper(noResolvedType0, true);
    noResolvedType0.supAndInfHelper(functionType0, true);
    assertFalse(noResolvedType0.isOrdinaryFunction());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test061113() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    NoResolvedType noResolvedType1 = (NoResolvedType) noResolvedType0.supAndInfHelper(errorFunctionType0, true);
    noResolvedType1.supAndInfHelper(noResolvedType0, true);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test061114() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    NoResolvedType noResolvedType1 = (NoResolvedType) noResolvedType0.supAndInfHelper(errorFunctionType0, true);
    noResolvedType1.supAndInfHelper(noResolvedType0, true);
    assertFalse(noResolvedType0.isOrdinaryFunction());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test062115() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    FunctionType functionType0 = noResolvedType0.supAndInfHelper(errorFunctionType0, true);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test062116() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    FunctionType functionType0 = noResolvedType0.supAndInfHelper(errorFunctionType0, true);
    functionType0.getTypesUnderShallowEquality(errorFunctionType0);
    assertFalse(noResolvedType0.isOrdinaryFunction());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test063117() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry1.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertTrue(functionType2.equals((Object) functionType1));
}",""
"public boolean isReturnTypeInferred() {
    return call.returnTypeInferred;
}","public void test063118() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry1.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertFalse(functionType2.isReturnTypeInferred());
}",""
"FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {
    // NOTE(nicksantos): When we remove the unknown type, the function types
    // form a lattice with the universal constructor at the top of the lattice,
    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.
    //
    // When we introduce the unknown type, it's much more difficult to make
    // heads or tails of the partial ordering of types, because there's no
    // clear hierarchy between the different components (parameter types and
    // return types) in the ArrowType.
    //
    // Rather than make the situation more complicated by introducing new
    // types (like unions of functions), we just fallback on the simpler
    // approach of getting things right at the top and the bottom of the
    // lattice.
    //
    // If there are unknown parameters or return types making things
    // ambiguous, then sup(A, B) is always the top function type, and
    // inf(A, B) is always the bottom function type.
    Preconditions.checkNotNull(that);
    if (isEquivalentTo(that)) {
        return this;
    }
    // If these are ordinary functions, then merge them.
    // Don't do this if any of the params/return
    // values are unknown, because then there will be cycles in
    // their local lattice and they will merge in weird ways.
    if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) {
        // Check for the degenerate case, but double check
        // that there's not a cycle.
        boolean isSubtypeOfThat = this.isSubtype(that);
        boolean isSubtypeOfThis = that.isSubtype(this);
        if (isSubtypeOfThat && !isSubtypeOfThis) {
            return leastSuper ? that : this;
        } else if (isSubtypeOfThis && !isSubtypeOfThat) {
            return leastSuper ? this : that;
        }
        // Merge the two functions component-wise.
        FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);
        if (merged != null) {
            return merged;
        }
    }
    // The function instance type is a special case
    // that lives above the rest of the lattice.
    JSType functionInstance = registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
        return leastSuper ? that : this;
    } else if (functionInstance.isEquivalentTo(this)) {
        return leastSuper ? this : that;
    }
    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the
    // greatest function. In practice, we don't because it's way too
    // broad. The greatest function takes var_args None parameters, which
    // means that all parameters register a type warning.
    //
    // Instead, we use the U2U ctor type, which has unknown type args.
    FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
}","public void test063119() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry1.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertNotSame(functionType2, functionType1);
}","/**
 * Computes the supremum or infimum of two functions.
 * Because sup() and inf() share a lot of logic for functions, we use
 * a single helper.
 * @param leastSuper If true, compute the supremum of {@code this} with
 *     {@code that}. Otherwise, compute the infimum.
 * @return The least supertype or greatest subtype.
 */"
"public FunctionType getSuperClassConstructor() {
    Preconditions.checkArgument(isConstructor() || isInterface());
    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();
    if (maybeSuperInstanceType == null) {
        return null;
    }
    return maybeSuperInstanceType.getConstructor();
}","public void test064120() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.getBindReturnType(1);
    // Undeclared exception!
    try {
        functionType0.getSuperClassConstructor();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Given a constructor or an interface type, get its superclass constructor
 * or {@code null} if none exists.
 */"
"public static ObjectType getTopDefiningInterface(ObjectType type, String propertyName) {
    ObjectType foundType = null;
    if (type.hasProperty(propertyName)) {
        foundType = type;
    }
    for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) {
        if (interfaceType.hasProperty(propertyName)) {
            foundType = getTopDefiningInterface(interfaceType, propertyName);
        }
    }
    return foundType;
}","public void test065121() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""bind"");
    ObjectType objectType0 = FunctionType.getTopDefiningInterface(errorFunctionType0, ""Named type with empty name component"");
    assertNull(objectType0);
}","/**
 * Given an interface and a property, finds the top-most super interface
 * that has the property defined (including this interface).
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test066122() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    functionType0.setInstanceType(noResolvedType0);
    assertTrue(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public ObjectType getTopMostDefiningType(String propertyName) {
    Preconditions.checkState(isConstructor() || isInterface());
    Preconditions.checkArgument(getInstanceType().hasProperty(propertyName));
    FunctionType ctor = this;
    if (isInterface()) {
        return getTopDefiningInterface(this.getInstanceType(), propertyName);
    }
    ObjectType topInstanceType = null;
    do {
        topInstanceType = ctor.getInstanceType();
        ctor = ctor.getSuperClassConstructor();
    } while (ctor != null && ctor.getPrototype().hasProperty(propertyName));
    return topInstanceType;
}","public void test066123() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    functionType0.setInstanceType(noResolvedType0);
    ObjectType objectType0 = functionType0.getTopMostDefiningType(""Unknown class name"");
    assertNotNull(objectType0);
}","/**
 * Given a constructor or an interface type and a property, finds the
 * top-most superclass that has the property defined (including this
 * constructor).
 */"
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test066124() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    functionType0.setInstanceType(noResolvedType0);
    ObjectType objectType0 = functionType0.getTopMostDefiningType(""Unknown class name"");
    assertFalse(functionType0.isConstructor());
}",""
"public ObjectType getTopMostDefiningType(String propertyName) {
    Preconditions.checkState(isConstructor() || isInterface());
    Preconditions.checkArgument(getInstanceType().hasProperty(propertyName));
    FunctionType ctor = this;
    if (isInterface()) {
        return getTopDefiningInterface(this.getInstanceType(), propertyName);
    }
    ObjectType topInstanceType = null;
    do {
        topInstanceType = ctor.getInstanceType();
        ctor = ctor.getSuperClassConstructor();
    } while (ctor != null && ctor.getPrototype().hasProperty(propertyName));
    return topInstanceType;
}","public void test067125() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    FunctionType functionType0 = noResolvedType0.supAndInfHelper(errorFunctionType0, false);
    // Undeclared exception!
    try {
        functionType0.getTopMostDefiningType(""Not declared as a type name"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Given a constructor or an interface type and a property, finds the
 * top-most superclass that has the property defined (including this
 * constructor).
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test068126() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    FunctionType functionType0 = noResolvedType0.supAndInfHelper(errorFunctionType0, true);
    functionType0.getTopMostDefiningType(""Not declared as a type name"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test068127() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    FunctionType functionType0 = noResolvedType0.supAndInfHelper(errorFunctionType0, true);
    functionType0.getTopMostDefiningType(""Not declared as a type name"");
    assertFalse(noResolvedType0.isOrdinaryFunction());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    if (that.isFunctionType()) {
        FunctionType other = that.toMaybeFunctionType();
        if (other.isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        boolean treatThisTypesAsCovariant = // If either one of these is a ctor, skip 'this' checking.
        this.isConstructor() || other.isConstructor() || // An interface 'this'-type is non-restrictive.
        // In practical terms, if C implements I, and I has a method m,
        // then any m doesn't necessarily have to C#m's 'this'
        // type doesn't need to match I.
        (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || // If one of the 'this' types is covariant of the other,
        // then we'll treat them as covariant (see comment above).
        other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);
        return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test069128() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""i"");
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, errorFunctionType0);
    boolean boolean0 = errorFunctionType0.isSubtype(proxyObjectType0);
    assertTrue(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test070129() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""G}~ft9,r"", (Node) null);
    FunctionType functionType1 = FunctionType.forInterface(jSTypeRegistry0, ""U0#B?gY]C;{X%9]"", (Node) null);
    FunctionType functionType2 = functionType0.supAndInfHelper(functionType1, true);
    assertFalse(functionType1.isOrdinaryFunction());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test070130() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""G}~ft9,r"", (Node) null);
    FunctionType functionType1 = FunctionType.forInterface(jSTypeRegistry0, ""U0#B?gY]C;{X%9]"", (Node) null);
    FunctionType functionType2 = functionType0.supAndInfHelper(functionType1, true);
    assertFalse(functionType2.equals((Object) functionType1));
}",""
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test070131() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""G}~ft9,r"", (Node) null);
    FunctionType functionType1 = FunctionType.forInterface(jSTypeRegistry0, ""U0#B?gY]C;{X%9]"", (Node) null);
    FunctionType functionType2 = functionType0.supAndInfHelper(functionType1, true);
    assertFalse(functionType1.isConstructor());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test071132() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""lR` nmVLW"");
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Named type with empty name component"", (Node) null);
    functionType0.supAndInfHelper(errorFunctionType0, true);
    assertTrue(functionType0.hasCachedValues());
}",""
"FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {
    // NOTE(nicksantos): When we remove the unknown type, the function types
    // form a lattice with the universal constructor at the top of the lattice,
    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.
    //
    // When we introduce the unknown type, it's much more difficult to make
    // heads or tails of the partial ordering of types, because there's no
    // clear hierarchy between the different components (parameter types and
    // return types) in the ArrowType.
    //
    // Rather than make the situation more complicated by introducing new
    // types (like unions of functions), we just fallback on the simpler
    // approach of getting things right at the top and the bottom of the
    // lattice.
    //
    // If there are unknown parameters or return types making things
    // ambiguous, then sup(A, B) is always the top function type, and
    // inf(A, B) is always the bottom function type.
    Preconditions.checkNotNull(that);
    if (isEquivalentTo(that)) {
        return this;
    }
    // If these are ordinary functions, then merge them.
    // Don't do this if any of the params/return
    // values are unknown, because then there will be cycles in
    // their local lattice and they will merge in weird ways.
    if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) {
        // Check for the degenerate case, but double check
        // that there's not a cycle.
        boolean isSubtypeOfThat = this.isSubtype(that);
        boolean isSubtypeOfThis = that.isSubtype(this);
        if (isSubtypeOfThat && !isSubtypeOfThis) {
            return leastSuper ? that : this;
        } else if (isSubtypeOfThis && !isSubtypeOfThat) {
            return leastSuper ? this : that;
        }
        // Merge the two functions component-wise.
        FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);
        if (merged != null) {
            return merged;
        }
    }
    // The function instance type is a special case
    // that lives above the rest of the lattice.
    JSType functionInstance = registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
        return leastSuper ? that : this;
    } else if (functionInstance.isEquivalentTo(this)) {
        return leastSuper ? this : that;
    }
    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the
    // greatest function. In practice, we don't because it's way too
    // broad. The greatest function takes var_args None parameters, which
    // means that all parameters register a type warning.
    //
    // Instead, we use the U2U ctor type, which has unknown type args.
    FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
}","public void test072133() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) immutableList0);
    FunctionType functionType2 = functionType1.supAndInfHelper(functionType0, true);
    assertSame(functionType2, functionType1);
}","/**
 * Computes the supremum or infimum of two functions.
 * Because sup() and inf() share a lot of logic for functions, we use
 * a single helper.
 * @param leastSuper If true, compute the supremum of {@code this} with
 *     {@code that}. Otherwise, compute the infimum.
 * @return The least supertype or greatest subtype.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test073134() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    FunctionType functionType0 = noResolvedType0.supAndInfHelper(errorFunctionType0, true);
    String string0 = functionType0.toDebugHashCodeString();
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public String toDebugHashCodeString() {
    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return super.toDebugHashCodeString();
    }
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();
    if (hasKnownTypeOfThis) {
        b.append(""this:"");
        b.append(getDebugHashCodeStringOf(typeOfThis));
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        b.append(getDebugHashCodeStringOf(p.getJSType()));
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            b.append(getDebugHashCodeStringOf(p.getJSType()));
            p = p.getNext();
        }
    }
    b.append("")"");
    b.append("": "");
    b.append(getDebugHashCodeStringOf(call.returnType));
    return b.toString();
}","public void test073135() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    FunctionType functionType0 = noResolvedType0.supAndInfHelper(errorFunctionType0, true);
    String string0 = functionType0.toDebugHashCodeString();
    assertEquals(""{20}"", string0);
}",""
"@Override
public int hashCode() {
    return isInterface() ? getReferenceName().hashCode() : call.hashCode();
}","public void test074136() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a type name"", (Node) null);
    functionType0.hashCode();
}",""
"@Override
String toStringHelper(boolean forAnnotations) {
    if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return ""Function"";
    }
    setPrettyPrint(false);
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType);
    if (hasKnownTypeOfThis) {
        if (isConstructor()) {
            b.append(""new:"");
        } else {
            b.append(""this:"");
        }
        b.append(typeOfThis.toStringHelper(forAnnotations));
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        appendArgString(b, p, forAnnotations);
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            appendArgString(b, p, forAnnotations);
            p = p.getNext();
        }
    }
    b.append(""): "");
    b.append(call.returnType.toStringHelper(forAnnotations));
    setPrettyPrint(true);
    return b.toString();
}","public void test075137() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""STRUCT"");
    errorFunctionType0.setPrettyPrint(false);
    String string0 = errorFunctionType0.toStringHelper(false);
    assertEquals(""Function"", string0);
}","/**
 * Informally, a function is represented by
 * {@code function (params): returnType} where the {@code params} is a comma
 * separated list of types, the first one being a special
 * {@code this:T} if the function expects a known type for {@code this}.
 */"
"@Override
String toStringHelper(boolean forAnnotations) {
    if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return ""Function"";
    }
    setPrettyPrint(false);
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType);
    if (hasKnownTypeOfThis) {
        if (isConstructor()) {
            b.append(""new:"");
        } else {
            b.append(""this:"");
        }
        b.append(typeOfThis.toStringHelper(forAnnotations));
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        appendArgString(b, p, forAnnotations);
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            appendArgString(b, p, forAnnotations);
            p = p.getNext();
        }
    }
    b.append(""): "");
    b.append(call.returnType.toStringHelper(forAnnotations));
    setPrettyPrint(true);
    return b.toString();
}","public void test076138() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    String string0 = errorFunctionType0.toStringHelper(true);
    assertEquals(""function (new:Not declared as a type name, *=, *=, *=): Not declared as a type name"", string0);
}","/**
 * Informally, a function is represented by
 * {@code function (params): returnType} where the {@code params} is a comma
 * separated list of types, the first one being a special
 * {@code this:T} if the function expects a known type for {@code this}.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test077139() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    NoResolvedType noResolvedType1 = (NoResolvedType) noResolvedType0.supAndInfHelper(errorFunctionType0, true);
    String string0 = noResolvedType1.toStringHelper(true);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
String toStringHelper(boolean forAnnotations) {
    return forAnnotations ? ""?"" : ""NoResolvedType"";
}","public void test077140() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    NoResolvedType noResolvedType1 = (NoResolvedType) noResolvedType0.supAndInfHelper(errorFunctionType0, true);
    String string0 = noResolvedType1.toStringHelper(true);
    assertEquals(""Function"", string0);
}",""
"public final String toAnnotationString() {
    return toStringHelper(true);
}","public void test078141() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a constructor"", (Node) null);
    String string0 = functionType0.toAnnotationString();
    assertEquals(""function (this:Not declared as a constructor): ?"", string0);
}","/**
 * A string representation of this type, suitable for printing
 * in type annotations at code generation time.
 */"
"@Override
String toStringHelper(boolean forAnnotations) {
    if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return ""Function"";
    }
    setPrettyPrint(false);
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType);
    if (hasKnownTypeOfThis) {
        if (isConstructor()) {
            b.append(""new:"");
        } else {
            b.append(""this:"");
        }
        b.append(typeOfThis.toStringHelper(forAnnotations));
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        appendArgString(b, p, forAnnotations);
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            appendArgString(b, p, forAnnotations);
            p = p.getNext();
        }
    }
    b.append(""): "");
    b.append(call.returnType.toStringHelper(forAnnotations));
    setPrettyPrint(true);
    return b.toString();
}","public void test079142() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.getBindReturnType(0);
    String string0 = functionType0.toStringHelper(false);
    assertEquals(""function (...[?]): NoResolvedType"", string0);
}","/**
 * Informally, a function is represented by
 * {@code function (params): returnType} where the {@code params} is a comma
 * separated list of types, the first one being a special
 * {@code this:T} if the function expects a known type for {@code this}.
 */"
"@Override
String toStringHelper(boolean forAnnotations) {
    if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return ""Function"";
    }
    setPrettyPrint(false);
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType);
    if (hasKnownTypeOfThis) {
        if (isConstructor()) {
            b.append(""new:"");
        } else {
            b.append(""this:"");
        }
        b.append(typeOfThis.toStringHelper(forAnnotations));
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        appendArgString(b, p, forAnnotations);
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            appendArgString(b, p, forAnnotations);
            p = p.getNext();
        }
    }
    b.append(""): "");
    b.append(call.returnType.toStringHelper(forAnnotations));
    setPrettyPrint(true);
    return b.toString();
}","public void test080143() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) voidType0, (List<JSType>) immutableList0);
    String string0 = functionType0.toStringHelper(true);
    assertEquals(""function (undefined, ...[undefined]): undefined"", string0);
}","/**
 * Informally, a function is represented by
 * {@code function (params): returnType} where the {@code params} is a comma
 * separated list of types, the first one being a special
 * {@code this:T} if the function expects a known type for {@code this}.
 */"
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    if (that.isFunctionType()) {
        FunctionType other = that.toMaybeFunctionType();
        if (other.isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        boolean treatThisTypesAsCovariant = // If either one of these is a ctor, skip 'this' checking.
        this.isConstructor() || other.isConstructor() || // An interface 'this'-type is non-restrictive.
        // In practical terms, if C implements I, and I has a method m,
        // then any m doesn't necessarily have to C#m's 'this'
        // type doesn't need to match I.
        (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || // If one of the 'this' types is covariant of the other,
        // then we'll treat them as covariant (see comment above).
        other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);
        return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test081144() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""jaz"");
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Named type with empty name component"", (Node) null);
    boolean boolean0 = functionType0.isSubtype(errorFunctionType0);
    assertFalse(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test081145() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""jaz"");
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Named type with empty name component"", (Node) null);
    boolean boolean0 = functionType0.isSubtype(errorFunctionType0);
    assertFalse(functionType0.isConstructor());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    if (that.isFunctionType()) {
        FunctionType other = that.toMaybeFunctionType();
        if (other.isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        boolean treatThisTypesAsCovariant = // If either one of these is a ctor, skip 'this' checking.
        this.isConstructor() || other.isConstructor() || // An interface 'this'-type is non-restrictive.
        // In practical terms, if C implements I, and I has a method m,
        // then any m doesn't necessarily have to C#m's 'this'
        // type doesn't need to match I.
        (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || // If one of the 'this' types is covariant of the other,
        // then we'll treat them as covariant (see comment above).
        other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);
        return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test082146() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qz'B%@L6e<^I"");
    ErrorFunctionType errorFunctionType1 = new ErrorFunctionType(jSTypeRegistry0, ""Qz'B%@L6e<^I"");
    boolean boolean0 = errorFunctionType0.isSubtype(errorFunctionType1);
    assertTrue(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test082147() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qz'B%@L6e<^I"");
    ErrorFunctionType errorFunctionType1 = new ErrorFunctionType(jSTypeRegistry0, ""Qz'B%@L6e<^I"");
    boolean boolean0 = errorFunctionType0.isSubtype(errorFunctionType1);
    assertFalse(errorFunctionType1.equals((Object) errorFunctionType0));
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test083148() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""bind"");
    JSType jSType0 = errorFunctionType0.getPropertyType(""bind"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public boolean isSubtype(JSType that) {
    return isSubtypeHelper(this, that);
}","public void test083149() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""bind"");
    JSType jSType0 = errorFunctionType0.getPropertyType(""bind"");
    boolean boolean0 = jSType0.isSubtype(errorFunctionType0);
    assertFalse(boolean0);
}","/**
 * Checks whether {@code this} is a subtype of {@code that}.<p>
 *
 * Subtyping rules:
 * <ul>
 * <li>(unknown) &mdash; every type is a subtype of the Unknown type.</li>
 * <li>(no) &mdash; the No type is a subtype of every type.</li>
 * <li>(no-object) &mdash; the NoObject type is a subtype of every object
 * type (i.e. subtypes of the Object type).</li>
 * <li>(ref) &mdash; a type is a subtype of itself.</li>
 * <li>(union-l) &mdash; A union type is a subtype of a type U if all the
 * union type's constituents are a subtype of U. Formally<br>
 * {@code (T<sub>1</sub>, &hellip;, T<sub>n</sub>) &lt;: U} if and only
 * {@code T<sub>k</sub> &lt;: U} for all {@code k &isin; 1..n}.</li>
 * <li>(union-r) &mdash; A type U is a subtype of a union type if it is a
 * subtype of one of the union type's constituents. Formally<br>
 * {@code U &lt;: (T<sub>1</sub>, &hellip;, T<sub>n</sub>)} if and only
 * if {@code U &lt;: T<sub>k</sub>} for some index {@code k}.</li>
 * <li>(objects) &mdash; an Object {@code O<sub>1</sub>} is a subtype
 * of an object {@code O<sub>2</sub>} if it has more properties
 * than {@code O<sub>2</sub>} and all common properties are
 * pairwise subtypes.</li>
 * </ul>
 *
 * @return {@code this &lt;: that}
 */"
"public boolean isNativeObjectType() {
    return false;
}","public void test084150() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    ObjectType objectType0 = noObjectType0.getTypeOfThis();
    assertFalse(objectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean matchesStringContext() {
    return true;
}","public void test085151() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.setSource((Node) null);
    assertTrue(noResolvedType0.matchesStringContext());
}",""
"public boolean isBooleanValueType() {
    return false;
}","public void test086152() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noObjectType0, false);
    JSType jSType0 = instanceObjectType0.getRestrictedTypeGivenToBooleanOutcome(false);
    instanceObjectType0.getGreatestSubtype(jSType0);
    Node node0 = new Node(0, (-528), (-2004603710));
    noObjectType0.setSource(node0);
    assertFalse(noObjectType0.isBooleanValueType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test087153() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.getAllImplementedInterfaces();
    noResolvedType0.setSource((Node) null);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"public boolean isScript() {
    return this.getType() == Token.SCRIPT;
}","public void test088154() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noObjectType0, false);
    JSType jSType0 = instanceObjectType0.getRestrictedTypeGivenToBooleanOutcome(false);
    UnknownType unknownType0 = (UnknownType) instanceObjectType0.getGreatestSubtype(jSType0);
    Node node0 = new Node(0, (-528), (-2004603710));
    noObjectType0.setPrototypeBasedOn((ObjectType) unknownType0, node0);
    noObjectType0.setSource(node0);
    assertFalse(node0.isScript());
}",""
"public boolean isNominalType() {
    return false;
}","public void test089155() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
    ErrorFunctionType errorFunctionType0 = (ErrorFunctionType) jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    errorFunctionType0.makesDicts();
    Node node0 = new Node(0);
    errorFunctionType0.setPrototypeBasedOn((ObjectType) errorFunctionType0, node0);
    assertFalse(errorFunctionType0.isNominalType());
}","/**
 * Whether this type is a nominal type (a named instance object or
 * a named enum).
 */"
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test090156() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""BITNOT"", (Node) null);
    functionType0.clearCachedValues();
    assertFalse(functionType0.isConstructor());
}",""
"void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) {
    // This is a bit weird. We need to successfully handle these
    // two cases:
    // Foo.prototype = new Bar();
    // and
    // Foo.prototype = {baz: 3};
    // In the first case, we do not want new properties to get
    // added to Bar. In the second case, we do want new properties
    // to get added to the type of the anonymous object.
    //
    // We handle this by breaking it into two cases:
    //
    // In the first case, we create a new PrototypeObjectType and set
    // its implicit prototype to the type being assigned. This ensures
    // that Bar will not get any properties of Foo.prototype, but properties
    // later assigned to Bar will get inherited properly.
    //
    // In the second case, we just use the anonymous object as the prototype.
    if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType()) {
        baseType = new PrototypeObjectType(registry, this.getReferenceName() + "".prototype"", baseType);
    }
    setPrototype(baseType, propertyNode);
}","public void test091157() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = noResolvedType0.getBindReturnType(1);
    FunctionType functionType1 = (FunctionType) functionType0.resolveInternal((ErrorReporter) null, noResolvedType0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType1, false);
    instanceObjectType0.getPropertyNode(""Not declared as a type name"");
    // Undeclared exception!
    try {
        functionType1.setPrototypeBasedOn((ObjectType) functionType0, (Node) null);
        fail(""Expecting exception: StackOverflowError"");
    } catch (StackOverflowError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public boolean hasCachedValues() {
    return !unknown;
}","public void test092158() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    ObjectType objectType0 = noObjectType0.getTopMostDefiningType((String) null);
    boolean boolean0 = objectType0.hasCachedValues();
    assertTrue(boolean0);
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"final void setImplicitPrototype(ObjectType implicitPrototype) {
    checkState(!hasCachedValues());
    this.implicitPrototypeFallback = implicitPrototype;
}","public void test093159() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    ErrorFunctionType errorFunctionType1 = (ErrorFunctionType) errorFunctionType0.supAndInfHelper(noResolvedType0, true);
    // Undeclared exception!
    try {
        errorFunctionType1.setImplicitPrototype(noResolvedType0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * This should only be reset on the FunctionPrototypeType, only to fix an
 * incorrectly established prototype chain due to the user having a mismatch
 * in super class declaration, and only before properties on that type are
 * processed.
 */"
"public boolean isCheckedUnknownType() {
    return false;
}","public void test094160() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""L7^Guai%p'YAm;"", ""com.google.javascript.rhino.jstype.IndexedType"", (-1394), Integer.MAX_VALUE);
    ImmutableList<ObjectType> immutableList0 = ImmutableList.of((ObjectType) noObjectType0, (ObjectType) namedType0, (ObjectType) namedType0, (ObjectType) namedType0);
    errorFunctionType0.setImplementedInterfaces(immutableList0);
    JSType jSType0 = errorFunctionType0.resolve(simpleErrorReporter0, noObjectType0);
    assertFalse(jSType0.isCheckedUnknownType());
}",""
"@Override
public boolean isObject() {
    return true;
}","public void test095161() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
    ErrorFunctionType errorFunctionType0 = (ErrorFunctionType) jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    ErrorFunctionType errorFunctionType1 = (ErrorFunctionType) errorFunctionType0.resolveInternal(simpleErrorReporter0, (StaticScope<JSType>) null);
    assertTrue(errorFunctionType1.isObject());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test096162() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    errorFunctionType0.toDebugHashCodeString();
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test097163() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    FunctionType functionType0 = noResolvedType0.supAndInfHelper(errorFunctionType0, false);
    String string0 = functionType0.toDebugHashCodeString();
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public String toDebugHashCodeString() {
    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return super.toDebugHashCodeString();
    }
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();
    if (hasKnownTypeOfThis) {
        b.append(""this:"");
        b.append(getDebugHashCodeStringOf(typeOfThis));
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        b.append(getDebugHashCodeStringOf(p.getJSType()));
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            b.append(getDebugHashCodeStringOf(p.getJSType()));
            p = p.getNext();
        }
    }
    b.append("")"");
    b.append("": "");
    b.append(getDebugHashCodeStringOf(call.returnType));
    return b.toString();
}","public void test097164() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    FunctionType functionType0 = noResolvedType0.supAndInfHelper(errorFunctionType0, false);
    String string0 = functionType0.toDebugHashCodeString();
    assertEquals(""function ({13}): function (this:me, {10}): me"", string0);
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test098165() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) noObjectType0, true, jSTypeArray0);
    functionType0.toDebugHashCodeString();
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasAnyTemplateInternal() {
    return !getTemplateTypeNames().isEmpty() || typeOfThis.hasAnyTemplate() || call.hasAnyTemplate();
}","public void test099166() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, true);
    ArrowType arrowType0 = new ArrowType(jSTypeRegistry0, (Node) null, recordType0, true);
    ImmutableList<String> immutableList0 = ImmutableList.of(""com.googe.common.base.Predicates$1"", ""Named type with empty name component"", ""ef :rD"");
    FunctionType functionType0 = new FunctionType(jSTypeRegistry0, "",SbQzcT1f:31"", (Node) null, arrowType0, (ObjectType) null, immutableList0, false, false);
    boolean boolean0 = functionType0.hasAnyTemplateInternal();
    assertTrue(boolean0);
}",""
"@Override
public boolean hasAnyTemplateInternal() {
    return !getTemplateTypeNames().isEmpty() || typeOfThis.hasAnyTemplate() || call.hasAnyTemplate();
}","public void test100167() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""ZJ5CD+2z =icYk"");
    JSType[] jSTypeArray0 = new JSType[5];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) templateType0, jSTypeArray0);
    boolean boolean0 = functionType0.hasAnyTemplateInternal();
    assertTrue(boolean0);
}",""
