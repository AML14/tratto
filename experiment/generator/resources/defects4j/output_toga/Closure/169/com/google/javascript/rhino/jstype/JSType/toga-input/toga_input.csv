focal_method,test_prefix,docstring
"public boolean isNoType() {
    return false;
}","public void test0000() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    noResolvedType0.getTypesUnderEquality(allType0);
    assertFalse(allType0.isNoType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test0001() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    noResolvedType0.getTypesUnderEquality(allType0);
    assertFalse(allType0.isNoObjectType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test0002() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    noResolvedType0.getTypesUnderEquality(allType0);
    assertFalse(noResolvedType0.hasCachedValues());
}",""
"public boolean isAllType() {
    return false;
}","public void test0003() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    noResolvedType0.getTypesUnderEquality(allType0);
    assertFalse(noResolvedType0.isAllType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test0004() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    noResolvedType0.getTypesUnderEquality(allType0);
    assertFalse(allType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test0005() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    noResolvedType0.getTypesUnderEquality(allType0);
    assertFalse(allType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isStringValueType() {
    return false;
}","public void test0016() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autoboxesTo();
    boolean boolean0 = jSType0.isStringValueType();
    assertFalse(boolean0);
}",""
"public boolean isAllType() {
    return false;
}","public void test0017() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autoboxesTo();
    boolean boolean0 = jSType0.isStringValueType();
    assertFalse(jSType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test0018() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autoboxesTo();
    boolean boolean0 = jSType0.isStringValueType();
    assertFalse(jSType0.isNoType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test0019() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autoboxesTo();
    boolean boolean0 = jSType0.isStringValueType();
    assertFalse(jSType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00110() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autoboxesTo();
    boolean boolean0 = jSType0.isStringValueType();
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test00111() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autoboxesTo();
    boolean boolean0 = jSType0.isStringValueType();
    assertFalse(jSType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test00212() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isBooleanObjectType();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isAllType() {
    return false;
}","public void test00213() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isBooleanObjectType();
    assertFalse(booleanType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test00214() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isBooleanObjectType();
    assertFalse(booleanType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00215() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isBooleanObjectType();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isBooleanObjectType() {
    return false;
}","public void test00216() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isBooleanObjectType();
    assertFalse(boolean0);
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test00217() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isBooleanObjectType();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isAllType() {
    return false;
}","public void test00318() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, voidType0, ""m(xW=htH0m>*Au"");
    enumElementType0.findPropertyType(""1PMq1"");
    assertFalse(enumElementType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test00319() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, voidType0, ""m(xW=htH0m>*Au"");
    enumElementType0.findPropertyType(""1PMq1"");
    assertFalse(enumElementType0.isNoType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test00320() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, voidType0, ""m(xW=htH0m>*Au"");
    enumElementType0.findPropertyType(""1PMq1"");
    assertFalse(enumElementType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00321() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, voidType0, ""m(xW=htH0m>*Au"");
    enumElementType0.findPropertyType(""1PMq1"");
    assertFalse(enumElementType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test00322() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, voidType0, ""m(xW=htH0m>*Au"");
    enumElementType0.findPropertyType(""1PMq1"");
    assertFalse(enumElementType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test00423() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getJSDocInfo();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoType() {
    return false;
}","public void test00424() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getJSDocInfo();
    assertFalse(booleanType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00425() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getJSDocInfo();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test00426() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getJSDocInfo();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isAllType() {
    return false;
}","public void test00427() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getJSDocInfo();
    assertFalse(booleanType0.isAllType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test00528() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    String string0 = booleanType0.toDebugHashCodeString();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00529() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    String string0 = booleanType0.toDebugHashCodeString();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public String toDebugHashCodeString() {
    return ""{"" + this.hashCode() + ""}"";
}","public void test00530() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    String string0 = booleanType0.toDebugHashCodeString();
    assertEquals(""{270}"", string0);
}","/**
 * A hash code function for diagnosing complicated issues
 * around type-identity.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test00531() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    String string0 = booleanType0.toDebugHashCodeString();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test00632() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isRegexpType();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isRegexpType() {
    return false;
}","public void test00633() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isRegexpType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00634() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isRegexpType();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test00635() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isRegexpType();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoType() {
    return false;
}","public void test00636() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isRegexpType();
    assertFalse(booleanType0.isNoType());
}",""
"public boolean isAllType() {
    return false;
}","public void test00637() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isRegexpType();
    assertFalse(booleanType0.isAllType());
}",""
"public boolean isAllType() {
    return false;
}","public void test00738() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.collapseUnion();
    assertFalse(jSType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test00739() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.collapseUnion();
    assertFalse(jSType0.isNoType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test00740() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.collapseUnion();
    assertFalse(jSType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test00741() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.collapseUnion();
    assertFalse(jSType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00742() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.collapseUnion();
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoType() {
    return false;
}","public void test00843() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isString();
    assertFalse(booleanType0.isNoType());
}",""
"public final boolean isString() {
    return this.isSubtype(getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));
}","public void test00844() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isString();
    assertFalse(boolean0);
}","/**
 * Tests whether the type is a string (value or Object).
 * @return {@code this &lt;: (String, string)}
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test00845() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isString();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test00846() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isString();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00847() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isString();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test00948() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isDateType();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test00949() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isDateType();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoType() {
    return false;
}","public void test00950() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isDateType();
    assertFalse(booleanType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00951() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isDateType();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isDateType() {
    return false;
}","public void test00952() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isDateType();
    assertFalse(boolean0);
}",""
"public boolean isAllType() {
    return false;
}","public void test00953() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isDateType();
    assertFalse(booleanType0.isAllType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test01054() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(numberType0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType.TypePair jSType_TypePair0 = noResolvedType0.getTypesUnderShallowInequality(jSType0);
    jSType0.getTypesUnderShallowInequality(jSType_TypePair0.typeB);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"public boolean isVoidType() {
    return false;
}","public void test01055() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(numberType0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType.TypePair jSType_TypePair0 = noResolvedType0.getTypesUnderShallowInequality(jSType0);
    jSType0.getTypesUnderShallowInequality(jSType_TypePair0.typeB);
    assertFalse(numberType0.isVoidType());
}",""
"public final String toAnnotationString() {
    return toStringHelper(true);
}","public void test01156() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""2vhARH(dUDsX%go&`"");
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) errorFunctionType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    String string0 = enumElementType0.toAnnotationString();
    assertEquals(""Not declared as a constructor"", string0);
}","/**
 * A string representation of this type, suitable for printing
 * in type annotations at code generation time.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test01157() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""2vhARH(dUDsX%go&`"");
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) errorFunctionType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    String string0 = enumElementType0.toAnnotationString();
    assertFalse(enumElementType0.isNoResolvedType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test01158() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""2vhARH(dUDsX%go&`"");
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) errorFunctionType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    String string0 = enumElementType0.toAnnotationString();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test01159() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""2vhARH(dUDsX%go&`"");
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) errorFunctionType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    String string0 = enumElementType0.toAnnotationString();
    assertFalse(enumElementType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01160() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""2vhARH(dUDsX%go&`"");
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) errorFunctionType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    String string0 = enumElementType0.toAnnotationString();
    assertFalse(enumElementType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test01261() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isStringObjectType();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01262() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isStringObjectType();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test01263() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isStringObjectType();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isStringObjectType() {
    return false;
}","public void test01264() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isStringObjectType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01365() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autoboxesTo();
    Node node0 = Node.newString(3657, "" YH81V3Xc?D"", 0, 0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType(node0, jSType0);
    boolean boolean0 = arrowType0.matchesObjectContext();
    assertFalse(arrowType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test01366() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autoboxesTo();
    Node node0 = Node.newString(3657, "" YH81V3Xc?D"", 0, 0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType(node0, jSType0);
    boolean boolean0 = arrowType0.matchesObjectContext();
    assertFalse(arrowType0.isNoObjectType());
}",""
"public boolean matchesObjectContext() {
    return false;
}","public void test01367() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autoboxesTo();
    Node node0 = Node.newString(3657, "" YH81V3Xc?D"", 0, 0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType(node0, jSType0);
    boolean boolean0 = arrowType0.matchesObjectContext();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in an
 * {@code Object} context, such as the expression in a with statement.
 *
 * Most types we will encounter, except notably {@code null}, have at least
 * the potential for converting to {@code Object}.  Host defined objects can
 * get peculiar.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test01368() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autoboxesTo();
    Node node0 = Node.newString(3657, "" YH81V3Xc?D"", 0, 0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType(node0, jSType0);
    boolean boolean0 = arrowType0.matchesObjectContext();
    assertFalse(arrowType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01469() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isNumberObjectType();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test01470() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isNumberObjectType();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNumberObjectType() {
    return false;
}","public void test01471() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isNumberObjectType();
    assertFalse(boolean0);
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test01472() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isNumberObjectType();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public final boolean isEnumElementType() {
    return toMaybeEnumElementType() != null;
}","public void test01573() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    ParameterizedType parameterizedType1 = new ParameterizedType(jSTypeRegistry0, enumElementType0, parameterizedType0);
    assertFalse(parameterizedType0.isEnumElementType());
}",""
"public final boolean isEnumElementType() {
    return toMaybeEnumElementType() != null;
}","public void test01574() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    ParameterizedType parameterizedType1 = new ParameterizedType(jSTypeRegistry0, enumElementType0, parameterizedType0);
    JSType jSType0 = parameterizedType1.getGreatestSubtype(parameterizedType0);
    assertTrue(parameterizedType1.isEnumElementType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01575() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    ParameterizedType parameterizedType1 = new ParameterizedType(jSTypeRegistry0, enumElementType0, parameterizedType0);
    JSType jSType0 = parameterizedType1.getGreatestSubtype(parameterizedType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test01576() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    ParameterizedType parameterizedType1 = new ParameterizedType(jSTypeRegistry0, enumElementType0, parameterizedType0);
    JSType jSType0 = parameterizedType1.getGreatestSubtype(parameterizedType0);
    assertFalse(enumElementType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test01577() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    ParameterizedType parameterizedType1 = new ParameterizedType(jSTypeRegistry0, enumElementType0, parameterizedType0);
    JSType jSType0 = parameterizedType1.getGreatestSubtype(parameterizedType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test01578() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    ParameterizedType parameterizedType1 = new ParameterizedType(jSTypeRegistry0, enumElementType0, parameterizedType0);
    JSType jSType0 = parameterizedType1.getGreatestSubtype(parameterizedType0);
    assertFalse(parameterizedType1.equals((Object) parameterizedType0));
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test01679() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    Node node0 = Node.newNumber((-1242.8477), 3, 5080);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.getGreatestSubtypeWithProperty(noObjectType0, ""Not declared as a constructor"");
    JSType jSType1 = jSTypeRegistry0.createDefaultObjectUnion(jSType0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType(node0, jSType1);
    boolean boolean0 = arrowType0.matchesStringContext();
    assertFalse(arrowType0.isNoResolvedType());
}",""
"public boolean matchesStringContext() {
    return false;
}","public void test01680() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    Node node0 = Node.newNumber((-1242.8477), 3, 5080);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.getGreatestSubtypeWithProperty(noObjectType0, ""Not declared as a constructor"");
    JSType jSType1 = jSTypeRegistry0.createDefaultObjectUnion(jSType0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType(node0, jSType1);
    boolean boolean0 = arrowType0.matchesStringContext();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in a
 * {@code String} context, such as an operand of a string concat (+) operator.
 *
 * All types have at least the potential for converting to {@code String}.
 * When we add externally defined types, such as a browser OM, we may choose
 * to add types that do not automatically convert to {@code String}.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test01681() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    Node node0 = Node.newNumber((-1242.8477), 3, 5080);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.getGreatestSubtypeWithProperty(noObjectType0, ""Not declared as a constructor"");
    JSType jSType1 = jSTypeRegistry0.createDefaultObjectUnion(jSType0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType(node0, jSType1);
    boolean boolean0 = arrowType0.matchesStringContext();
    assertFalse(arrowType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01682() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    Node node0 = Node.newNumber((-1242.8477), 3, 5080);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.getGreatestSubtypeWithProperty(noObjectType0, ""Not declared as a constructor"");
    JSType jSType1 = jSTypeRegistry0.createDefaultObjectUnion(jSType0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType(node0, jSType1);
    boolean boolean0 = arrowType0.matchesStringContext();
    assertFalse(arrowType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test01783() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(voidType0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType.TypePair jSType_TypePair0 = noResolvedType0.getTypesUnderShallowInequality(jSType0);
    boolean boolean0 = jSType_TypePair0.typeB.isNullable();
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"public boolean isNullable() {
    return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE));
}","public void test01784() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(voidType0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType.TypePair jSType_TypePair0 = noResolvedType0.getTypesUnderShallowInequality(jSType0);
    boolean boolean0 = jSType_TypePair0.typeB.isNullable();
    assertTrue(boolean0);
}","/**
 * Tests whether this type is nullable.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test01885() throws Throwable {
    StringType stringType0 = new StringType((JSTypeRegistry) null);
    stringType0.unboxesTo();
    assertFalse(stringType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isConstructor() {
    return false;
}","public void test01986() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isNominalConstructor();
    assertFalse(booleanType0.isConstructor());
}","/**
 * Whether this type is a {@link FunctionType} that is a constructor or a
 * named type that points to such a type.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test01987() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isNominalConstructor();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test01988() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isNominalConstructor();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isInterface() {
    return false;
}","public void test01989() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isNominalConstructor();
    assertFalse(booleanType0.isInterface());
}","/**
 * Whether this type is a {@link FunctionType} that is an interface or a named
 * type that points to such a type.
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test01990() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isNominalConstructor();
    assertFalse(boolean0);
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test01991() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isNominalConstructor();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test02092() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isArrayType();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test02093() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isArrayType();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test02094() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isArrayType();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isArrayType() {
    return false;
}","public void test02095() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isArrayType();
    assertFalse(boolean0);
}",""
"public boolean setValidator(Predicate<JSType> validator) {
    return validator.apply(this);
}","public void test02196() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    // Undeclared exception!
    try {
        booleanType0.setValidator((Predicate<JSType>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.JSType"", e);
    }
}","/**
 * Certain types have constraints on them at resolution-time.
 * For example, a type in an {@code @extends} annotation must be an
 * object. Clients should inject a validator that emits a warning
 * if the type does not validate, and return false.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test02297() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isBooleanValueType();
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isBooleanValueType() {
    return false;
}","public void test02298() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isBooleanValueType();
    assertFalse(boolean0);
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test02399() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canBeCalled();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean canBeCalled() {
    return false;
}","public void test023100() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canBeCalled();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can be used as the
 * 'function' in a function call.
 *
 * @return {@code true} if this type might be callable.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test023101() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canBeCalled();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test023102() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canBeCalled();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test024103() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    arrowType0.getDisplayName();
    assertFalse(arrowType0.isNoResolvedType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test024104() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    arrowType0.getDisplayName();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test024105() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    arrowType0.getDisplayName();
    assertFalse(arrowType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test024106() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    arrowType0.getDisplayName();
    assertFalse(arrowType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test025107() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.isNumber();
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test026108() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Not declared as a type name"", 1, 0);
    boolean boolean0 = namedType0.isOrdinaryFunction();
    assertFalse(namedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean isNoObjectType() {
    return referencedType.isNoObjectType();
}","public void test026109() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Not declared as a type name"", 1, 0);
    boolean boolean0 = namedType0.isOrdinaryFunction();
    assertFalse(namedType0.isNoObjectType());
}",""
"@Override
public boolean isNoResolvedType() {
    return referencedType.isNoResolvedType();
}","public void test026110() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Not declared as a type name"", 1, 0);
    boolean boolean0 = namedType0.isOrdinaryFunction();
    assertFalse(namedType0.isNoResolvedType());
}",""
"@Override
public boolean isOrdinaryFunction() {
    return referencedType.isOrdinaryFunction();
}","public void test026111() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Not declared as a type name"", 1, 0);
    boolean boolean0 = namedType0.isOrdinaryFunction();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test027112() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ObjectType objectType0 = noResolvedType0.dereference();
    assertFalse(objectType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test028113() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) booleanType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.isNamedType();
    assertFalse(instanceObjectType0.isNoResolvedType());
}",""
"boolean isNamedType() {
    return false;
}","public void test028114() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) booleanType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.isNamedType();
    assertFalse(boolean0);
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test028115() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) booleanType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.isNamedType();
    assertFalse(instanceObjectType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test028116() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) booleanType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.isNamedType();
    assertFalse(instanceObjectType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test029117() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    booleanType0.matchConstraint(enumType0);
    assertFalse(enumType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test029118() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    booleanType0.matchConstraint(enumType0);
    assertFalse(enumType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test029119() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    booleanType0.matchConstraint(enumType0);
    assertFalse(enumType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test029120() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    booleanType0.matchConstraint(enumType0);
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test030121() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.matchesInt32Context();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test030122() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.matchesInt32Context();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test030123() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.matchesInt32Context();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test031124() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.hasProperty(""'"");
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean hasProperty(String pname) {
    return false;
}","public void test031125() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.hasProperty(""'"");
    assertFalse(boolean0);
}","/**
 * Checks whether the property pname is present on the object.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test031126() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.hasProperty(""'"");
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test031127() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.hasProperty(""'"");
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test032128() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isInstanceType();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isInstanceType() {
    return false;
}","public void test032129() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isInstanceType();
    assertFalse(boolean0);
}","/**
 * Whether this type is an Instance object of some constructor.
 * Does not necessarily mean this is an {@link InstanceObjectType}.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test032130() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isInstanceType();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test032131() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isInstanceType();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test033132() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.isCheckedUnknownType();
    assertFalse(errorFunctionType0.isNoResolvedType());
}",""
"public boolean isCheckedUnknownType() {
    return false;
}","public void test033133() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.isCheckedUnknownType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test033134() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.isCheckedUnknownType();
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test033135() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.isCheckedUnknownType();
    assertFalse(errorFunctionType0.isNoObjectType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test033136() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.isCheckedUnknownType();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"boolean isTheObjectType() {
    return false;
}","public void test034137() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isTheObjectType();
    assertFalse(boolean0);
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test034138() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isTheObjectType();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test034139() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isTheObjectType();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test034140() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isTheObjectType();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test035141() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.matchesUint32Context();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test035142() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.matchesUint32Context();
    assertFalse(arrowType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test035143() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.matchesUint32Context();
    assertFalse(arrowType0.isNoObjectType());
}",""
"public final boolean matchesUint32Context() {
    return matchesNumberContext();
}","public void test035144() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.matchesUint32Context();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in a
 * 'Uint32' context.  This context includes the right-hand operand of a shift
 * operator.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test035145() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.matchesUint32Context();
    assertFalse(arrowType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test036146() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isEnumType();
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isEnumType() {
    return toMaybeEnumType() != null;
}","public void test036147() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isEnumType();
    assertFalse(boolean0);
}",""
"@Override
public boolean isNoResolvedType() {
    return referencedType.isNoResolvedType();
}","public void test037148() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Unknown class name"", 0, 1);
    boolean boolean0 = namedType0.isInvariant(booleanType0);
    assertFalse(namedType0.isNoResolvedType());
}",""
"@Override
public boolean isNoObjectType() {
    return referencedType.isNoObjectType();
}","public void test037149() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Unknown class name"", 0, 1);
    boolean boolean0 = namedType0.isInvariant(booleanType0);
    assertFalse(namedType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test037150() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Unknown class name"", 0, 1);
    boolean boolean0 = namedType0.isInvariant(booleanType0);
    assertFalse(namedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isInvariant(JSType that) {
    return checkEquivalenceHelper(that, false);
}","public void test037151() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Unknown class name"", 0, 1);
    boolean boolean0 = namedType0.isInvariant(booleanType0);
    assertFalse(boolean0);
}","/**
 * Checks if two types are invariant.
 * @see EquivalenceMethod
 */"
"public boolean isNumberValueType() {
    return false;
}","public void test038152() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.isNumberValueType();
    assertFalse(boolean0);
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test038153() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.isNumberValueType();
    assertFalse(voidType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test038154() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.isNumberValueType();
    assertFalse(voidType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test038155() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.isNumberValueType();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test039156() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, errorFunctionType0);
    instanceObjectType0.forceResolve(simpleErrorReporter0, errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test039157() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, errorFunctionType0);
    instanceObjectType0.forceResolve(simpleErrorReporter0, errorFunctionType0);
    assertFalse(errorFunctionType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test040158() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.clearResolved();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test040159() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.clearResolved();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test040160() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.clearResolved();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test041161() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isFunctionPrototypeType();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isFunctionPrototypeType() {
    return false;
}","public void test041162() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isFunctionPrototypeType();
    assertFalse(boolean0);
}","/**
 * Whether this is the prototype of a function.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test041163() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isFunctionPrototypeType();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test041164() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isFunctionPrototypeType();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test042165() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    String string0 = jSType0.toString();
    assertFalse(jSType0.isNoObjectType());
}",""
"@Override
public String toString() {
    return toStringHelper(false);
}","public void test042166() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    String string0 = jSType0.toString();
    assertEquals(""(boolean|null)"", string0);
}","/**
 * A string representation of this type, suitable for printing
 * in warnings.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test042167() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    String string0 = jSType0.toString();
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test042168() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    String string0 = jSType0.toString();
    assertFalse(jSType0.isNoResolvedType());
}",""
"public boolean hasDisplayName() {
    String displayName = getDisplayName();
    return displayName != null && !displayName.isEmpty();
}","public void test043169() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.hasDisplayName();
    assertFalse(boolean0);
}","/**
 * @return true if the JSType has a user meaningful label.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test043170() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.hasDisplayName();
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test044171() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isNoResolvedType());
}",""
"public boolean hasDisplayName() {
    String displayName = getDisplayName();
    return displayName != null && !displayName.isEmpty();
}","public void test044172() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(boolean0);
}","/**
 * @return true if the JSType has a user meaningful label.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test044173() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isNoObjectType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test044174() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test044175() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test045176() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test045177() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isNoResolvedType());
}",""
"public boolean hasDisplayName() {
    String displayName = getDisplayName();
    return displayName != null && !displayName.isEmpty();
}","public void test045178() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertTrue(boolean0);
}","/**
 * @return true if the JSType has a user meaningful label.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test045179() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test045180() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isNoObjectType());
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test046181() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, ""q^:[[>,}BYm<8"", noType0, false);
    JSType[] jSTypeArray0 = new JSType[4];
    jSTypeArray0[0] = (JSType) noType0;
    jSTypeArray0[1] = (JSType) prototypeObjectType0;
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) prototypeObjectType0, jSTypeArray0);
    JSType jSType0 = JSType.getLeastSupertype((JSType) functionType0, jSTypeArray0[0]);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""Not declared as a constructor"");
    jSTypeArray0[1].getGreatestSubtype(enumElementType0);
    assertTrue(prototypeObjectType0.hasCachedValues());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test047182() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    ErrorFunctionType errorFunctionType1 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    boolean boolean0 = errorFunctionType1.canTestForShallowEqualityWith(errorFunctionType0);
    assertFalse(errorFunctionType1.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test047183() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    ErrorFunctionType errorFunctionType1 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    boolean boolean0 = errorFunctionType1.canTestForShallowEqualityWith(errorFunctionType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test047184() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    ErrorFunctionType errorFunctionType1 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    boolean boolean0 = errorFunctionType1.canTestForShallowEqualityWith(errorFunctionType0);
    assertFalse(errorFunctionType1.isNoResolvedType());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test047185() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    ErrorFunctionType errorFunctionType1 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    boolean boolean0 = errorFunctionType1.canTestForShallowEqualityWith(errorFunctionType0);
    assertFalse(errorFunctionType1.equals((Object) errorFunctionType0));
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test047186() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    ErrorFunctionType errorFunctionType1 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    boolean boolean0 = errorFunctionType1.canTestForShallowEqualityWith(errorFunctionType0);
    assertFalse(errorFunctionType1.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test048187() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isStruct();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test048188() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isStruct();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isStruct() {
    if (isObject()) {
        FunctionType ctor = toObjectType().getConstructor();
        // getConstructor can return an *interface* type, so it's not safe to
        // assume that makesStructs is only called on constructors.
        return ctor != null && ctor.makesStructs();
    }
    return false;
}","public void test048189() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isStruct();
    assertFalse(boolean0);
}","/**
 * Returns true iff {@code this} can be a {@code struct}.
 * UnionType overrides the method, assume {@code this} is not a union here.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test048190() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isStruct();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test049191() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = numberType0.autoboxesTo();
    boolean boolean0 = jSType0.isStruct();
    assertFalse(jSType0.isNoObjectType());
}",""
"public boolean isStruct() {
    if (isObject()) {
        FunctionType ctor = toObjectType().getConstructor();
        // getConstructor can return an *interface* type, so it's not safe to
        // assume that makesStructs is only called on constructors.
        return ctor != null && ctor.makesStructs();
    }
    return false;
}","public void test049192() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = numberType0.autoboxesTo();
    boolean boolean0 = jSType0.isStruct();
    assertFalse(boolean0);
}","/**
 * Returns true iff {@code this} can be a {@code struct}.
 * UnionType overrides the method, assume {@code this} is not a union here.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test049193() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = numberType0.autoboxesTo();
    boolean boolean0 = jSType0.isStruct();
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test049194() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = numberType0.autoboxesTo();
    boolean boolean0 = jSType0.isStruct();
    assertFalse(jSType0.isNoResolvedType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test050195() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""2vhARH(dUDsX%go&`"");
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) errorFunctionType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    boolean boolean0 = enumElementType0.isStruct();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test050196() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""2vhARH(dUDsX%go&`"");
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) errorFunctionType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    boolean boolean0 = enumElementType0.isStruct();
    assertFalse(enumElementType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test050197() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""2vhARH(dUDsX%go&`"");
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) errorFunctionType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    boolean boolean0 = enumElementType0.isStruct();
    assertFalse(enumElementType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test050198() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""2vhARH(dUDsX%go&`"");
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) errorFunctionType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    boolean boolean0 = enumElementType0.isStruct();
    assertFalse(enumElementType0.isNoObjectType());
}",""
"public boolean isStruct() {
    if (isObject()) {
        FunctionType ctor = toObjectType().getConstructor();
        // getConstructor can return an *interface* type, so it's not safe to
        // assume that makesStructs is only called on constructors.
        return ctor != null && ctor.makesStructs();
    }
    return false;
}","public void test050199() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""2vhARH(dUDsX%go&`"");
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) errorFunctionType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    boolean boolean0 = enumElementType0.isStruct();
    assertFalse(boolean0);
}","/**
 * Returns true iff {@code this} can be a {@code struct}.
 * UnionType overrides the method, assume {@code this} is not a union here.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test051200() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isDict();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isDict() {
    if (isObject()) {
        FunctionType ctor = toObjectType().getConstructor();
        return ctor != null && ctor.makesDicts();
    }
    return false;
}","public void test051201() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isDict();
    assertFalse(boolean0);
}","/**
 * Returns true iff {@code this} can be a {@code dict}.
 * UnionType overrides the method, assume {@code this} is not a union here.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test051202() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isDict();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test051203() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isDict();
    assertFalse(booleanType0.isNoObjectType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test052204() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noObjectType0, false);
    boolean boolean0 = instanceObjectType0.isDict();
    assertTrue(noObjectType0.hasCachedValues());
}",""
"public boolean isDict() {
    if (isObject()) {
        FunctionType ctor = toObjectType().getConstructor();
        return ctor != null && ctor.makesDicts();
    }
    return false;
}","public void test052205() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noObjectType0, false);
    boolean boolean0 = instanceObjectType0.isDict();
    assertFalse(boolean0);
}","/**
 * Returns true iff {@code this} can be a {@code dict}.
 * UnionType overrides the method, assume {@code this} is not a union here.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test053206() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isDict();
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isDict() {
    if (isObject()) {
        FunctionType ctor = toObjectType().getConstructor();
        return ctor != null && ctor.makesDicts();
    }
    return false;
}","public void test053207() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isDict();
    assertFalse(boolean0);
}","/**
 * Returns true iff {@code this} can be a {@code dict}.
 * UnionType overrides the method, assume {@code this} is not a union here.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test054208() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    noObjectType0.setDict();
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noObjectType0, false);
    boolean boolean0 = instanceObjectType0.isDict();
    assertFalse(instanceObjectType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test054209() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    noObjectType0.setDict();
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noObjectType0, false);
    boolean boolean0 = instanceObjectType0.isDict();
    assertFalse(instanceObjectType0.isNoObjectType());
}",""
"public boolean isDict() {
    if (isObject()) {
        FunctionType ctor = toObjectType().getConstructor();
        return ctor != null && ctor.makesDicts();
    }
    return false;
}","public void test054210() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    noObjectType0.setDict();
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noObjectType0, false);
    boolean boolean0 = instanceObjectType0.isDict();
    assertTrue(boolean0);
}","/**
 * Returns true iff {@code this} can be a {@code dict}.
 * UnionType overrides the method, assume {@code this} is not a union here.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test054211() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    noObjectType0.setDict();
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noObjectType0, false);
    boolean boolean0 = instanceObjectType0.isDict();
    assertFalse(instanceObjectType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test055212() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    boolean boolean0 = numberType0.isGlobalThisType();
    assertFalse(numberType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test055213() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    boolean boolean0 = numberType0.isGlobalThisType();
    assertFalse(numberType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test055214() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    boolean boolean0 = numberType0.isGlobalThisType();
    assertFalse(numberType0.isNoResolvedType());
}",""
"public final boolean isGlobalThisType() {
    return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS);
}","public void test055215() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    boolean boolean0 = numberType0.isGlobalThisType();
    assertFalse(boolean0);
}","/**
 * Returns true if this is a global this type.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test056216() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    FunctionType functionType0 = JSType.toMaybeFunctionType((JSType) errorFunctionType0);
    assertFalse(functionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test056217() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    FunctionType functionType0 = JSType.toMaybeFunctionType((JSType) errorFunctionType0);
    assertFalse(functionType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test056218() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    FunctionType functionType0 = JSType.toMaybeFunctionType((JSType) errorFunctionType0);
    assertFalse(functionType0.isNoResolvedType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test056219() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    FunctionType functionType0 = JSType.toMaybeFunctionType((JSType) errorFunctionType0);
    assertTrue(functionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public static FunctionType toMaybeFunctionType(JSType type) {
    return type == null ? null : type.toMaybeFunctionType();
}","public void test056220() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    FunctionType functionType0 = JSType.toMaybeFunctionType((JSType) errorFunctionType0);
    assertNotNull(functionType0);
}","/**
 * Null-safe version of toMaybeFunctionType().
 */"
"public static FunctionType toMaybeFunctionType(JSType type) {
    return type == null ? null : type.toMaybeFunctionType();
}","public void test057221() throws Throwable {
    FunctionType functionType0 = JSType.toMaybeFunctionType((JSType) null);
    assertNull(functionType0);
}","/**
 * Null-safe version of toMaybeFunctionType().
 */"
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test058222() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, true);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, recordType0, booleanType0);
    parameterizedType0.getGreatestSubtype(booleanType0);
    assertTrue(recordType0.hasCachedValues());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test058223() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, true);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, recordType0, booleanType0);
    parameterizedType0.getGreatestSubtype(booleanType0);
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test059224() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", (String) null, (-967), 40);
    boolean boolean0 = namedType0.isParameterizedType();
    assertFalse(namedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean isNoObjectType() {
    return referencedType.isNoObjectType();
}","public void test059225() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", (String) null, (-967), 40);
    boolean boolean0 = namedType0.isParameterizedType();
    assertFalse(namedType0.isNoObjectType());
}",""
"@Override
public boolean isNoResolvedType() {
    return referencedType.isNoResolvedType();
}","public void test059226() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", (String) null, (-967), 40);
    boolean boolean0 = namedType0.isParameterizedType();
    assertFalse(namedType0.isNoResolvedType());
}",""
"public final boolean isParameterizedType() {
    return toMaybeParameterizedType() != null;
}","public void test059227() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", (String) null, (-967), 40);
    boolean boolean0 = namedType0.isParameterizedType();
    assertFalse(boolean0);
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test060228() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    boolean boolean0 = parameterizedType0.isParameterizedType();
    assertFalse(enumType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test060229() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    boolean boolean0 = parameterizedType0.isParameterizedType();
    assertFalse(parameterizedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test060230() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    boolean boolean0 = parameterizedType0.isParameterizedType();
    assertFalse(enumType0.isNoResolvedType());
}",""
"public final boolean isParameterizedType() {
    return toMaybeParameterizedType() != null;
}","public void test060231() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    boolean boolean0 = parameterizedType0.isParameterizedType();
    assertTrue(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test061232() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType.toMaybeParameterizedType((JSType) noResolvedType0);
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public static ParameterizedType toMaybeParameterizedType(JSType type) {
    return type == null ? null : type.toMaybeParameterizedType();
}","public void test062233() throws Throwable {
    ParameterizedType parameterizedType0 = JSType.toMaybeParameterizedType((JSType) null);
    assertNull(parameterizedType0);
}","/**
 * Null-safe version of toMaybeParameterizedType().
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test063234() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(templateType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isTemplateType() {
    return toMaybeTemplateType() != null;
}","public void test063235() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(templateType0);
    assertTrue(templateType0.isTemplateType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test064236() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) noResolvedType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    JSType.toMaybeTemplateType((JSType) enumElementType0);
    assertFalse(enumElementType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test064237() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) noResolvedType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    JSType.toMaybeTemplateType((JSType) enumElementType0);
    assertFalse(enumElementType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test064238() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) noResolvedType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    JSType.toMaybeTemplateType((JSType) enumElementType0);
    assertFalse(enumElementType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test064239() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) noResolvedType0, ""Not declared as a constructor"", "".Rt+28OS e]&~w1L"", (-2520), 51);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""B XP(`)J|"");
    JSType.toMaybeTemplateType((JSType) enumElementType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public static TemplateType toMaybeTemplateType(JSType type) {
    return type == null ? null : type.toMaybeTemplateType();
}","public void test065240() throws Throwable {
    JSType[] jSTypeArray0 = new JSType[4];
    TemplateType templateType0 = JSType.toMaybeTemplateType(jSTypeArray0[0]);
    assertNull(templateType0);
}","/**
 * Null-safe version of toMaybeTemplateType().
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test066241() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(noObjectType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test066242() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(noObjectType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test066243() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(noObjectType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test067244() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isNominalConstructor();
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test067245() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isNominalConstructor();
    assertFalse(boolean0);
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test068246() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""<nQ?:rv"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertFalse(functionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test068247() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""<nQ?:rv"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertFalse(functionType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test068248() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""<nQ?:rv"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertFalse(functionType0.isNoResolvedType());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test068249() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""<nQ?:rv"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertFalse(boolean0);
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test068250() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""<nQ?:rv"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertTrue(functionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test069251() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    JSType[] jSTypeArray0 = new JSType[7];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    errorFunctionType0.setSource(node0);
    boolean boolean0 = errorFunctionType0.isNominalConstructor();
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test069252() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    JSType[] jSTypeArray0 = new JSType[7];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    errorFunctionType0.setSource(node0);
    boolean boolean0 = errorFunctionType0.isNominalConstructor();
    assertFalse(errorFunctionType0.isNoObjectType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test069253() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    JSType[] jSTypeArray0 = new JSType[7];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    errorFunctionType0.setSource(node0);
    boolean boolean0 = errorFunctionType0.isNominalConstructor();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test069254() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    JSType[] jSTypeArray0 = new JSType[7];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    errorFunctionType0.setSource(node0);
    boolean boolean0 = errorFunctionType0.isNominalConstructor();
    assertFalse(errorFunctionType0.isNoResolvedType());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test069255() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    JSType[] jSTypeArray0 = new JSType[7];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    errorFunctionType0.setSource(node0);
    boolean boolean0 = errorFunctionType0.isNominalConstructor();
    assertTrue(boolean0);
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test070256() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 1, 1);
    boolean boolean0 = namedType0.differsFrom(booleanType0);
    assertFalse(namedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean isNoResolvedType() {
    return referencedType.isNoResolvedType();
}","public void test070257() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 1, 1);
    boolean boolean0 = namedType0.differsFrom(booleanType0);
    assertFalse(namedType0.isNoResolvedType());
}",""
"public final boolean differsFrom(JSType that) {
    return !checkEquivalenceHelper(that, true);
}","public void test070258() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 1, 1);
    boolean boolean0 = namedType0.differsFrom(booleanType0);
    assertTrue(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type for
 * the purposes of data flow analysis.
 *
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types. See {@code EquivalenceMethod} for more info.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"@Override
public boolean isNoObjectType() {
    return referencedType.isNoObjectType();
}","public void test070259() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 1, 1);
    boolean boolean0 = namedType0.differsFrom(booleanType0);
    assertFalse(namedType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test071260() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 0, 1);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.differsFrom(namedType0);
    assertFalse(arrowType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test071261() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 0, 1);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.differsFrom(namedType0);
    assertFalse(arrowType0.isNoObjectType());
}",""
"public final boolean differsFrom(JSType that) {
    return !checkEquivalenceHelper(that, true);
}","public void test071262() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 0, 1);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.differsFrom(namedType0);
    assertTrue(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type for
 * the purposes of data flow analysis.
 *
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types. See {@code EquivalenceMethod} for more info.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test071263() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 0, 1);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.differsFrom(namedType0);
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test071264() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 0, 1);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.differsFrom(namedType0);
    assertFalse(arrowType0.isNoResolvedType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test072265() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 0, 1);
    JSType jSType0 = booleanType0.getGreatestSubtype(namedType0);
    boolean boolean0 = namedType0.differsFrom(jSType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test072266() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 0, 1);
    JSType jSType0 = booleanType0.getGreatestSubtype(namedType0);
    boolean boolean0 = namedType0.differsFrom(jSType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean differsFrom(JSType that) {
    return !checkEquivalenceHelper(that, true);
}","public void test072267() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 0, 1);
    JSType jSType0 = booleanType0.getGreatestSubtype(namedType0);
    boolean boolean0 = namedType0.differsFrom(jSType0);
    assertFalse(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type for
 * the purposes of data flow analysis.
 *
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types. See {@code EquivalenceMethod} for more info.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test072268() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Not declared as a type name"", 0, 1);
    JSType jSType0 = booleanType0.getGreatestSubtype(namedType0);
    boolean boolean0 = namedType0.differsFrom(jSType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"final boolean isImplicitPrototype(ObjectType prototype) {
    for (ObjectType current = this; current != null; current = current.getImplicitPrototype()) {
        if (current.isEquivalentTo(prototype)) {
            return true;
        }
    }
    return false;
}","public void test073269() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Unknown class name"", 1, 1);
    UnknownType unknownType0 = (UnknownType) numberType0.getGreatestSubtype(namedType0);
    boolean boolean0 = unknownType0.isImplicitPrototype(namedType0);
    assertFalse(boolean0);
}","/**
 * Checks that the prototype is an implicit prototype of this object. Since
 * each object has an implicit prototype, an implicit prototype's
 * implicit prototype is also this implicit prototype's.
 *
 * @param prototype any prototype based object
 *
 * @return {@code true} if {@code prototype} is {@code equal} to any
 *         object in this object's implicit prototype chain.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test073270() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Unknown class name"", 1, 1);
    UnknownType unknownType0 = (UnknownType) numberType0.getGreatestSubtype(namedType0);
    boolean boolean0 = unknownType0.isImplicitPrototype(namedType0);
    assertFalse(unknownType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test073271() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Unknown class name"", 1, 1);
    UnknownType unknownType0 = (UnknownType) numberType0.getGreatestSubtype(namedType0);
    boolean boolean0 = unknownType0.isImplicitPrototype(namedType0);
    assertFalse(unknownType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test073272() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Named type with empty name component"", ""Unknown class name"", 1, 1);
    UnknownType unknownType0 = (UnknownType) numberType0.getGreatestSubtype(namedType0);
    boolean boolean0 = unknownType0.isImplicitPrototype(namedType0);
    assertFalse(unknownType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test074273() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, templateType0, templateType0);
    JSType jSType0 = templateType0.getGreatestSubtype(parameterizedType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test074274() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, templateType0, templateType0);
    JSType jSType0 = templateType0.getGreatestSubtype(parameterizedType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test074275() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, templateType0, templateType0);
    JSType jSType0 = templateType0.getGreatestSubtype(parameterizedType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test075276() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Named type with empty name component"");
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(enumElementType0);
    JSType jSType1 = jSType0.getGreatestSubtype(booleanType0);
    assertFalse(jSType1.isNoResolvedType());
}",""
"public final boolean isUnionType() {
    return toMaybeUnionType() != null;
}","public void test075277() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Named type with empty name component"");
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(enumElementType0);
    JSType jSType1 = jSType0.getGreatestSubtype(booleanType0);
    assertTrue(jSType0.isUnionType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test075278() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Named type with empty name component"");
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(enumElementType0);
    JSType jSType1 = jSType0.getGreatestSubtype(booleanType0);
    assertFalse(jSType1.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test075279() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Named type with empty name component"");
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(enumElementType0);
    JSType jSType1 = jSType0.getGreatestSubtype(booleanType0);
    assertFalse(jSType1.isNoObjectType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test076280() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(voidType0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType.TypePair jSType_TypePair0 = noResolvedType0.getTypesUnderShallowInequality(jSType0);
    JSType jSType1 = jSType0.getLeastSupertype(jSType_TypePair0.typeB);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"public JSType getLeastSupertype(JSType that) {
    if (that.isUnionType()) {
        // Union types have their own implementation of getLeastSupertype.
        return that.toMaybeUnionType().getLeastSupertype(this);
    }
    return getLeastSupertype(this, that);
}","public void test076281() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(voidType0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType.TypePair jSType_TypePair0 = noResolvedType0.getTypesUnderShallowInequality(jSType0);
    JSType jSType1 = jSType0.getLeastSupertype(jSType_TypePair0.typeB);
    assertSame(jSType0, jSType1);
}","/**
 * Gets the least supertype of {@code this} and {@code that}.
 * The least supertype is the join (&#8744;) or supremum of both types in the
 * type lattice.<p>
 * Examples:
 * <ul>
 * <li>{@code number &#8744; *} = {@code *}</li>
 * <li>{@code number &#8744; Object} = {@code (number, Object)}</li>
 * <li>{@code Number &#8744; Object} = {@code Object}</li>
 * </ul>
 * @return {@code this &#8744; that}
 */"
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test077282() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, recordType0);
    proxyObjectType0.getTypesUnderShallowEquality(recordType0);
    assertTrue(recordType0.hasCachedValues());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test077283() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, recordType0);
    proxyObjectType0.getTypesUnderShallowEquality(recordType0);
    assertFalse(recordType0.isNoResolvedType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test079284() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(errorFunctionType0, booleanType0);
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.differsFrom(parameterizedType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean differsFrom(JSType that) {
    return !checkEquivalenceHelper(that, true);
}","public void test079285() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(errorFunctionType0, booleanType0);
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.differsFrom(parameterizedType0);
    assertTrue(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type for
 * the purposes of data flow analysis.
 *
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types. See {@code EquivalenceMethod} for more info.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"public static boolean isEquivalent(JSType typeA, JSType typeB) {
    return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB);
}","public void test080286() throws Throwable {
    boolean boolean0 = JSType.isEquivalent((JSType) null, (JSType) null);
    assertTrue(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test081287() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = JSType.isEquivalent(booleanType0, (JSType) null);
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test081288() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = JSType.isEquivalent(booleanType0, (JSType) null);
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public static boolean isEquivalent(JSType typeA, JSType typeB) {
    return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB);
}","public void test081289() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = JSType.isEquivalent(booleanType0, (JSType) null);
    assertFalse(boolean0);
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test081290() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = JSType.isEquivalent(booleanType0, (JSType) null);
    assertFalse(booleanType0.isNoObjectType());
}",""
"public static boolean isEquivalent(JSType typeA, JSType typeB) {
    return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB);
}","public void test082291() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = JSType.isEquivalent(booleanType0, booleanType0);
    assertTrue(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test082292() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = JSType.isEquivalent(booleanType0, booleanType0);
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test082293() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = JSType.isEquivalent(booleanType0, booleanType0);
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test082294() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = JSType.isEquivalent(booleanType0, booleanType0);
    assertFalse(booleanType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test083295() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.equals(simpleErrorReporter0);
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test083296() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.equals(simpleErrorReporter0);
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test083297() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.equals(simpleErrorReporter0);
    assertFalse(booleanType0.isNoResolvedType());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test083298() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.equals(simpleErrorReporter0);
    assertFalse(boolean0);
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test084299() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    booleanType0.equals(numberType0);
    assertFalse(numberType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test084300() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    booleanType0.equals(numberType0);
    assertFalse(numberType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test084301() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    booleanType0.equals(numberType0);
    assertFalse(numberType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test084302() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    booleanType0.equals(numberType0);
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test085303() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.findPropertyType("""");
    assertFalse(booleanType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test085304() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.findPropertyType("""");
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test085305() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.findPropertyType("""");
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean canAssignTo(JSType that) {
    if (this.isSubtype(that)) {
        return true;
    }
    return false;
}","public void test086306() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = numberType0.autoboxesTo();
    boolean boolean0 = jSType0.canAssignTo(numberType0);
    assertFalse(boolean0);
}","/**
 * Tests whether values of {@code this} type can be safely assigned
 * to values of {@code that} type.<p>
 *
 * The default implementation verifies that {@code this} is a subtype
 * of {@code that}.<p>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test086307() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = numberType0.autoboxesTo();
    boolean boolean0 = jSType0.canAssignTo(numberType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test086308() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = numberType0.autoboxesTo();
    boolean boolean0 = jSType0.canAssignTo(numberType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test086309() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = numberType0.autoboxesTo();
    boolean boolean0 = jSType0.canAssignTo(numberType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public boolean hasCachedValues() {
    return !unknown;
}","public void test087310() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Unknown class name"");
    boolean boolean0 = enumElementType0.canAssignTo(booleanType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public boolean canAssignTo(JSType that) {
    if (this.isSubtype(that)) {
        return true;
    }
    return false;
}","public void test087311() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Unknown class name"");
    boolean boolean0 = enumElementType0.canAssignTo(booleanType0);
    assertTrue(boolean0);
}","/**
 * Tests whether values of {@code this} type can be safely assigned
 * to values of {@code that} type.<p>
 *
 * The default implementation verifies that {@code this} is a subtype
 * of {@code that}.<p>
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test088312() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autobox();
    assertFalse(jSType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test088313() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autobox();
    assertFalse(jSType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test088314() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.autobox();
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test089315() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    noResolvedType0.getTypesUnderEquality(instanceObjectType0);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test090316() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    NoType noType0 = (NoType) nullType0.restrictByNotNullOrUndefined();
    booleanType0.testForEqualityHelper(allType0, noType0);
    assertTrue(noType0.hasCachedValues());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test090317() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    NoType noType0 = (NoType) nullType0.restrictByNotNullOrUndefined();
    booleanType0.testForEqualityHelper(allType0, noType0);
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test091318() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, errorFunctionType0);
    instanceObjectType0.getTypesUnderEquality(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test091319() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, errorFunctionType0);
    instanceObjectType0.getTypesUnderEquality(errorFunctionType0);
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test092320() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.getTypesUnderEquality(booleanType0);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test093321() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Unknown class name"");
    NoType noType0 = new NoType(jSTypeRegistry0);
    enumElementType0.getTypesUnderInequality(noType0);
    assertTrue(noType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test094322() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    noObjectType0.getTypesUnderEquality(numberType0);
    assertTrue(noObjectType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test095323() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.canTestForEqualityWith(booleanType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean canTestForEqualityWith(JSType that) {
    return this.testForEquality(that).equals(UNKNOWN);
}","public void test095324() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.canTestForEqualityWith(booleanType0);
    assertFalse(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable. By meaningfully, we mean compatible types that do not lead
 * to step 22 of the definition of the Abstract Equality Comparison
 * Algorithm (11.9.3, page 55&ndash;56) of the ECMA-262 specification.<p>
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test096325() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, errorFunctionType0);
    instanceObjectType0.getTypesUnderEquality(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test096326() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, errorFunctionType0);
    instanceObjectType0.getTypesUnderEquality(errorFunctionType0);
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test097327() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, ""q^:[[>,}BYm<8"", noType0, false);
    JSType[] jSTypeArray0 = new JSType[4];
    jSTypeArray0[2] = (JSType) prototypeObjectType0;
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) prototypeObjectType0, jSTypeArray0);
    boolean boolean0 = functionType0.canTestForEqualityWith(jSTypeArray0[2]);
    assertTrue(functionType0.hasCachedValues());
}",""
"public final boolean canTestForEqualityWith(JSType that) {
    return this.testForEquality(that).equals(UNKNOWN);
}","public void test097328() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, ""q^:[[>,}BYm<8"", noType0, false);
    JSType[] jSTypeArray0 = new JSType[4];
    jSTypeArray0[2] = (JSType) prototypeObjectType0;
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) prototypeObjectType0, jSTypeArray0);
    boolean boolean0 = functionType0.canTestForEqualityWith(jSTypeArray0[2]);
    assertFalse(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable. By meaningfully, we mean compatible types that do not lead
 * to step 22 of the definition of the Abstract Equality Comparison
 * Algorithm (11.9.3, page 55&ndash;56) of the ECMA-262 specification.<p>
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test098329() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Named type with empty name component"");
    enumElementType0.getTypesUnderInequality(jSType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public final boolean canTestForEqualityWith(JSType that) {
    return this.testForEquality(that).equals(UNKNOWN);
}","public void test099330() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalNullableType(booleanType0);
    boolean boolean0 = booleanType0.canTestForEqualityWith(jSType0);
    assertFalse(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable. By meaningfully, we mean compatible types that do not lead
 * to step 22 of the definition of the Abstract Equality Comparison
 * Algorithm (11.9.3, page 55&ndash;56) of the ECMA-262 specification.<p>
 */"
"public final boolean isUnionType() {
    return toMaybeUnionType() != null;
}","public void test099331() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalNullableType(booleanType0);
    boolean boolean0 = booleanType0.canTestForEqualityWith(jSType0);
    assertTrue(jSType0.isUnionType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test099332() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalNullableType(booleanType0);
    boolean boolean0 = booleanType0.canTestForEqualityWith(jSType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test100333() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = noResolvedType0.canTestForShallowEqualityWith(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test100334() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = noResolvedType0.canTestForShallowEqualityWith(errorFunctionType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test101335() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(noType0);
    assertTrue(noType0.hasCachedValues());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test101336() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(noType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test102337() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    boolean boolean0 = noObjectType0.canTestForShallowEqualityWith(booleanType0);
    assertTrue(noObjectType0.hasCachedValues());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test102338() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    boolean boolean0 = noObjectType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test103339() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    boolean boolean0 = enumType0.canTestForShallowEqualityWith(parameterizedType0);
    assertFalse(enumType0.isNoResolvedType());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test103340() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    boolean boolean0 = enumType0.canTestForShallowEqualityWith(parameterizedType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test103341() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    boolean boolean0 = enumType0.canTestForShallowEqualityWith(parameterizedType0);
    assertFalse(enumType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test103342() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    boolean boolean0 = enumType0.canTestForShallowEqualityWith(parameterizedType0);
    assertFalse(parameterizedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test104343() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(""Not declared as a type name"");
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Unknown class name"", node0, booleanType0);
    boolean boolean0 = enumType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test104344() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(""Not declared as a type name"");
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Unknown class name"", node0, booleanType0);
    boolean boolean0 = enumType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(enumType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test104345() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(""Not declared as a type name"");
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Unknown class name"", node0, booleanType0);
    boolean boolean0 = enumType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(enumType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test104346() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(""Not declared as a type name"");
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Unknown class name"", node0, booleanType0);
    boolean boolean0 = enumType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(enumType0.isNoObjectType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test105347() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getLeastSupertype(noResolvedType0);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test105348() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getLeastSupertype(noResolvedType0);
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public JSType getLeastSupertype(JSType that) {
    if (that.isUnionType()) {
        // Union types have their own implementation of getLeastSupertype.
        return that.toMaybeUnionType().getLeastSupertype(this);
    }
    return getLeastSupertype(this, that);
}","public void test106349() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(booleanType0);
    JSType jSType1 = booleanType0.getLeastSupertype(jSType0);
    assertSame(jSType1, jSType0);
}","/**
 * Gets the least supertype of {@code this} and {@code that}.
 * The least supertype is the join (&#8744;) or supremum of both types in the
 * type lattice.<p>
 * Examples:
 * <ul>
 * <li>{@code number &#8744; *} = {@code *}</li>
 * <li>{@code number &#8744; Object} = {@code (number, Object)}</li>
 * <li>{@code Number &#8744; Object} = {@code Object}</li>
 * </ul>
 * @return {@code this &#8744; that}
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test106350() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(booleanType0);
    JSType jSType1 = booleanType0.getLeastSupertype(jSType0);
    assertFalse(jSType1.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test106351() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(booleanType0);
    JSType jSType1 = booleanType0.getLeastSupertype(jSType0);
    assertFalse(jSType1.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test106352() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(booleanType0);
    JSType jSType1 = booleanType0.getLeastSupertype(jSType0);
    assertFalse(jSType1.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test107353() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    JSType jSType1 = errorFunctionType0.getGreatestSubtype(jSType0);
    assertFalse(errorFunctionType0.isNoObjectType());
}",""
"public final boolean isUnionType() {
    return toMaybeUnionType() != null;
}","public void test107354() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    JSType jSType1 = errorFunctionType0.getGreatestSubtype(jSType0);
    assertTrue(jSType0.isUnionType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test107355() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    JSType jSType1 = errorFunctionType0.getGreatestSubtype(jSType0);
    assertFalse(jSType1.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test107356() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    JSType jSType1 = errorFunctionType0.getGreatestSubtype(jSType0);
    assertFalse(jSType1.isNoResolvedType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test107357() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    JSType jSType1 = errorFunctionType0.getGreatestSubtype(jSType0);
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isRecordType() {
    return toMaybeRecordType() != null;
}","public void test108358() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType0 = booleanType0.getGreatestSubtype(recordType0);
    assertTrue(recordType0.isRecordType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test108359() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType0 = booleanType0.getGreatestSubtype(recordType0);
    assertFalse(recordType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test108360() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType0 = booleanType0.getGreatestSubtype(recordType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test108361() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType0 = booleanType0.getGreatestSubtype(recordType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isEnumElementType() {
    return toMaybeEnumElementType() != null;
}","public void test109362() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""?2u$d&Z2pxUfhK+YA"");
    Node node0 = Node.newNumber(4480.551518101, 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Named type with empty name component"", node0, booleanType0);
    EnumElementType enumElementType1 = enumType0.getElementsType();
    enumElementType1.getTypesUnderShallowEquality(enumElementType0);
    assertTrue(enumElementType1.isEnumElementType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test109363() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""?2u$d&Z2pxUfhK+YA"");
    Node node0 = Node.newNumber(4480.551518101, 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Named type with empty name component"", node0, booleanType0);
    EnumElementType enumElementType1 = enumType0.getElementsType();
    enumElementType1.getTypesUnderShallowEquality(enumElementType0);
    assertFalse(enumElementType1.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test109364() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""?2u$d&Z2pxUfhK+YA"");
    Node node0 = Node.newNumber(4480.551518101, 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Named type with empty name component"", node0, booleanType0);
    EnumElementType enumElementType1 = enumType0.getElementsType();
    enumElementType1.getTypesUnderShallowEquality(enumElementType0);
    assertFalse(enumElementType1.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test109365() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""?2u$d&Z2pxUfhK+YA"");
    Node node0 = Node.newNumber(4480.551518101, 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Named type with empty name component"", node0, booleanType0);
    EnumElementType enumElementType1 = enumType0.getElementsType();
    enumElementType1.getTypesUnderShallowEquality(enumElementType0);
    assertFalse(enumElementType1.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test110366() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newString(""Invalid padding: %s"");
    AllType allType0 = new AllType(jSTypeRegistry0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, allType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, proxyObjectType0, ""B XP(`)J|"");
    JSType jSType0 = jSTypeRegistry0.createOptionalNullableType(enumElementType0);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Invalid padding: %s"", node0, jSType0);
    JSType jSType1 = enumType0.getGreatestSubtype(enumElementType0);
    assertFalse(enumType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test110367() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newString(""Invalid padding: %s"");
    AllType allType0 = new AllType(jSTypeRegistry0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, allType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, proxyObjectType0, ""B XP(`)J|"");
    JSType jSType0 = jSTypeRegistry0.createOptionalNullableType(enumElementType0);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Invalid padding: %s"", node0, jSType0);
    JSType jSType1 = enumType0.getGreatestSubtype(enumElementType0);
    assertFalse(jSType1.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isEnumElementType() {
    return toMaybeEnumElementType() != null;
}","public void test110368() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newString(""Invalid padding: %s"");
    AllType allType0 = new AllType(jSTypeRegistry0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, allType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, proxyObjectType0, ""B XP(`)J|"");
    JSType jSType0 = jSTypeRegistry0.createOptionalNullableType(enumElementType0);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Invalid padding: %s"", node0, jSType0);
    JSType jSType1 = enumType0.getGreatestSubtype(enumElementType0);
    assertTrue(enumElementType0.isEnumElementType());
}",""
"public JSType getGreatestSubtype(JSType that) {
    return getGreatestSubtype(this, that);
}","public void test110369() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newString(""Invalid padding: %s"");
    AllType allType0 = new AllType(jSTypeRegistry0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, allType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, proxyObjectType0, ""B XP(`)J|"");
    JSType jSType0 = jSTypeRegistry0.createOptionalNullableType(enumElementType0);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Invalid padding: %s"", node0, jSType0);
    JSType jSType1 = enumType0.getGreatestSubtype(enumElementType0);
    assertNotSame(jSType1, enumElementType0);
}","/**
 * Gets the greatest subtype of {@code this} and {@code that}.
 * The greatest subtype is the meet (&#8743;) or infimum of both types in the
 * type lattice.<p>
 * Examples
 * <ul>
 * <li>{@code Number &#8743; Any} = {@code Any}</li>
 * <li>{@code number &#8743; Object} = {@code Any}</li>
 * <li>{@code Number &#8743; Object} = {@code Number}</li>
 * </ul>
 * @return {@code this &#8744; that}
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test110370() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newString(""Invalid padding: %s"");
    AllType allType0 = new AllType(jSTypeRegistry0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, allType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, proxyObjectType0, ""B XP(`)J|"");
    JSType jSType0 = jSTypeRegistry0.createOptionalNullableType(enumElementType0);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Invalid padding: %s"", node0, jSType0);
    JSType jSType1 = enumType0.getGreatestSubtype(enumElementType0);
    assertFalse(enumType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test111371() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    JSType jSType0 = parameterizedType0.getGreatestSubtype(noResolvedType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test112372() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Named type with empty name component"", 0, 0);
    JSType jSType0 = namedType0.getLeastSupertype(booleanType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isUnionType() {
    return toMaybeUnionType() != null;
}","public void test112373() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Named type with empty name component"", 0, 0);
    JSType jSType0 = namedType0.getLeastSupertype(booleanType0);
    assertTrue(jSType0.isUnionType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test112374() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Named type with empty name component"", 0, 0);
    JSType jSType0 = namedType0.getLeastSupertype(booleanType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"@Override
public boolean isNoResolvedType() {
    return referencedType.isNoResolvedType();
}","public void test112375() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Named type with empty name component"", 0, 0);
    JSType jSType0 = namedType0.getLeastSupertype(booleanType0);
    assertFalse(namedType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test113376() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = noResolvedType0.getRestrictedTypeGivenToBooleanOutcome(false);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test113377() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = noResolvedType0.getRestrictedTypeGivenToBooleanOutcome(false);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test114378() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""#xnsWtwRK T{3bd0.{"", ""#xnsWtwRK T{3bd0.{"", (-1700), (-1700));
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = namedType0.resolveInternal(simpleErrorReporter0, noResolvedType0);
    JSType.TypePair jSType_TypePair0 = noResolvedType0.getTypesUnderShallowInequality(jSType0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType_TypePair0.typeB, jSType_TypePair0.typeB);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    unionType0.getRestrictedTypeGivenToBooleanOutcome(true);
    assertTrue(namedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test114379() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""#xnsWtwRK T{3bd0.{"", ""#xnsWtwRK T{3bd0.{"", (-1700), (-1700));
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = namedType0.resolveInternal(simpleErrorReporter0, noResolvedType0);
    JSType.TypePair jSType_TypePair0 = noResolvedType0.getTypesUnderShallowInequality(jSType0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType_TypePair0.typeB, jSType_TypePair0.typeB);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    unionType0.getRestrictedTypeGivenToBooleanOutcome(true);
    assertFalse(unionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test115380() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.getRestrictedTypeGivenToBooleanOutcome(true);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test115381() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.getRestrictedTypeGivenToBooleanOutcome(true);
    assertFalse(jSType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test115382() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = booleanType0.getRestrictedTypeGivenToBooleanOutcome(true);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test116383() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.getTypesUnderEquality(jSType0);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test117384() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) booleanType0.autoboxesTo();
    instanceObjectType0.getTypesUnderEquality(booleanType0);
    assertTrue(instanceObjectType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test118385() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, noObjectType0, noObjectType0);
    noObjectType0.getTypesUnderEquality(parameterizedType0);
    assertTrue(noObjectType0.hasCachedValues());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test119386() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, nullType0, ""Not declared as a constructor"");
    enumElementType0.getTypesUnderInequality(nullType0);
    assertFalse(enumElementType0.isNoObjectType());
}",""
"public boolean hasCachedValues() {
    return !unknown;
}","public void test119387() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, nullType0, ""Not declared as a constructor"");
    enumElementType0.getTypesUnderInequality(nullType0);
    assertFalse(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test119388() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, nullType0, ""Not declared as a constructor"");
    enumElementType0.getTypesUnderInequality(nullType0);
    assertFalse(enumElementType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test119389() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, nullType0, ""Not declared as a constructor"");
    enumElementType0.getTypesUnderInequality(nullType0);
    assertFalse(enumElementType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test120390() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test120391() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isUnionType() {
    return toMaybeUnionType() != null;
}","public void test120392() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertTrue(jSType0.isUnionType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test120393() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test120394() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean isNoObjectType() {
    return referencedType.isNoObjectType();
}","public void test121395() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Named type with empty name component"", 1, 0);
    boolean boolean0 = JSType.isSubtypeHelper(namedType0, namedType0);
    assertFalse(namedType0.isNoObjectType());
}",""
"static boolean isSubtypeHelper(JSType thisType, JSType thatType) {
    // unknown
    if (thatType.isUnknownType()) {
        return true;
    }
    // all type
    if (thatType.isAllType()) {
        return true;
    }
    // equality
    if (thisType.isEquivalentTo(thatType)) {
        return true;
    }
    // unions
    if (thatType.isUnionType()) {
        UnionType union = thatType.toMaybeUnionType();
        for (JSType element : union.alternates) {
            if (thisType.isSubtype(element)) {
                return true;
            }
        }
    }
    // proxy types
    if (thatType instanceof ProxyObjectType) {
        return thisType.isSubtype(((ProxyObjectType) thatType).getReferencedTypeInternal());
    }
    return false;
}","public void test121396() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Named type with empty name component"", 1, 0);
    boolean boolean0 = JSType.isSubtypeHelper(namedType0, namedType0);
    assertTrue(boolean0);
}","/**
 * A generic implementation meant to be used as a helper for common subtyping
 * cases.
 */"
"@Override
public boolean isNoResolvedType() {
    return referencedType.isNoResolvedType();
}","public void test121397() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Named type with empty name component"", 1, 0);
    boolean boolean0 = JSType.isSubtypeHelper(namedType0, namedType0);
    assertFalse(namedType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test121398() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Named type with empty name component"", 1, 0);
    boolean boolean0 = JSType.isSubtypeHelper(namedType0, namedType0);
    assertFalse(namedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test122399() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    enumType0.defineInferredProperty(""Not declared as a constructor"", booleanType0, node0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    assertFalse(parameterizedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test122400() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 0, 1);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, ""Not declared as a constructor"", node0, booleanType0);
    enumType0.defineInferredProperty(""Not declared as a constructor"", booleanType0, node0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, enumType0, enumType0);
    enumType0.resolveInternal(simpleErrorReporter0, parameterizedType0);
    assertTrue(enumType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test123401() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    errorFunctionType0.setResolvedTypeInternal((JSType) null);
    errorFunctionType0.resolve(simpleErrorReporter0, errorFunctionType0);
    assertTrue(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"static final JSType safeResolve(JSType type, ErrorReporter t, StaticScope<JSType> scope) {
    return type == null ? null : type.resolve(t, scope);
}","public void test124402() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSType jSType0 = JSType.safeResolve((JSType) null, simpleErrorReporter0, (StaticScope<JSType>) null);
    assertNull(jSType0);
}","/**
 * A null-safe resolve.
 * @see #resolve
 */"
