focal_method,test_prefix,docstring
"RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {
    this(registry, properties, true);
}","public void test000() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    hashMap0.put(""\n\nSubtree1: "", (RecordTypeBuilder.RecordProperty) null);
    RecordType recordType0 = null;
    try {
        recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // RecordProperty associated with a property should not be null!
        //
        verifyException(""com.google.javascript.rhino.jstype.RecordType"", e);
    }
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test011() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    Node node0 = Node.newString(""Not declared as a type name"");
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(templateType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, false);
    ObjectType objectType0 = recordType0.getImplicitPrototype();
    assertFalse(recordType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test012() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    Node node0 = Node.newString(""Not declared as a type name"");
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(templateType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, false);
    ObjectType objectType0 = recordType0.getImplicitPrototype();
    recordType0.getGreatestSubtypeHelper(objectType0);
    assertTrue(recordType0.hasCachedValues());
}",""
"boolean isSynthetic() {
    return !declared;
}","public void test023() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, true);
    boolean boolean0 = recordType0.isSynthetic();
    assertFalse(boolean0);
}","/**
 * @return Is this synthesized for internal bookkeeping?
 */"
"boolean isSynthetic() {
    return !declared;
}","public void test034() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, false);
    boolean boolean0 = recordType0.isSynthetic();
    assertTrue(boolean0);
}","/**
 * @return Is this synthesized for internal bookkeeping?
 */"
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test045() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    Node node0 = Node.newString(0, ""Named type with empty name component"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(jSType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    assertTrue(recordType0.hasCachedValues());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test046() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    Node node0 = Node.newString(0, ""Named type with empty name component"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(jSType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0);
    assertTrue(recordType1.equals((Object) recordType0));
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test057() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    Node node0 = new Node(1);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noResolvedType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    assertTrue(recordType0.hasCachedValues());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test058() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    Node node0 = new Node(1);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noResolvedType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    hashMap0.put(""Not declared as a type name"", recordTypeBuilder_RecordProperty0);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0);
    assertFalse(recordType1.equals((Object) recordType0));
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test069() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    Node node0 = Node.newString(0, ""Named type with empty name component"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(jSType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty1 = new RecordTypeBuilder.RecordProperty(recordType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty1);
    assertTrue(recordType0.hasCachedValues());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test0610() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    Node node0 = Node.newString(0, ""Named type with empty name component"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(jSType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty1 = new RecordTypeBuilder.RecordProperty(recordType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty1);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType1.getGreatestSubtypeHelper(recordType0);
    assertFalse(recordType1.equals((Object) recordType0));
}",""
"@Override
boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) {
    if (isFrozen) {
        return false;
    }
    if (!inferred) {
        properties.put(propertyName, type);
    }
    return super.defineProperty(propertyName, type, inferred, propertyNode);
}","public void test0711() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    JSType jSType0 = recordType0.getGreatestSubtypeHelper(recordType0);
    boolean boolean0 = recordType0.defineProperty(""Not declared as a constructor"", jSType0, false, (Node) null);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test0813() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    Node node0 = Node.newString(0, ""Named type with empty name component"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(jSType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType1 = recordType0.getGreatestSubtypeHelper(recordType0);
    assertTrue(jSType1.equals((Object) recordType0));
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test0914() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newString(""Not declared as a type name"");
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(recordType0, node0);
    hashMap0.put(""Not declared as a constructor"", recordTypeBuilder_RecordProperty0);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0, true);
    JSType jSType0 = recordType1.getGreatestSubtypeHelper(recordType0);
    assertTrue(jSType0.equals((Object) recordType1));
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test0915() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newString(""Not declared as a type name"");
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(recordType0, node0);
    hashMap0.put(""Not declared as a constructor"", recordTypeBuilder_RecordProperty0);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0, true);
    JSType jSType0 = recordType1.getGreatestSubtypeHelper(recordType0);
    assertFalse(recordType1.equals((Object) recordType0));
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test1016() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    Node node0 = new Node(0, 1, 0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    ObjectType objectType0 = recordType0.getParentScope();
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(objectType0, node0);
    hashMap0.put(""Not declared as a constructor"", recordTypeBuilder_RecordProperty0);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType0 = recordType0.getGreatestSubtypeHelper(recordType1);
    assertTrue(jSType0.equals((Object) recordType1));
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test1017() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    Node node0 = new Node(0, 1, 0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    ObjectType objectType0 = recordType0.getParentScope();
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(objectType0, node0);
    hashMap0.put(""Not declared as a constructor"", recordTypeBuilder_RecordProperty0);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType0 = recordType0.getGreatestSubtypeHelper(recordType1);
    assertFalse(recordType1.equals((Object) recordType0));
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test1118() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType0 = recordType0.getGreatestSubtypeHelper(voidType0);
    assertFalse(jSType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1219() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    Node node0 = new Node(1, 1, 0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(objectType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    NoObjectType noObjectType0 = (NoObjectType) recordType0.getGreatestSubtypeHelper(objectType0);
    assertTrue(noObjectType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test1220() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    Node node0 = new Node(1, 1, 0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(objectType0, node0);
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    NoObjectType noObjectType0 = (NoObjectType) recordType0.getGreatestSubtypeHelper(objectType0);
    assertTrue(recordType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test1321() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""prototype"");
    Node node0 = Node.newString(""Unknown class name"");
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseUnknownType();
    errorFunctionType0.defineInferredProperty(""prototype"", jSType0, node0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(errorFunctionType0, node0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.getGreatestSubtypeHelper(errorFunctionType0);
    assertTrue(recordType0.hasCachedValues());
}",""
"public final boolean isTemplateType() {
    return toMaybeTemplateType() != null;
}","public void test1422() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, recordType0, ""Not declared as a type name"");
    JSType jSType0 = recordType0.getGreatestSubtypeHelper(enumElementType0);
    assertFalse(jSType0.isTemplateType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1523() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    Node node0 = Node.newString(""Named type with empty name component"", 1, 0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noResolvedType0, node0);
    hashMap0.put(""Named type with empty name component"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = RecordType.isSubtype((ObjectType) noResolvedType0, recordType0);
    assertFalse(noResolvedType0.hasCachedValues());
}",""
"static boolean isSubtype(ObjectType typeA, RecordType typeB) {
    // typeA is a subtype of record type typeB iff:
    // 1) typeA has all the properties declared in typeB.
    // 2) And for each property of typeB,
    //    2a) if the property of typeA is declared, it must be equal
    //        to the type of the property of typeB,
    //    2b) otherwise, it must be a subtype of the property of typeB.
    //
    // To figure out why this is true, consider the following pseudo-code:
    // /** @type {{a: (Object,null)}} */ var x;
    // /** @type {{a: !Object}} */ var y;
    // var z = {a: {}};
    // x.a = null;
    //
    // y cannot be assigned to x, because line 4 would violate y's declared
    // properties. But z can be assigned to x. Even though z and y are the
    // same type, the properties of z are inferred--and so an assignment
    // to the property of z would not violate any restrictions on it.
    for (String property : typeB.properties.keySet()) {
        if (!typeA.hasProperty(property)) {
            return false;
        }
        JSType propA = typeA.getPropertyType(property);
        JSType propB = typeB.getPropertyType(property);
        if (!propA.isUnknownType() && !propB.isUnknownType()) {
            if (typeA.isPropertyTypeDeclared(property)) {
                // If one declared property isn't invariant,
                // then the whole record isn't covariant.
                if (!propA.isInvariant(propB)) {
                    return false;
                }
            } else {
                // If one inferred property isn't a subtype,
                // then the whole record isn't covariant.
                if (!propA.isSubtype(propB)) {
                    return false;
                }
            }
        }
    }
    return true;
}","public void test1524() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    Node node0 = Node.newString(""Named type with empty name component"", 1, 0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noResolvedType0, node0);
    hashMap0.put(""Named type with empty name component"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = RecordType.isSubtype((ObjectType) noResolvedType0, recordType0);
    assertTrue(boolean0);
}","/**
 * Determines if typeA is a subtype of typeB
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1625() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    NoType noType0 = (NoType) voidType0.restrictByNotNullOrUndefined();
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 1, 0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    UnknownType unknownType0 = (UnknownType) errorFunctionType0.getPropertyType(""Not declared as a constructor"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(unknownType0, node0);
    hashMap0.put(""Not declared as a constructor"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = RecordType.isSubtype((ObjectType) noType0, recordType0);
    assertTrue(noType0.hasCachedValues());
}",""
"static boolean isSubtype(ObjectType typeA, RecordType typeB) {
    // typeA is a subtype of record type typeB iff:
    // 1) typeA has all the properties declared in typeB.
    // 2) And for each property of typeB,
    //    2a) if the property of typeA is declared, it must be equal
    //        to the type of the property of typeB,
    //    2b) otherwise, it must be a subtype of the property of typeB.
    //
    // To figure out why this is true, consider the following pseudo-code:
    // /** @type {{a: (Object,null)}} */ var x;
    // /** @type {{a: !Object}} */ var y;
    // var z = {a: {}};
    // x.a = null;
    //
    // y cannot be assigned to x, because line 4 would violate y's declared
    // properties. But z can be assigned to x. Even though z and y are the
    // same type, the properties of z are inferred--and so an assignment
    // to the property of z would not violate any restrictions on it.
    for (String property : typeB.properties.keySet()) {
        if (!typeA.hasProperty(property)) {
            return false;
        }
        JSType propA = typeA.getPropertyType(property);
        JSType propB = typeB.getPropertyType(property);
        if (!propA.isUnknownType() && !propB.isUnknownType()) {
            if (typeA.isPropertyTypeDeclared(property)) {
                // If one declared property isn't invariant,
                // then the whole record isn't covariant.
                if (!propA.isInvariant(propB)) {
                    return false;
                }
            } else {
                // If one inferred property isn't a subtype,
                // then the whole record isn't covariant.
                if (!propA.isSubtype(propB)) {
                    return false;
                }
            }
        }
    }
    return true;
}","public void test1626() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    NoType noType0 = (NoType) voidType0.restrictByNotNullOrUndefined();
    Node node0 = Node.newString(0, ""Not declared as a constructor"", 1, 0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    UnknownType unknownType0 = (UnknownType) errorFunctionType0.getPropertyType(""Not declared as a constructor"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(unknownType0, node0);
    hashMap0.put(""Not declared as a constructor"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = RecordType.isSubtype((ObjectType) noType0, recordType0);
    assertTrue(boolean0);
}","/**
 * Determines if typeA is a subtype of typeB
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1727() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""prototype"");
    Node node0 = Node.newString(1, ""Not declared as a type name"", 1, 1);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(errorFunctionType0, node0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = RecordType.isSubtype((ObjectType) errorFunctionType0, recordType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"static boolean isSubtype(ObjectType typeA, RecordType typeB) {
    // typeA is a subtype of record type typeB iff:
    // 1) typeA has all the properties declared in typeB.
    // 2) And for each property of typeB,
    //    2a) if the property of typeA is declared, it must be equal
    //        to the type of the property of typeB,
    //    2b) otherwise, it must be a subtype of the property of typeB.
    //
    // To figure out why this is true, consider the following pseudo-code:
    // /** @type {{a: (Object,null)}} */ var x;
    // /** @type {{a: !Object}} */ var y;
    // var z = {a: {}};
    // x.a = null;
    //
    // y cannot be assigned to x, because line 4 would violate y's declared
    // properties. But z can be assigned to x. Even though z and y are the
    // same type, the properties of z are inferred--and so an assignment
    // to the property of z would not violate any restrictions on it.
    for (String property : typeB.properties.keySet()) {
        if (!typeA.hasProperty(property)) {
            return false;
        }
        JSType propA = typeA.getPropertyType(property);
        JSType propB = typeB.getPropertyType(property);
        if (!propA.isUnknownType() && !propB.isUnknownType()) {
            if (typeA.isPropertyTypeDeclared(property)) {
                // If one declared property isn't invariant,
                // then the whole record isn't covariant.
                if (!propA.isInvariant(propB)) {
                    return false;
                }
            } else {
                // If one inferred property isn't a subtype,
                // then the whole record isn't covariant.
                if (!propA.isSubtype(propB)) {
                    return false;
                }
            }
        }
    }
    return true;
}","public void test1728() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""prototype"");
    Node node0 = Node.newString(1, ""Not declared as a type name"", 1, 1);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(errorFunctionType0, node0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    hashMap0.put(""prototype"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = RecordType.isSubtype((ObjectType) errorFunctionType0, recordType0);
    assertFalse(boolean0);
}","/**
 * Determines if typeA is a subtype of typeB
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1829() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    NoType noType0 = (NoType) voidType0.restrictByNotNullOrUndefined();
    Node node0 = Node.newString(1, ""Named type with empty name component"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noType0, node0);
    hashMap0.put(""Not declared as a constructor"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = RecordType.isSubtype((ObjectType) noType0, recordType0);
    assertTrue(noType0.hasCachedValues());
}",""
"static boolean isSubtype(ObjectType typeA, RecordType typeB) {
    // typeA is a subtype of record type typeB iff:
    // 1) typeA has all the properties declared in typeB.
    // 2) And for each property of typeB,
    //    2a) if the property of typeA is declared, it must be equal
    //        to the type of the property of typeB,
    //    2b) otherwise, it must be a subtype of the property of typeB.
    //
    // To figure out why this is true, consider the following pseudo-code:
    // /** @type {{a: (Object,null)}} */ var x;
    // /** @type {{a: !Object}} */ var y;
    // var z = {a: {}};
    // x.a = null;
    //
    // y cannot be assigned to x, because line 4 would violate y's declared
    // properties. But z can be assigned to x. Even though z and y are the
    // same type, the properties of z are inferred--and so an assignment
    // to the property of z would not violate any restrictions on it.
    for (String property : typeB.properties.keySet()) {
        if (!typeA.hasProperty(property)) {
            return false;
        }
        JSType propA = typeA.getPropertyType(property);
        JSType propB = typeB.getPropertyType(property);
        if (!propA.isUnknownType() && !propB.isUnknownType()) {
            if (typeA.isPropertyTypeDeclared(property)) {
                // If one declared property isn't invariant,
                // then the whole record isn't covariant.
                if (!propA.isInvariant(propB)) {
                    return false;
                }
            } else {
                // If one inferred property isn't a subtype,
                // then the whole record isn't covariant.
                if (!propA.isSubtype(propB)) {
                    return false;
                }
            }
        }
    }
    return true;
}","public void test1830() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    NoType noType0 = (NoType) voidType0.restrictByNotNullOrUndefined();
    Node node0 = Node.newString(1, ""Named type with empty name component"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noType0, node0);
    hashMap0.put(""Not declared as a constructor"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = RecordType.isSubtype((ObjectType) noType0, recordType0);
    assertTrue(boolean0);
}","/**
 * Determines if typeA is a subtype of typeB
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test1931() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    Node node0 = Node.newString(""Not declared as a constructor"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noResolvedType0, node0);
    hashMap0.put(""Not declared as a constructor"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.resolveInternal(simpleErrorReporter0, noResolvedType0);
    assertTrue(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test2032() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    Node node0 = Node.newString(""Not declared as a type name"", 1, 1);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    JSType jSType0 = jSTypeRegistry0.getType((StaticScope<JSType>) errorFunctionType0, ""Unknown class name"", ""Not declared as a type name"", 0, 12);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(jSType0, node0);
    hashMap0.put(""Named type with empty name component"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType1 = recordType0.resolveInternal(simpleErrorReporter0, errorFunctionType0);
    assertFalse(jSType1.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
