focal_method,test_prefix,docstring
"public final boolean isEnumElementType() {
    return toMaybeEnumElementType() != null;
}","public void test000() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(noResolvedType0, jSType0);
    JSType jSType1 = modificationVisitor0.caseParameterizedType(parameterizedType0);
    assertFalse(jSType1.isEnumElementType());
}",""
"@Override
public TypePair getTypesUnderInequality(JSType that) {
    UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);
    UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry);
    for (JSType element : alternates) {
        TypePair p = element.getTypesUnderInequality(that);
        if (p.typeA != null) {
            thisRestricted.addAlternate(p.typeA);
        }
        if (p.typeB != null) {
            thatRestricted.addAlternate(p.typeB);
        }
    }
    return new TypePair(thisRestricted.build(), thatRestricted.build());
}","public void test011() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noObjectType0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) noObjectType0, (JSType) noObjectType0, jSType0, (JSType) noObjectType0, (JSType) noObjectType0, (JSType) noObjectType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType1 = unionType0.collapseUnion();
    JSType.TypePair jSType_TypePair0 = unionType0.getTypesUnderInequality(jSType1);
    assertNotNull(jSType_TypePair0);
}",""
"@Override
public boolean matchesNumberContext() {
    // TODO(user): Reverse this logic to make it correct instead of generous.
    for (JSType t : alternates) {
        if (t.matchesNumberContext()) {
            return true;
        }
    }
    return false;
}","public void test033() throws Throwable {
    ArrayDeque<JSType> arrayDeque0 = new ArrayDeque<JSType>();
    AllType allType0 = new AllType((JSTypeRegistry) null);
    arrayDeque0.add(allType0);
    UnionType unionType0 = new UnionType((JSTypeRegistry) null, arrayDeque0);
    boolean boolean0 = unionType0.matchesNumberContext();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in a
 * numeric context, such as an operand of a multiply operator.
 *
 * @return true if the type can appear in a numeric context.
 */"
"public final boolean matchesInt32Context() {
    return matchesNumberContext();
}","public void test044() throws Throwable {
    StringType stringType0 = new StringType((JSTypeRegistry) null);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) stringType0, (JSType) stringType0, (JSType) stringType0);
    UnionType unionType0 = new UnionType((JSTypeRegistry) null, immutableList0);
    boolean boolean0 = unionType0.matchesInt32Context();
    assertTrue(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in a
 * 'Int32' context.  This context includes, for example, the operands of a
 * bitwise or operator.  Since we do not currently support integer types,
 * this is a synonym for {@code Number}.
 */"
"@Override
public boolean matchesStringContext() {
    // TODO(user): Reverse this logic to make it correct instead of generous.
    for (JSType t : alternates) {
        if (t.matchesStringContext()) {
            return true;
        }
    }
    return false;
}","public void test055() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    ArrayDeque<JSType> arrayDeque0 = new ArrayDeque<JSType>();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, arrayDeque0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) unionType0, (JSType) noResolvedType0, (JSType) noResolvedType0, (JSType) noResolvedType0, (JSType) unionType0, (JSType) noResolvedType0, (JSType) noResolvedType0);
    UnionType unionType1 = new UnionType(jSTypeRegistry0, immutableList0);
    boolean boolean0 = unionType1.matchesStringContext();
    assertTrue(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in a
 * {@code String} context, such as an operand of a string concat ({@code +})
 * operator.<p>
 *
 * All types have at least the potential for converting to {@code String}.
 * When we add externally defined types, such as a browser OM, we may choose
 * to add types that do not automatically convert to {@code String}.
 *
 * @return {@code true} if not {@link VoidType}
 */"
"@Override
public boolean matchesObjectContext() {
    // TODO(user): Reverse this logic to make it correct instead of generous.
    for (JSType t : alternates) {
        if (t.matchesObjectContext()) {
            return true;
        }
    }
    return false;
}","public void test066() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<VoidType> immutableList0 = ImmutableList.of(voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0);
    ImmutableList<JSType> immutableList1 = ImmutableList.copyOf((Collection<? extends JSType>) immutableList0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList1);
    boolean boolean0 = unionType0.matchesObjectContext();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in an
 * {@code Object} context, such as the expression in a {@code with}
 * statement.<p>
 *
 * Most types we will encounter, except notably {@code null}, have at least
 * the potential for converting to {@code Object}.  Host defined objects can
 * get peculiar.<p>
 *
 * VOID type is included here because while it is not part of the JavaScript
 * language, functions returning 'void' type can't be used as operands of
 * any operator or statement.<p>
 *
 * @return {@code true} if the type is not {@link NullType} or
 *         {@link VoidType}
 */"
"public boolean matchesObjectContext() {
    return false;
}","public void test077() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noObjectType0);
    boolean boolean0 = jSType0.matchesObjectContext();
    assertTrue(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in an
 * {@code Object} context, such as the expression in a with statement.
 *
 * Most types we will encounter, except notably {@code null}, have at least
 * the potential for converting to {@code Object}.  Host defined objects can
 * get peculiar.
 */"
"@Override
public JSType findPropertyType(String propertyName) {
    JSType propertyType = null;
    for (JSType alternate : getAlternates()) {
        // Filter out the null/undefined type.
        if (alternate.isNullType() || alternate.isVoidType()) {
            continue;
        }
        JSType altPropertyType = alternate.findPropertyType(propertyName);
        if (altPropertyType == null) {
            continue;
        }
        if (propertyType == null) {
            propertyType = altPropertyType;
        } else {
            propertyType = propertyType.getLeastSupertype(altPropertyType);
        }
    }
    return propertyType;
}","public void test088() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) nullType0, (JSType) nullType0, (JSType) nullType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType0 = unionType0.findPropertyType(""Not declared as a type name"");
    assertNull(jSType0);
}",""
"public boolean isConstructor() {
    return false;
}","public void test099() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    JSType jSType1 = jSType0.findPropertyType(""Not declared as a type name"");
    assertFalse(jSType1.isConstructor());
}","/**
 * Whether this type is a {@link FunctionType} that is a constructor or a
 * named type that points to such a type.
 */"
"@Override
public JSType findPropertyType(String propertyName) {
    JSType propertyType = null;
    for (JSType alternate : getAlternates()) {
        // Filter out the null/undefined type.
        if (alternate.isNullType() || alternate.isVoidType()) {
            continue;
        }
        JSType altPropertyType = alternate.findPropertyType(propertyName);
        if (altPropertyType == null) {
            continue;
        }
        if (propertyType == null) {
            propertyType = altPropertyType;
        } else {
            propertyType = propertyType.getLeastSupertype(altPropertyType);
        }
    }
    return propertyType;
}","public void test1010() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ArrayDeque<JSType> arrayDeque0 = new ArrayDeque<JSType>();
    StringType stringType0 = new StringType(jSTypeRegistry0);
    arrayDeque0.add(stringType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, arrayDeque0);
    JSType jSType0 = unionType0.findPropertyType(""Named type with empty name component"");
    assertNull(jSType0);
}",""
"public final boolean isParameterizedType() {
    return toMaybeParameterizedType() != null;
}","public void test1111() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""eM&"");
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) templateType0, (JSType) templateType0, (JSType) templateType0, (JSType) templateType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType0 = unionType0.findPropertyType(""Not declared as a constructor"");
    assertFalse(jSType0.isParameterizedType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1212() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<VoidType> immutableList0 = ImmutableList.of(voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0);
    ImmutableList<JSType> immutableList1 = ImmutableList.copyOf((Collection<? extends JSType>) immutableList0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList1);
    NoType noType0 = (NoType) unionType0.getRestrictedTypeGivenToBooleanOutcome(true);
    boolean boolean0 = unionType0.canAssignTo(noType0);
    assertTrue(noType0.hasCachedValues());
}",""
"@Override
public boolean canAssignTo(JSType that) {
    boolean canAssign = true;
    for (JSType t : alternates) {
        if (t.isUnknownType()) {
            return true;
        }
        canAssign &= t.canAssignTo(that);
    }
    return canAssign;
}","public void test1213() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<VoidType> immutableList0 = ImmutableList.of(voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0);
    ImmutableList<JSType> immutableList1 = ImmutableList.copyOf((Collection<? extends JSType>) immutableList0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList1);
    NoType noType0 = (NoType) unionType0.getRestrictedTypeGivenToBooleanOutcome(true);
    boolean boolean0 = unionType0.canAssignTo(noType0);
    assertFalse(boolean0);
}",""
"@Override
public boolean canAssignTo(JSType that) {
    boolean canAssign = true;
    for (JSType t : alternates) {
        if (t.isUnknownType()) {
            return true;
        }
        canAssign &= t.canAssignTo(that);
    }
    return canAssign;
}","public void test1314() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""eM&"");
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) templateType0, (JSType) templateType0, (JSType) templateType0, (JSType) templateType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    boolean boolean0 = unionType0.canAssignTo(templateType0);
    assertTrue(boolean0);
}",""
"@Override
public boolean canBeCalled() {
    for (JSType t : alternates) {
        if (!t.canBeCalled()) {
            return false;
        }
    }
    return true;
}","public void test1415() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ArrayDeque<JSType> arrayDeque0 = new ArrayDeque<JSType>();
    UnionType unionType0 = new UnionType(jSTypeRegistry0, arrayDeque0);
    boolean boolean0 = unionType0.canBeCalled();
    assertTrue(boolean0);
}",""
"public boolean canBeCalled() {
    return false;
}","public void test1516() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    boolean boolean0 = jSType0.canBeCalled();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can be used as the
 * 'function' in a function call.
 *
 * @return {@code true} if this type might be callable.
 */"
"public final boolean isParameterizedType() {
    return toMaybeParameterizedType() != null;
}","public void test1617() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    JSType jSType1 = jSType0.restrictByNotNullOrUndefined();
    assertFalse(jSType1.isParameterizedType());
}",""
"public TernaryValue testForEquality(JSType that) {
    return testForEqualityHelper(this, that);
}","public void test1718() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    jSType0.testForEquality(noResolvedType0);
}","/**
 * Compares {@code this} and {@code that}.
 * @return <ul>
 * <li>{@link TernaryValue#TRUE} if the comparison of values of
 *   {@code this} type and {@code that} always succeed (such as
 *   {@code undefined} compared to {@code null})</li>
 * <li>{@link TernaryValue#FALSE} if the comparison of values of
 *   {@code this} type and {@code that} always fails (such as
 *   {@code undefined} compared to {@code number})</li>
 * <li>{@link TernaryValue#UNKNOWN} if the comparison can succeed or
 *   fail depending on the concrete values</li>
 * </ul>
 */"
"public TernaryValue testForEquality(JSType that) {
    return testForEqualityHelper(this, that);
}","public void test1819() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noObjectType0);
    jSType0.testForEquality(noObjectType0);
}","/**
 * Compares {@code this} and {@code that}.
 * @return <ul>
 * <li>{@link TernaryValue#TRUE} if the comparison of values of
 *   {@code this} type and {@code that} always succeed (such as
 *   {@code undefined} compared to {@code null})</li>
 * <li>{@link TernaryValue#FALSE} if the comparison of values of
 *   {@code this} type and {@code that} always fails (such as
 *   {@code undefined} compared to {@code number})</li>
 * <li>{@link TernaryValue#UNKNOWN} if the comparison can succeed or
 *   fail depending on the concrete values</li>
 * </ul>
 */"
"public boolean isNullable() {
    return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE));
}","public void test1920() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noObjectType0);
    boolean boolean0 = jSType0.isNullable();
    assertFalse(boolean0);
}","/**
 * Tests whether this type is nullable.
 */"
"public boolean isNullable() {
    return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE));
}","public void test2021() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    boolean boolean0 = jSType0.isNullable();
    assertTrue(boolean0);
}","/**
 * Tests whether this type is nullable.
 */"
"public boolean isNullType() {
    return false;
}","public void test2122() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""eM&"");
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) templateType0, (JSType) templateType0, (JSType) templateType0, (JSType) templateType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType0 = unionType0.getLeastSupertype(templateType0);
    assertFalse(jSType0.isNullType());
}",""
"@Override
public boolean isStruct() {
    for (JSType typ : getAlternates()) {
        if (typ.isStruct()) {
            return true;
        }
    }
    return false;
}","public void test2223() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<VoidType> immutableList0 = ImmutableList.of(voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0, voidType0);
    ImmutableList<JSType> immutableList1 = ImmutableList.copyOf((Collection<? extends JSType>) immutableList0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList1);
    boolean boolean0 = unionType0.isStruct();
    assertFalse(boolean0);
}",""
"public boolean isDict() {
    if (isObject()) {
        FunctionType ctor = toObjectType().getConstructor();
        return ctor != null && ctor.makesDicts();
    }
    return false;
}","public void test2324() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noObjectType0);
    boolean boolean0 = jSType0.isDict();
    assertFalse(boolean0);
}","/**
 * Returns true iff {@code this} can be a {@code dict}.
 * UnionType overrides the method, assume {@code this} is not a union here.
 */"
"public boolean isStringValueType() {
    return false;
}","public void test2425() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    Stack<JSType> stack0 = new Stack<JSType>();
    UnionType unionType0 = new UnionType(jSTypeRegistry0, stack0);
    JSType jSType0 = unionType0.getLeastSupertype(unionType0);
    assertFalse(jSType0.isStringValueType());
}",""
"public JSType getLeastSupertype(JSType that) {
    if (that.isUnionType()) {
        // Union types have their own implementation of getLeastSupertype.
        return that.toMaybeUnionType().getLeastSupertype(this);
    }
    return getLeastSupertype(this, that);
}","public void test2526() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noObjectType0);
    JSType jSType1 = jSType0.collapseUnion();
    JSType jSType2 = jSType0.getLeastSupertype(jSType1);
    assertEquals(0, JSType.NOT_ENUMDECL);
}","/**
 * Gets the least supertype of {@code this} and {@code that}.
 * The least supertype is the join (&#8744;) or supremum of both types in the
 * type lattice.<p>
 * Examples:
 * <ul>
 * <li>{@code number &#8744; *} = {@code *}</li>
 * <li>{@code number &#8744; Object} = {@code (number, Object)}</li>
 * <li>{@code Number &#8744; Object} = {@code Object}</li>
 * </ul>
 * @return {@code this &#8744; that}
 */"
"@Override
public JSType getLeastSupertype(JSType that) {
    if (!that.isUnknownType() && !that.isUnionType()) {
        for (JSType alternate : alternates) {
            if (!alternate.isUnknownType() && that.isSubtype(alternate)) {
                return this;
            }
        }
    }
    return getLeastSupertype(this, that);
}","public void test2627() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, "","");
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) templateType0, (JSType) voidType0, (JSType) voidType0, (JSType) voidType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType.TypePair jSType_TypePair0 = unionType0.getTypesUnderInequality(voidType0);
    JSType jSType0 = unionType0.getLeastSupertype(jSType_TypePair0.typeB);
    assertSame(jSType0, unionType0);
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test2728() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ArrayDeque<JSType> arrayDeque0 = new ArrayDeque<JSType>();
    StringType stringType0 = new StringType(jSTypeRegistry0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, arrayDeque0);
    JSType jSType0 = unionType0.meet(stringType0);
    assertFalse(jSType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"@Override
public int getPropertiesCount() {
    // Should never be called, returning the biggest number to highlight the
    // 'unifying' role of this type.
    return Integer.MAX_VALUE;
}","public void test2829() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    UnionType unionType0 = (UnionType) jSTypeRegistry0.createOptionalType(noResolvedType0);
    NoResolvedType noResolvedType1 = (NoResolvedType) unionType0.meet(noResolvedType0);
    assertEquals(Integer.MAX_VALUE, noResolvedType1.getPropertiesCount());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test2930() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    UnionType unionType0 = (UnionType) jSTypeRegistry0.createOptionalType(noObjectType0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) numberType0, (JSType) numberType0, (JSType) unionType0, (JSType) unionType0, (JSType) unionType0, (JSType) numberType0, (JSType) noObjectType0);
    UnionType unionType1 = new UnionType(jSTypeRegistry0, immutableList0);
    UnionType unionType2 = (UnionType) unionType0.meet(unionType1);
    assertTrue(unionType2.equals((Object) unionType0));
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test3031() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ArrayDeque<JSType> arrayDeque0 = new ArrayDeque<JSType>();
    StringType stringType0 = new StringType(jSTypeRegistry0);
    arrayDeque0.add(stringType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, arrayDeque0);
    JSType jSType0 = unionType0.autobox();
    NoType noType0 = (NoType) unionType0.meet(jSType0);
    assertFalse(noType0.hasCachedValues());
}",""
"public boolean canBeCalled() {
    return false;
}","public void test3132() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    ArrayDeque<JSType> arrayDeque0 = new ArrayDeque<JSType>();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, arrayDeque0);
    JSType jSType0 = unionType0.meet(unionType0);
    assertTrue(jSType0.canBeCalled());
}","/**
 * This predicate is used to test whether a given type can be used as the
 * 'function' in a function call.
 *
 * @return {@code true} if this type might be callable.
 */"
"@Override
public boolean hasProperty(String pname) {
    for (JSType alternate : alternates) {
        if (alternate.hasProperty(pname)) {
            return true;
        }
    }
    return false;
}","public void test3533() throws Throwable {
    StringType stringType0 = new StringType((JSTypeRegistry) null);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) stringType0, (JSType) stringType0, (JSType) stringType0);
    UnionType unionType0 = new UnionType((JSTypeRegistry) null, immutableList0);
    boolean boolean0 = unionType0.hasProperty(""Not declared as a type name"");
    assertFalse(boolean0);
}",""
"public boolean hasProperty(String pname) {
    return false;
}","public void test3634() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    boolean boolean0 = jSType0.hasProperty(""Named type with empty name component"");
    assertTrue(boolean0);
}","/**
 * Checks whether the property pname is present on the object.
 */"
"public boolean isObject() {
    return false;
}","public void test3735() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    boolean boolean0 = jSType0.isObject();
    assertFalse(boolean0);
}","/**
 * Tests whether this type is an {@code Object}, or any subtype thereof.
 * @return {@code this &lt;: Object}
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test3836() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    UnionType unionType0 = (UnionType) jSTypeRegistry0.createOptionalType(noResolvedType0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    boolean boolean0 = unionType0.contains(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public boolean contains(JSType type) {
    for (JSType alt : alternates) {
        if (alt.isEquivalentTo(type)) {
            return true;
        }
    }
    return false;
}","public void test3837() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    UnionType unionType0 = (UnionType) jSTypeRegistry0.createOptionalType(noResolvedType0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    boolean boolean0 = unionType0.contains(errorFunctionType0);
    assertFalse(boolean0);
}","/**
 * A {@link UnionType} contains a given type (alternate) iff the member
 * vector contains it.
 *
 * @param type The alternate which might be in this union.
 *
 * @return {@code true} if the alternate is in the union
 */"
"public boolean contains(JSType type) {
    for (JSType alt : alternates) {
        if (alt.isEquivalentTo(type)) {
            return true;
        }
    }
    return false;
}","public void test3938() throws Throwable {
    StringType stringType0 = new StringType((JSTypeRegistry) null);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) stringType0, (JSType) stringType0, (JSType) stringType0);
    UnionType unionType0 = new UnionType((JSTypeRegistry) null, immutableList0);
    boolean boolean0 = unionType0.contains(stringType0);
    assertTrue(boolean0);
}","/**
 * A {@link UnionType} contains a given type (alternate) iff the member
 * vector contains it.
 *
 * @param type The alternate which might be in this union.
 *
 * @return {@code true} if the alternate is in the union
 */"
"@Override
public boolean matchesStringContext() {
    return true;
}","public void test4039() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    UnionType unionType0 = (UnionType) jSTypeRegistry0.createOptionalType(noResolvedType0);
    VoidType voidType0 = (VoidType) unionType0.getRestrictedUnion(noResolvedType0);
    assertTrue(voidType0.matchesStringContext());
}",""
"public final boolean isTemplateType() {
    return toMaybeTemplateType() != null;
}","public void test4140() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""eM&"");
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) templateType0, (JSType) templateType0, (JSType) templateType0, (JSType) templateType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType0 = unionType0.getRestrictedUnion(templateType0);
    assertTrue(jSType0.isTemplateType());
}",""
"public final String toAnnotationString() {
    return toStringHelper(true);
}","public void test4241() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    String string0 = jSType0.toAnnotationString();
    assertEquals(""(?|undefined)"", string0);
}","/**
 * A string representation of this type, suitable for printing
 * in type annotations at code generation time.
 */"
"@Override
public boolean isSubtype(JSType that) {
    // unknown
    if (that.isUnknownType()) {
        return true;
    }
    // all type
    if (that.isAllType()) {
        return true;
    }
    for (JSType element : alternates) {
        if (!element.isSubtype(that)) {
            return false;
        }
    }
    return true;
}","public void test4342() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, (String) null);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) templateType0, (JSType) templateType0, (JSType) templateType0, (JSType) templateType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    boolean boolean0 = unionType0.isSubtype(templateType0);
    assertTrue(boolean0);
}",""
"public boolean isInterface() {
    return false;
}","public void test4443() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    JSType jSType1 = allType0.getGreatestSubtype(jSType0);
    assertFalse(jSType1.isInterface());
}","/**
 * Whether this type is a {@link FunctionType} that is an interface or a named
 * type that points to such a type.
 */"
"public final boolean isNumber() {
    return this.isSubtype(getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));
}","public void test4544() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noObjectType0);
    boolean boolean0 = jSType0.isNumber();
    assertFalse(boolean0);
}","/**
 * Tests whether the type is a number (value or Object).
 * @return {@code this &lt;: (Number, number)}
 */"
"@Override
public BooleanLiteralSet getPossibleToBooleanOutcomes() {
    BooleanLiteralSet literals = BooleanLiteralSet.EMPTY;
    for (JSType element : alternates) {
        literals = literals.union(element.getPossibleToBooleanOutcomes());
        if (literals == BooleanLiteralSet.BOTH) {
            break;
        }
    }
    return literals;
}","public void test4645() throws Throwable {
    StringType stringType0 = new StringType((JSTypeRegistry) null);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) stringType0, (JSType) stringType0, (JSType) stringType0);
    UnionType unionType0 = new UnionType((JSTypeRegistry) null, immutableList0);
    BooleanLiteralSet booleanLiteralSet0 = unionType0.getPossibleToBooleanOutcomes();
    assertEquals(BooleanLiteralSet.BOTH, booleanLiteralSet0);
}",""
"public abstract BooleanLiteralSet getPossibleToBooleanOutcomes();","public void test4746() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    BooleanLiteralSet booleanLiteralSet0 = jSType0.getPossibleToBooleanOutcomes();
    assertEquals(BooleanLiteralSet.FALSE, booleanLiteralSet0);
}","/**
 * Computes the set of possible outcomes of the {@code ToBoolean} predicate
 * for this type. The {@code ToBoolean} predicate is defined by the ECMA-262
 * standard, 3<sup>rd</sup> edition. Its behavior for simple types can be
 * summarized by the following table:
 * <table>
 * <tr><th>type</th><th>result</th></tr>
 * <tr><td>{@code undefined}</td><td>{false}</td></tr>
 * <tr><td>{@code null}</td><td>{false}</td></tr>
 * <tr><td>{@code boolean}</td><td>{true, false}</td></tr>
 * <tr><td>{@code number}</td><td>{true, false}</td></tr>
 * <tr><td>{@code string}</td><td>{true, false}</td></tr>
 * <tr><td>{@code Object}</td><td>{true}</td></tr>
 * </table>
 * @return the set of boolean literals for this type
 */"
"@Override
public TypePair getTypesUnderEquality(JSType that) {
    UnionTypeBuilder thisRestricted = new UnionTypeBuilder(registry);
    UnionTypeBuilder thatRestricted = new UnionTypeBuilder(registry);
    for (JSType element : alternates) {
        TypePair p = element.getTypesUnderEquality(that);
        if (p.typeA != null) {
            thisRestricted.addAlternate(p.typeA);
        }
        if (p.typeB != null) {
            thatRestricted.addAlternate(p.typeB);
        }
    }
    return new TypePair(thisRestricted.build(), thatRestricted.build());
}","public void test4847() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    ArrayDeque<JSType> arrayDeque0 = new ArrayDeque<JSType>();
    arrayDeque0.add(stringType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, arrayDeque0);
    JSType.TypePair jSType_TypePair0 = unionType0.getTypesUnderEquality(stringType0);
    assertNotNull(jSType_TypePair0);
}",""
"public TypePair getTypesUnderEquality(JSType that) {
    // unions types
    if (that.isUnionType()) {
        TypePair p = that.toMaybeUnionType().getTypesUnderEquality(this);
        return new TypePair(p.typeB, p.typeA);
    }
    // other types
    switch(this.testForEquality(that)) {
        case FALSE:
            return new TypePair(null, null);
        case TRUE:
        case UNKNOWN:
            return new TypePair(this, that);
    }
    // switch case is exhaustive
    throw new IllegalStateException();
}","public void test4948() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    JSType.TypePair jSType_TypePair0 = jSType0.getTypesUnderEquality(noResolvedType0);
    assertNotNull(jSType_TypePair0);
}","/**
 * Computes the subset of {@code this} and {@code that} types if equality
 * is observed. If a value {@code v1} of type {@code null} is equal to a value
 * {@code v2} of type {@code (undefined,number)}, we can infer that the
 * type of {@code v1} is {@code null} and the type of {@code v2} is
 * {@code undefined}.
 *
 * @return a pair containing the restricted type of {@code this} as the first
 *         component and the restricted type of {@code that} as the second
 *         element. The returned pair is never {@code null} even though its
 *         components may be {@code null}
 */"
"public TypePair getTypesUnderShallowInequality(JSType that) {
    // union types
    if (that.isUnionType()) {
        TypePair p = that.toMaybeUnionType().getTypesUnderShallowInequality(this);
        return new TypePair(p.typeB, p.typeA);
    }
    // Other types.
    // There are only two types whose shallow inequality is deterministically
    // true -- null and undefined. We can just enumerate them.
    if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) {
        return new TypePair(null, null);
    } else {
        return new TypePair(this, that);
    }
}","public void test5049() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    JSType.TypePair jSType_TypePair0 = jSType0.getTypesUnderShallowInequality(jSType0);
    assertNotNull(jSType_TypePair0);
}","/**
 * Computes the subset of {@code this} and {@code that} types under
 * shallow inequality.
 *
 * @return A pair containing the restricted type of {@code this} as the first
 *         component and the restricted type of {@code that} as the second
 *         element. The returned pair is never {@code null} even though its
 *         components may be {@code null}
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test5150() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Not declared as a constructor"", 1, 0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) noResolvedType0, (JSType) noResolvedType0, (JSType) namedType0, (JSType) namedType0, (JSType) namedType0, (JSType) namedType0, (JSType) namedType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    unionType0.resolveInternal(simpleErrorReporter0, noResolvedType0);
    assertTrue(namedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test5151() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Not declared as a constructor"", 1, 0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) noResolvedType0, (JSType) noResolvedType0, (JSType) namedType0, (JSType) namedType0, (JSType) namedType0, (JSType) namedType0, (JSType) namedType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    unionType0.resolveInternal(simpleErrorReporter0, noResolvedType0);
    assertTrue(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test5252() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    UnionType unionType0 = (UnionType) jSTypeRegistry0.createOptionalType(noResolvedType0);
    unionType0.resolveInternal(simpleErrorReporter0, noResolvedType0);
    assertTrue(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
    // for circularly defined types.
    setResolvedTypeInternal(this);
    boolean changed = false;
    ImmutableList.Builder<JSType> resolvedTypes = ImmutableList.builder();
    for (JSType alternate : alternates) {
        JSType newAlternate = alternate.resolve(t, scope);
        changed |= (alternate != newAlternate);
        resolvedTypes.add(alternate);
    }
    if (changed) {
        Collection<JSType> newAlternates = resolvedTypes.build();
        Preconditions.checkState(newAlternates.hashCode() == this.hashcode);
        alternates = newAlternates;
    }
    return this;
}","public void test5353() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ArrayDeque<JSType> arrayDeque0 = new ArrayDeque<JSType>();
    UnionType unionType0 = new UnionType(jSTypeRegistry0, arrayDeque0);
    JSType[] jSTypeArray0 = new JSType[1];
    jSTypeArray0[0] = (JSType) unionType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, jSTypeArray0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, functionType0, unionType0);
    arrayDeque0.add(parameterizedType0);
    UnionType unionType1 = new UnionType(jSTypeRegistry0, arrayDeque0);
    // Undeclared exception!
    try {
        unionType1.resolveInternal(simpleErrorReporter0, (StaticScope<JSType>) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"public String toDebugHashCodeString() {
    return ""{"" + this.hashCode() + ""}"";
}","public void test5454() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    String string0 = jSType0.toDebugHashCodeString();
    assertEquals(""{(function (this:me, {10}): me,{12})}"", string0);
}","/**
 * A hash code function for diagnosing complicated issues
 * around type-identity.
 */"
"@Override
public boolean setValidator(Predicate<JSType> validator) {
    for (JSType a : alternates) {
        a.setValidator(validator);
    }
    return true;
}","public void test5555() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    ArrayDeque<JSType> arrayDeque0 = new ArrayDeque<JSType>();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, arrayDeque0);
    boolean boolean0 = unionType0.setValidator((Predicate<JSType>) null);
    assertTrue(boolean0);
}",""
"public boolean setValidator(Predicate<JSType> validator) {
    return validator.apply(this);
}","public void test5656() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noResolvedType0);
    // Undeclared exception!
    try {
        jSType0.setValidator((Predicate<JSType>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.JSType"", e);
    }
}","/**
 * Certain types have constraints on them at resolution-time.
 * For example, a type in an {@code @extends} annotation must be an
 * object. Clients should inject a validator that emits a warning
 * if the type does not validate, and return false.
 */"
"@Override
public JSType collapseUnion() {
    JSType currentValue = null;
    ObjectType currentCommonSuper = null;
    for (JSType a : alternates) {
        if (a.isUnknownType()) {
            return getNativeType(JSTypeNative.UNKNOWN_TYPE);
        }
        ObjectType obj = a.toObjectType();
        if (obj == null) {
            if (currentValue == null && currentCommonSuper == null) {
                // If obj is not an object, then it must be a value.
                currentValue = a;
            } else {
                // Multiple values and objects will always collapse to the ALL_TYPE.
                return getNativeType(JSTypeNative.ALL_TYPE);
            }
        } else if (currentValue != null) {
            // Values and objects will always collapse to the ALL_TYPE.
            return getNativeType(JSTypeNative.ALL_TYPE);
        } else if (currentCommonSuper == null) {
            currentCommonSuper = obj;
        } else {
            currentCommonSuper = registry.findCommonSuperObject(currentCommonSuper, obj);
        }
    }
    return currentCommonSuper;
}","public void test5757() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    ArrayDeque<JSType> arrayDeque0 = new ArrayDeque<JSType>();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, arrayDeque0);
    JSType jSType0 = unionType0.collapseUnion();
    assertNull(jSType0);
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test5858() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""eM&"");
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) templateType0, (JSType) templateType0, (JSType) templateType0, (JSType) templateType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType0 = unionType0.collapseUnion();
    assertFalse(jSType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"@Override
public JSType collapseUnion() {
    JSType currentValue = null;
    ObjectType currentCommonSuper = null;
    for (JSType a : alternates) {
        if (a.isUnknownType()) {
            return getNativeType(JSTypeNative.UNKNOWN_TYPE);
        }
        ObjectType obj = a.toObjectType();
        if (obj == null) {
            if (currentValue == null && currentCommonSuper == null) {
                // If obj is not an object, then it must be a value.
                currentValue = a;
            } else {
                // Multiple values and objects will always collapse to the ALL_TYPE.
                return getNativeType(JSTypeNative.ALL_TYPE);
            }
        } else if (currentValue != null) {
            // Values and objects will always collapse to the ALL_TYPE.
            return getNativeType(JSTypeNative.ALL_TYPE);
        } else if (currentCommonSuper == null) {
            currentCommonSuper = obj;
        } else {
            currentCommonSuper = registry.findCommonSuperObject(currentCommonSuper, obj);
        }
    }
    return currentCommonSuper;
}","public void test5959() throws Throwable {
    StringType stringType0 = new StringType((JSTypeRegistry) null);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) stringType0, (JSType) stringType0, (JSType) stringType0);
    UnionType unionType0 = new UnionType((JSTypeRegistry) null, immutableList0);
    // Undeclared exception!
    try {
        unionType0.collapseUnion();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.JSType"", e);
    }
}",""
"public boolean isConstructor() {
    return false;
}","public void test6060() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(noObjectType0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of(jSType0, (JSType) noObjectType0, jSType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType1 = unionType0.collapseUnion();
    assertFalse(jSType1.isConstructor());
}","/**
 * Whether this type is a {@link FunctionType} that is a constructor or a
 * named type that points to such a type.
 */"
"public boolean isConstructor() {
    return false;
}","public void test6161() throws Throwable {
    StringType stringType0 = new StringType((JSTypeRegistry) null);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) stringType0, (JSType) stringType0, (JSType) stringType0);
    UnionType unionType0 = new UnionType((JSTypeRegistry) null, immutableList0);
    unionType0.matchConstraint(stringType0);
    assertFalse(unionType0.isConstructor());
}","/**
 * Whether this type is a {@link FunctionType} that is a constructor or a
 * named type that points to such a type.
 */"
"@Override
public boolean hasAnyTemplateInternal() {
    for (JSType alternate : alternates) {
        if (alternate.hasAnyTemplate()) {
            return true;
        }
    }
    return false;
}","public void test6262() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    UnionType unionType0 = (UnionType) jSTypeRegistry0.createOptionalType(noObjectType0);
    boolean boolean0 = unionType0.hasAnyTemplateInternal();
    assertFalse(boolean0);
}",""
"@Override
public boolean hasAnyTemplateInternal() {
    for (JSType alternate : alternates) {
        if (alternate.hasAnyTemplate()) {
            return true;
        }
    }
    return false;
}","public void test6363() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, (String) null);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) templateType0, (JSType) templateType0, (JSType) templateType0, (JSType) templateType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    boolean boolean0 = unionType0.hasAnyTemplateInternal();
    assertTrue(boolean0);
}",""
