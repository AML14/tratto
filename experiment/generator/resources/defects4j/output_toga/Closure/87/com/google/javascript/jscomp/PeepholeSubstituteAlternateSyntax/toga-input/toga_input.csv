focal_method,test_prefix,docstring
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test000() throws Throwable {
    Node node0 = new Node(0, 0, 0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(4095, Node.MAX_COLUMN_NUMBER);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test011() throws Throwable {
    Node node0 = new Node(0, 0, 0);
    Node node1 = new Node(26, node0, 15, 4);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertNotNull(node2);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public int getType() {
    return type;
}","public void test012() throws Throwable {
    Node node0 = new Node(0, 0, 0);
    Node node1 = new Node(26, node0, 15, 4);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(26, node2.getType());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test023() throws Throwable {
    Node node0 = new Node(113);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test034() throws Throwable {
    Node node0 = new Node(114, 114, 114);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test045() throws Throwable {
    Node node0 = new Node(115, 115, 115);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // malformed 'for' statement FOR 115
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test056() throws Throwable {
    Node node0 = new Node(30);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Compiler compiler0 = new Compiler();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    peepholeSubstituteAlternateSyntax0.beginTraversal(nodeTraversal0);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(45, Node.IS_NAMESPACE);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test067() throws Throwable {
    Node node0 = new Node(30, 30, 30);
    Node node1 = new Node(4, node0, 4, 8);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test078() throws Throwable {
    Node node0 = new Node(113);
    Node node1 = new Node(4, 25, 11);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isNoSideEffectsCall() {
    return areBitFlagsSet(getSideEffectFlags(), NO_SIDE_EFFECTS);
}","public void test089() throws Throwable {
    Node node0 = new Node(105, 105, 105);
    Node node1 = new Node(4, 25, 11);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertFalse(node2.isNoSideEffectsCall());
}","/**
 * Returns true if this node is a function or constructor call that
 * has no side effects.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test0910() throws Throwable {
    Node node0 = new Node(132, 132, 132);
    Node node1 = new Node(4, 29, 0);
    node0.addChildrenToFront(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(1, Node.DECR_FLAG);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1011() throws Throwable {
    Node node0 = new Node(113);
    Node node1 = new Node(4, 25, 11);
    node1.addChildAfter(node0, node0);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(15, Node.NO_SIDE_EFFECTS);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1112() throws Throwable {
    Node node0 = new Node(110, 110, 110);
    Node node1 = new Node(4, 29, 0);
    node0.addChildrenToFront(node1);
    Node node2 = Node.newNumber((double) (-1), 1, 2);
    node1.addChildrenToBack(node2);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node3 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(17, Node.TYPE_PROP);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1213() throws Throwable {
    Node node0 = new Node(115, 115, 115);
    Node node1 = new Node(4, 25, 11);
    node1.addChildAfter(node0, node0);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1314() throws Throwable {
    Node node0 = new Node(26);
    Node node1 = new Node(12, node0, node0, node0, node0, 40, 1);
    node0.addChildrenToFront(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1415() throws Throwable {
    Node node0 = new Node(26);
    Node node1 = new Node(13, node0);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1516() throws Throwable {
    Node node0 = new Node(26);
    Node node1 = new Node(46, node0, node0, node0, 38, 5);
    node1.setType(45);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1617() throws Throwable {
    Node node0 = new Node(26);
    Node node1 = new Node(46, node0, node0, node0, 38, 5);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1718() throws Throwable {
    Node node0 = new Node(108);
    Node node1 = Node.newNumber((double) 2);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Compiler compiler0 = new Compiler();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    peepholeSubstituteAlternateSyntax0.beginTraversal(nodeTraversal0);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertNotNull(node2);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean hasChildren() {
    return first != null;
}","public void test1719() throws Throwable {
    Node node0 = new Node(108);
    Node node1 = Node.newNumber((double) 2);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Compiler compiler0 = new Compiler();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    peepholeSubstituteAlternateSyntax0.beginTraversal(nodeTraversal0);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertTrue(node2.hasChildren());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1820() throws Throwable {
    Node node0 = new Node((-2));
    Node node1 = new Node(108, node0, (-1), 1);
    node1.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(2, Node.ATTRIBUTE_FLAG);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1921() throws Throwable {
    Node node0 = new Node(26, 26, 26);
    node0.addChildToBack(node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2022() throws Throwable {
    Node node0 = new Node(130, 130, 130);
    Node node1 = new Node(100, node0, node0, node0);
    node0.addChildrenToFront(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals((-2), Node.OBJECT_IDS_PROP);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2123() throws Throwable {
    Node node0 = new Node(26);
    Node node1 = new Node((-1), node0, 1, 29);
    node1.setType(101);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2224() throws Throwable {
    Node node0 = new Node(26, 26, 26);
    Node node1 = new Node(14, node0, node0, node0);
    node1.setType(100);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2325() throws Throwable {
    Node node0 = new Node(130, 130, 130);
    Node node1 = new Node(26, node0, node0, node0, node0, (-3), 12);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(37, Node.SYNTHETIC_BLOCK_PROP);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2426() throws Throwable {
    Node node0 = new Node(26, 26, 26);
    Node node1 = new Node(14, node0, node0, node0);
    Node node2 = Node.newNumber((double) 39, 40, 114);
    node1.addChildToBack(node2);
    node1.setType(100);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2527() throws Throwable {
    Node node0 = new Node(98, 98, 98);
    node0.addChildrenToFront(node0);
    Node node1 = new Node(35);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(44, Node.IS_VAR_ARGS_PARAM);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2628() throws Throwable {
    Node node0 = new Node(130);
    Node node1 = Node.newNumber((double) 0);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(1, Node.LEFT);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isLocalResultCall() {
    return areBitFlagsSet(getSideEffectFlags(), FLAG_LOCAL_RESULTS);
}","public void test2729() throws Throwable {
    Node node0 = new Node(30);
    node0.addChildToBack(node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Compiler compiler0 = new Compiler();
    compiler0.setNormalized();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    peepholeSubstituteAlternateSyntax0.beginTraversal(nodeTraversal0);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isLocalResultCall());
}","/**
 * Returns true if this node is a function or constructor call that
 * returns a primitive or a local object (an object that has no other
 * references).
 */"
"public boolean isOnlyModifiesThisCall() {
    return areBitFlagsSet(getSideEffectFlags() & Node.NO_SIDE_EFFECTS, Node.FLAG_GLOBAL_STATE_UNMODIFIED | Node.FLAG_ARGUMENTS_UNMODIFIED | Node.FLAG_NO_THROWS);
}","public void test2830() throws Throwable {
    Node node0 = new Node(37, 37, 37);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Compiler compiler0 = new Compiler();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    peepholeSubstituteAlternateSyntax0.beginTraversal(nodeTraversal0);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isOnlyModifiesThisCall());
}","/**
 * @return Whether the only side-effect is ""modifies this""
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (node.getType() != Token.CALL) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            return tryFoldLiteralConstructor(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2931() throws Throwable {
    Node node0 = new Node(37);
    node0.addChildToBack(node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax();
    Compiler compiler0 = new Compiler();
    compiler0.setNormalized();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    peepholeSubstituteAlternateSyntax0.beginTraversal(nodeTraversal0);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(22, Node.TARGETBLOCK_PROP);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"static boolean containsUnicodeEscape(String s) {
    String esc = CodeGenerator.regexpEscape(s);
    for (int i = -1; (i = esc.indexOf(""\\u"", i + 1)) >= 0; ) {
        int nSlashes = 0;
        while (i - nSlashes > 0 && '\\' == esc.charAt(i - nSlashes - 1)) {
            ++nSlashes;
        }
        // if there are an even number of slashes before the \ u then it is a
        // unicode literal.
        if (0 == (nSlashes & 1)) {
            return true;
        }
    }
    return false;
}","public void test3032() throws Throwable {
    boolean boolean0 = PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(""k[j\\u"");
    assertTrue(boolean0);
}","/**
 * true if the javascript string would contain a unicode escape when written
 * out as the body of a regular expression literal.
 */"
