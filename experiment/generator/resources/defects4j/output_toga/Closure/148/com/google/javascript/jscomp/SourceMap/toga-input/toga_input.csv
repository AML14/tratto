focal_method,test_prefix,docstring
"void setStartingPosition(int offsetLine, int offsetIndex) {
    // TODO(johnlenz): correct this.
    // Preconditions.checkState(mappings.isEmpty(),
    //     ""Must be set prior to adding mappings"");
    offsetPosition = new Position(offsetLine, offsetIndex);
}","public void test000() throws Throwable {
    SourceMap sourceMap0 = new SourceMap();
    sourceMap0.setStartingPosition(1950, 1950);
}","/**
 * Sets the source code that exists in the buffer to which the
 * generated code is being generated. This ensures that the source map
 * accurately reflects the fact that the source is being appended to
 * an existing buffer and as such, does not start at line 0, position 0
 * but rather some other line and position.
 *
 * @param offsetLine The index of the current line being printed.
 * @param offsetIndex The column index of the current character being printed.
 */"
"void reset() {
    mappings = Lists.newArrayList();
    offsetPosition = new Position(0, 0);
    prefixPosition = new Position(0, 0);
}","public void test011() throws Throwable {
    SourceMap sourceMap0 = new SourceMap();
    sourceMap0.reset();
}","/**
 * Resets the source map for reuse for the generation of a new source file.
 */"
"void addMapping(Node node, Position startPosition, Position endPosition) {
    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);
    // If the node does not have an associated source file or
    // its line number is -1, then the node does not have sufficient
    // information for a mapping to be useful.
    if (sourceFile == null || node.getLineno() < 0) {
        return;
    }
    String escapedSourceFile;
    if (lastSourceFile != sourceFile) {
        // yes, ""s1 != s2"" not ""!s1.equals(s2)""
        lastSourceFile = sourceFile;
        lastSourceFileEscaped = escapeString(sourceFile);
    }
    escapedSourceFile = lastSourceFileEscaped;
    // Create the new mapping.
    Mapping mapping = new Mapping();
    mapping.id = mappings.size();
    mapping.sourceFile = escapedSourceFile;
    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());
    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);
    if (originalName != null) {
        mapping.originalName = escapeString(originalName);
    }
    // If the mapping is found on the first line, we need to offset
    // its character position by the number of characters found on
    // the *last* line of the source file to which the code is
    // being generated.
    int offsetLine = offsetPosition.getLineNumber();
    int startOffsetPosition = offsetPosition.getCharacterIndex();
    int endOffsetPosition = offsetPosition.getCharacterIndex();
    if (startPosition.getLineNumber() > 0) {
        startOffsetPosition = 0;
    }
    if (endPosition.getLineNumber() > 0) {
        endOffsetPosition = 0;
    }
    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);
    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);
    mappings.add(mapping);
}","public void test032() throws Throwable {
    SourceMap sourceMap0 = new SourceMap();
    Node node0 = Node.newString(""LC2'5#j2=^o1g^C_a"");
    Position position0 = new Position(1, 4095);
    sourceMap0.addMapping(node0, position0, position0);
    assertEquals(26, Node.DIRECTCALL_PROP);
}","/**
 * Adds a mapping for the given node.  Mappings must be added in order.
 *
 * @param node The node that the new mapping represents.
 * @param startPosition The position on the starting line
 * @param endPosition The position on the ending line.
 */"
"void addMapping(Node node, Position startPosition, Position endPosition) {
    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);
    // If the node does not have an associated source file or
    // its line number is -1, then the node does not have sufficient
    // information for a mapping to be useful.
    if (sourceFile == null || node.getLineno() < 0) {
        return;
    }
    String escapedSourceFile;
    if (lastSourceFile != sourceFile) {
        // yes, ""s1 != s2"" not ""!s1.equals(s2)""
        lastSourceFile = sourceFile;
        lastSourceFileEscaped = escapeString(sourceFile);
    }
    escapedSourceFile = lastSourceFileEscaped;
    // Create the new mapping.
    Mapping mapping = new Mapping();
    mapping.id = mappings.size();
    mapping.sourceFile = escapedSourceFile;
    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());
    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);
    if (originalName != null) {
        mapping.originalName = escapeString(originalName);
    }
    // If the mapping is found on the first line, we need to offset
    // its character position by the number of characters found on
    // the *last* line of the source file to which the code is
    // being generated.
    int offsetLine = offsetPosition.getLineNumber();
    int startOffsetPosition = offsetPosition.getCharacterIndex();
    int endOffsetPosition = offsetPosition.getCharacterIndex();
    if (startPosition.getLineNumber() > 0) {
        startOffsetPosition = 0;
    }
    if (endPosition.getLineNumber() > 0) {
        endOffsetPosition = 0;
    }
    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);
    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);
    mappings.add(mapping);
}","public void test043() throws Throwable {
    SourceMap sourceMap0 = new SourceMap();
    Node node0 = Node.newString(22, ""\""Z{)3m=.vhNxmrqpi"");
    node0.putProp(38, ""\""Z{)3m=.vhNxmrqpi"");
    Position position0 = new Position(5, 16);
    sourceMap0.addMapping(node0, position0, position0);
    assertEquals(12, Node.COLUMN_BITS);
}","/**
 * Adds a mapping for the given node.  Mappings must be added in order.
 *
 * @param node The node that the new mapping represents.
 * @param startPosition The position on the starting line
 * @param endPosition The position on the ending line.
 */"
"public boolean isUnscopedQualifiedName() {
    switch(getType()) {
        case Token.NAME:
            return true;
        case Token.GETPROP:
            return getFirstChild().isUnscopedQualifiedName();
        default:
            return false;
    }
}","public void test065() throws Throwable {
    SourceMap sourceMap0 = new SourceMap();
    Node node0 = Node.newString(22, ""\""Z{)hm=.vhNxmOqpi"", 22, 22);
    node0.putProp(38, ""\""Z{)hm=.vhNxmOqpi"");
    Position position0 = new Position(1, (-2785));
    node0.putProp(40, ""]\n"");
    sourceMap0.addMapping(node0, position0, position0);
    assertFalse(node0.isUnscopedQualifiedName());
}","/**
 * Returns whether a node corresponds to a simple or a qualified name without
 * a ""this"" reference, such as <code>a.b.c</code>, but not <code>this.a</code>
 * .
 */"
"void setWrapperPrefix(String prefix) {
    // Determine the current line and character position.
    int prefixLine = 0;
    int prefixIndex = 0;
    for (int i = 0; i < prefix.length(); ++i) {
        if (prefix.charAt(i) == '\n') {
            prefixLine++;
            prefixIndex = 0;
        } else {
            prefixIndex++;
        }
    }
    prefixPosition = new Position(prefixLine, prefixIndex);
}","public void test076() throws Throwable {
    SourceMap sourceMap0 = new SourceMap();
    sourceMap0.setWrapperPrefix(""[]\n"");
}","/**
 * Sets the prefix used for wrapping the generated source file before
 * it is output. This ensures that the source map is adjusted as
 * needed.
 *
 * @param prefix The prefix that is added before the generated source code.
 */"
"public void appendTo(Appendable out, String name) throws IOException {
    // Write the mappings out to the file. The format of the generated
    // source map is three sections, each deliminated by a magic comment.
    //
    // The first section contains an array for each line of the generated
    // code, where each element in the array is the ID of the mapping which
    // best represents the index-th character found on that line of the
    // generated source code.
    //
    // The second section contains an array per generated line. Unused.
    //
    // The third and final section contains an array per line, each of which
    // represents a mapping with a unique ID. The mappings are added in order.
    // The array itself contains a tuple representing
    // ['source file', line, col (, 'original name')]
    //
    // Example for 2 lines of generated code (with line numbers added for
    // readability):
    //
    // 1)  /** Begin line maps. **/{ ""count"": 2 }
    // 2)  [0,0,0,0,0,0,1,1,1,1,2]
    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]
    // 4)  /** Begin file information. **/
    // 5)  []
    // 6)  []
    // 7)  /** Begin mapping definitions. **/
    // 8)  [""a.js"", 1, 34]
    // 9)  [""a.js"", 5, 2]
    // 10) [""b.js"", 1, 3, ""event""]
    // 11) [""c.js"", 1, 4]
    // 12) [""d.js"", 3, 78, ""foo""]
    int maxLine = findLastLine();
    // Add the line character maps.
    out.append(""/** Begin line maps. **/{ \""file\"" : "");
    out.append(escapeString(name));
    out.append("", \""count\"": "");
    out.append(String.valueOf(maxLine + 1));
    out.append("" }\n"");
    (new LineMapper(out)).appendLineMappings();
    // Add the source file maps.
    out.append(""/** Begin file information. **/\n"");
    // This section is unused but we need one entry per line to
    // prevent changing the format.
    for (int i = 0; i <= maxLine; ++i) {
        out.append(""[]\n"");
    }
    // Add the mappings themselves.
    out.append(""/** Begin mapping definitions. **/\n"");
    for (Mapping mapping : mappings) {
        mapping.appendTo(out);
        out.append(""\n"");
    }
}","public void test087() throws Throwable {
    SourceMap sourceMap0 = new SourceMap();
    StringWriter stringWriter0 = new StringWriter();
    // Undeclared exception!
    try {
        sourceMap0.appendTo(stringWriter0, ""F8`xq%`^\""KExo_3+5"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Appends the source map in LavaBug format to the given buffer.
 *
 * @param out The stream to which the map will be appended.
 * @param name The name of the generated source file that this source map
 *   represents.
 */"
"public void appendTo(Appendable out, String name) throws IOException {
    // Write the mappings out to the file. The format of the generated
    // source map is three sections, each deliminated by a magic comment.
    //
    // The first section contains an array for each line of the generated
    // code, where each element in the array is the ID of the mapping which
    // best represents the index-th character found on that line of the
    // generated source code.
    //
    // The second section contains an array per generated line. Unused.
    //
    // The third and final section contains an array per line, each of which
    // represents a mapping with a unique ID. The mappings are added in order.
    // The array itself contains a tuple representing
    // ['source file', line, col (, 'original name')]
    //
    // Example for 2 lines of generated code (with line numbers added for
    // readability):
    //
    // 1)  /** Begin line maps. **/{ ""count"": 2 }
    // 2)  [0,0,0,0,0,0,1,1,1,1,2]
    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]
    // 4)  /** Begin file information. **/
    // 5)  []
    // 6)  []
    // 7)  /** Begin mapping definitions. **/
    // 8)  [""a.js"", 1, 34]
    // 9)  [""a.js"", 5, 2]
    // 10) [""b.js"", 1, 3, ""event""]
    // 11) [""c.js"", 1, 4]
    // 12) [""d.js"", 3, 78, ""foo""]
    int maxLine = findLastLine();
    // Add the line character maps.
    out.append(""/** Begin line maps. **/{ \""file\"" : "");
    out.append(escapeString(name));
    out.append("", \""count\"": "");
    out.append(String.valueOf(maxLine + 1));
    out.append("" }\n"");
    (new LineMapper(out)).appendLineMappings();
    // Add the source file maps.
    out.append(""/** Begin file information. **/\n"");
    // This section is unused but we need one entry per line to
    // prevent changing the format.
    for (int i = 0; i <= maxLine; ++i) {
        out.append(""[]\n"");
    }
    // Add the mappings themselves.
    out.append(""/** Begin mapping definitions. **/\n"");
    for (Mapping mapping : mappings) {
        mapping.appendTo(out);
        out.append(""\n"");
    }
}","public void test1312() throws Throwable {
    SourceMap sourceMap0 = new SourceMap();
    Node node0 = Node.newString(22, ""\""Z{)hm=.vhNxmOqpi"", 22, 22);
    node0.putProp(38, ""\""Z{)hm=.vhNxmOqpi"");
    Position position0 = new Position((-2), 0);
    sourceMap0.addMapping(node0, position0, position0);
    StringWriter stringWriter0 = new StringWriter();
    // Undeclared exception!
    try {
        sourceMap0.appendTo(stringWriter0, ""\""Z{)hm=.vhNxmOqpi"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        //
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Appends the source map in LavaBug format to the given buffer.
 *
 * @param out The stream to which the map will be appended.
 * @param name The name of the generated source file that this source map
 *   represents.
 */"
"public void appendTo(Appendable out, String name) throws IOException {
    // Write the mappings out to the file. The format of the generated
    // source map is three sections, each deliminated by a magic comment.
    //
    // The first section contains an array for each line of the generated
    // code, where each element in the array is the ID of the mapping which
    // best represents the index-th character found on that line of the
    // generated source code.
    //
    // The second section contains an array per generated line. Unused.
    //
    // The third and final section contains an array per line, each of which
    // represents a mapping with a unique ID. The mappings are added in order.
    // The array itself contains a tuple representing
    // ['source file', line, col (, 'original name')]
    //
    // Example for 2 lines of generated code (with line numbers added for
    // readability):
    //
    // 1)  /** Begin line maps. **/{ ""count"": 2 }
    // 2)  [0,0,0,0,0,0,1,1,1,1,2]
    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]
    // 4)  /** Begin file information. **/
    // 5)  []
    // 6)  []
    // 7)  /** Begin mapping definitions. **/
    // 8)  [""a.js"", 1, 34]
    // 9)  [""a.js"", 5, 2]
    // 10) [""b.js"", 1, 3, ""event""]
    // 11) [""c.js"", 1, 4]
    // 12) [""d.js"", 3, 78, ""foo""]
    int maxLine = findLastLine();
    // Add the line character maps.
    out.append(""/** Begin line maps. **/{ \""file\"" : "");
    out.append(escapeString(name));
    out.append("", \""count\"": "");
    out.append(String.valueOf(maxLine + 1));
    out.append("" }\n"");
    (new LineMapper(out)).appendLineMappings();
    // Add the source file maps.
    out.append(""/** Begin file information. **/\n"");
    // This section is unused but we need one entry per line to
    // prevent changing the format.
    for (int i = 0; i <= maxLine; ++i) {
        out.append(""[]\n"");
    }
    // Add the mappings themselves.
    out.append(""/** Begin mapping definitions. **/\n"");
    for (Mapping mapping : mappings) {
        mapping.appendTo(out);
        out.append(""\n"");
    }
}","public void test1413() throws Throwable {
    SourceMap sourceMap0 = new SourceMap();
    Node node0 = new Node(26, 26, 95);
    node0.putProp(38, ""aZ%$d9"");
    Position position0 = new Position(0, (-1835));
    sourceMap0.addMapping(node0, position0, position0);
    StringWriter stringWriter0 = new StringWriter();
    // Undeclared exception!
    try {
        sourceMap0.appendTo(stringWriter0, ""]\n"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Appends the source map in LavaBug format to the given buffer.
 *
 * @param out The stream to which the map will be appended.
 * @param name The name of the generated source file that this source map
 *   represents.
 */"
