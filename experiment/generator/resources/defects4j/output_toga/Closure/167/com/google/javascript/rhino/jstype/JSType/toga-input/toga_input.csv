focal_method,test_prefix,docstring
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test0000() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    booleanType0.getTypesUnderEquality(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public boolean isAllType() {
    return false;
}","public void test0001() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    booleanType0.getTypesUnderEquality(errorFunctionType0);
    assertFalse(booleanType0.isAllType());
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test0012() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) booleanType0.autoboxesTo();
    instanceObjectType0.getTypesUnderShallowEquality(booleanType0);
    assertTrue(instanceObjectType0.hasCachedValues());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test0023() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Named type with empty name component"", 0, 1);
    namedType0.resolve(simpleErrorReporter0, errorFunctionType0);
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test0024() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Named type with empty name component"", 0, 1);
    namedType0.resolve(simpleErrorReporter0, errorFunctionType0);
    assertTrue(namedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test0035() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    boolean boolean0 = errorFunctionType0.isStringValueType();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isAllType() {
    return false;
}","public void test0036() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    boolean boolean0 = errorFunctionType0.isStringValueType();
    assertFalse(errorFunctionType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test0037() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    boolean boolean0 = errorFunctionType0.isStringValueType();
    assertFalse(errorFunctionType0.isNoType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test0038() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    boolean boolean0 = errorFunctionType0.isStringValueType();
    assertFalse(errorFunctionType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test0039() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    boolean boolean0 = errorFunctionType0.isStringValueType();
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test00310() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    boolean boolean0 = errorFunctionType0.isStringValueType();
    assertFalse(errorFunctionType0.isNoObjectType());
}",""
"public boolean isStringValueType() {
    return false;
}","public void test00311() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    boolean boolean0 = errorFunctionType0.isStringValueType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00412() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isBooleanObjectType();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isBooleanObjectType() {
    return false;
}","public void test00413() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isBooleanObjectType();
    assertFalse(boolean0);
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test00514() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = jSType0.autobox();
    assertFalse(jSType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test00515() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = jSType0.autobox();
    assertFalse(jSType1.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00516() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = jSType0.autobox();
    assertFalse(jSType1.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isAllType() {
    return false;
}","public void test00617() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getJSDocInfo();
    assertFalse(booleanType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test00618() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getJSDocInfo();
    assertFalse(booleanType0.isNoType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test00619() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getJSDocInfo();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00620() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getJSDocInfo();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test00621() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getJSDocInfo();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public String toDebugHashCodeString() {
    return ""{"" + this.hashCode() + ""}"";
}","public void test00722() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    String string0 = voidType0.toDebugHashCodeString();
    assertEquals(""{1}"", string0);
}","/**
 * A hash code function for diagnosing complicated issues
 * around type-identity.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test00723() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    String string0 = voidType0.toDebugHashCodeString();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isRegexpType() {
    return false;
}","public void test00824() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isRegexpType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test00825() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isRegexpType();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test00926() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    JSType jSType0 = voidType0.collapseUnion();
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test01027() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isString();
    assertFalse(noResolvedType0.hasCachedValues());
}",""
"public boolean isAllType() {
    return false;
}","public void test01028() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isString();
    assertFalse(noResolvedType0.isAllType());
}",""
"public final boolean isString() {
    return this.isSubtype(getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));
}","public void test01029() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isString();
    assertTrue(boolean0);
}","/**
 * Tests whether the type is a string (value or Object).
 * @return {@code this &lt;: (String, string)}
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test01030() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isString();
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isDateType() {
    return false;
}","public void test01131() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isDateType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01132() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isDateType();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isUnionType() {
    return toMaybeUnionType() != null;
}","public void test01233() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertTrue(jSType0.isUnionType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test01234() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01235() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNullType() {
    return false;
}","public void test01236() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(jSType0.isNullType());
}",""
"public boolean isNoType() {
    return false;
}","public void test01237() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(voidType0.isNoType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test01238() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public boolean isAllType() {
    return false;
}","public void test01239() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(voidType0.isAllType());
}",""
"public boolean isVoidType() {
    return false;
}","public void test01240() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(voidType0);
    voidType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(jSType0.isVoidType());
}",""
"public boolean isAllType() {
    return false;
}","public void test01341() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.toAnnotationString();
    assertFalse(booleanType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test01342() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.toAnnotationString();
    assertFalse(booleanType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01343() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.toAnnotationString();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test01344() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.toAnnotationString();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test01345() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.toAnnotationString();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01446() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isStringObjectType();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isStringObjectType() {
    return false;
}","public void test01447() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isStringObjectType();
    assertFalse(boolean0);
}",""
"public boolean isNullType() {
    return false;
}","public void test01548() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""zGr"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    JSType.TypePair jSType_TypePair0 = arrowType0.getTypesUnderShallowInequality(errorFunctionType0);
    assertFalse(arrowType0.isNullType());
}",""
"public boolean isVoidType() {
    return false;
}","public void test01549() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""zGr"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    JSType.TypePair jSType_TypePair0 = arrowType0.getTypesUnderShallowInequality(errorFunctionType0);
    assertFalse(arrowType0.isVoidType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test01550() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""zGr"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    JSType.TypePair jSType_TypePair0 = arrowType0.getTypesUnderShallowInequality(errorFunctionType0);
    boolean boolean0 = jSType_TypePair0.typeA.matchesObjectContext();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isAllType() {
    return false;
}","public void test01551() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""zGr"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    JSType.TypePair jSType_TypePair0 = arrowType0.getTypesUnderShallowInequality(errorFunctionType0);
    boolean boolean0 = jSType_TypePair0.typeA.matchesObjectContext();
    assertFalse(arrowType0.isAllType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test01552() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""zGr"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    JSType.TypePair jSType_TypePair0 = arrowType0.getTypesUnderShallowInequality(errorFunctionType0);
    boolean boolean0 = jSType_TypePair0.typeA.matchesObjectContext();
    assertFalse(arrowType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01553() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""zGr"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    JSType.TypePair jSType_TypePair0 = arrowType0.getTypesUnderShallowInequality(errorFunctionType0);
    boolean boolean0 = jSType_TypePair0.typeA.matchesObjectContext();
    assertFalse(arrowType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test01554() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""zGr"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    JSType.TypePair jSType_TypePair0 = arrowType0.getTypesUnderShallowInequality(errorFunctionType0);
    boolean boolean0 = jSType_TypePair0.typeA.matchesObjectContext();
    assertFalse(arrowType0.isNoObjectType());
}",""
"public boolean matchesObjectContext() {
    return false;
}","public void test01555() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""zGr"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    JSType.TypePair jSType_TypePair0 = arrowType0.getTypesUnderShallowInequality(errorFunctionType0);
    boolean boolean0 = jSType_TypePair0.typeA.matchesObjectContext();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in an
 * {@code Object} context, such as the expression in a with statement.
 *
 * Most types we will encounter, except notably {@code null}, have at least
 * the potential for converting to {@code Object}.  Host defined objects can
 * get peculiar.
 */"
"public boolean isNoType() {
    return false;
}","public void test01556() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""zGr"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    JSType.TypePair jSType_TypePair0 = arrowType0.getTypesUnderShallowInequality(errorFunctionType0);
    boolean boolean0 = jSType_TypePair0.typeA.matchesObjectContext();
    assertFalse(arrowType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01657() throws Throwable {
    BooleanType booleanType0 = new BooleanType((JSTypeRegistry) null);
    JSType.toMaybeParameterizedType((JSType) booleanType0);
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNumberObjectType() {
    return false;
}","public void test01758() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isNumberObjectType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01759() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isNumberObjectType();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean matchesStringContext() {
    return primitiveType.matchesStringContext();
}","public void test01860() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null);
    EnumType enumType0 = jSTypeRegistry0.createEnumType("""", (Node) null, arrowType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    boolean boolean0 = enumElementType0.matchesStringContext();
    assertFalse(boolean0);
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test01861() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null);
    EnumType enumType0 = jSTypeRegistry0.createEnumType("""", (Node) null, arrowType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    boolean boolean0 = enumElementType0.matchesStringContext();
    assertFalse(enumElementType0.isNoResolvedType());
}",""
"public boolean isAllType() {
    return false;
}","public void test01862() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null);
    EnumType enumType0 = jSTypeRegistry0.createEnumType("""", (Node) null, arrowType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    boolean boolean0 = enumElementType0.matchesStringContext();
    assertFalse(enumElementType0.isAllType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test01863() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null);
    EnumType enumType0 = jSTypeRegistry0.createEnumType("""", (Node) null, arrowType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    boolean boolean0 = enumElementType0.matchesStringContext();
    assertFalse(enumElementType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test01864() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null);
    EnumType enumType0 = jSTypeRegistry0.createEnumType("""", (Node) null, arrowType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    boolean boolean0 = enumElementType0.matchesStringContext();
    assertFalse(enumElementType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoType() {
    return false;
}","public void test01865() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null);
    EnumType enumType0 = jSTypeRegistry0.createEnumType("""", (Node) null, arrowType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    boolean boolean0 = enumElementType0.matchesStringContext();
    assertFalse(enumElementType0.isNoType());
}",""
"public boolean isNullable() {
    return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE));
}","public void test01966() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    // Undeclared exception!
    try {
        voidType0.isNullable();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tests whether this type is nullable.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test02067() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    voidType0.unboxesTo();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean canTestForEqualityWith(JSType that) {
    return this.testForEquality(that).equals(UNKNOWN);
}","public void test02168() throws Throwable {
    BooleanType booleanType0 = new BooleanType((JSTypeRegistry) null);
    // Undeclared exception!
    try {
        booleanType0.canTestForEqualityWith(booleanType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable. By meaningfully, we mean compatible types that do not lead
 * to step 22 of the definition of the Abstract Equality Comparison
 * Algorithm (11.9.3, page 55&ndash;56) of the ECMA-262 specification.<p>
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test02269() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isNominalConstructor();
    assertFalse(boolean0);
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"public boolean isConstructor() {
    return false;
}","public void test02270() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isNominalConstructor();
    assertFalse(voidType0.isConstructor());
}","/**
 * Whether this type is a {@link FunctionType} that is a constructor or a
 * named type that points to such a type.
 */"
"public boolean isInterface() {
    return false;
}","public void test02271() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isNominalConstructor();
    assertFalse(voidType0.isInterface());
}","/**
 * Whether this type is a {@link FunctionType} that is an interface or a named
 * type that points to such a type.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test02272() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isNominalConstructor();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test02373() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isArrayType();
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test02374() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isArrayType();
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test02375() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isArrayType();
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isArrayType() {
    return false;
}","public void test02376() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isArrayType();
    assertFalse(boolean0);
}",""
"public boolean isAllType() {
    return false;
}","public void test02377() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isArrayType();
    assertFalse(booleanType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test02378() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.isArrayType();
    assertFalse(booleanType0.isNoType());
}",""
"public boolean setValidator(Predicate<JSType> validator) {
    return validator.apply(this);
}","public void test02479() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    // Undeclared exception!
    try {
        voidType0.setValidator((Predicate<JSType>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.JSType"", e);
    }
}","/**
 * Certain types have constraints on them at resolution-time.
 * For example, a type in an {@code @extends} annotation must be an
 * object. Clients should inject a validator that emits a warning
 * if the type does not validate, and return false.
 */"
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test02580() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""C2^\""qi3"");
    boolean boolean0 = errorFunctionType0.isBooleanValueType();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test02581() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""C2^\""qi3"");
    boolean boolean0 = errorFunctionType0.isBooleanValueType();
    assertFalse(errorFunctionType0.isNoResolvedType());
}",""
"public boolean isBooleanValueType() {
    return false;
}","public void test02582() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""C2^\""qi3"");
    boolean boolean0 = errorFunctionType0.isBooleanValueType();
    assertFalse(boolean0);
}",""
"public boolean isNoType() {
    return false;
}","public void test02583() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""C2^\""qi3"");
    boolean boolean0 = errorFunctionType0.isBooleanValueType();
    assertFalse(errorFunctionType0.isNoType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test02584() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""C2^\""qi3"");
    boolean boolean0 = errorFunctionType0.isBooleanValueType();
    assertFalse(errorFunctionType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test02585() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""C2^\""qi3"");
    boolean boolean0 = errorFunctionType0.isBooleanValueType();
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isAllType() {
    return false;
}","public void test02586() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""C2^\""qi3"");
    boolean boolean0 = errorFunctionType0.isBooleanValueType();
    assertFalse(errorFunctionType0.isAllType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test02687() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.canBeCalled();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean canBeCalled() {
    return false;
}","public void test02688() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.canBeCalled();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can be used as the
 * 'function' in a function call.
 *
 * @return {@code true} if this type might be callable.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test02789() throws Throwable {
    PriorityQueue<JSType> priorityQueue0 = new PriorityQueue<JSType>();
    UnionType unionType0 = new UnionType((JSTypeRegistry) null, priorityQueue0);
    boolean boolean0 = unionType0.hasDisplayName();
    assertFalse(unionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean hasDisplayName() {
    String displayName = getDisplayName();
    return displayName != null && !displayName.isEmpty();
}","public void test02790() throws Throwable {
    PriorityQueue<JSType> priorityQueue0 = new PriorityQueue<JSType>();
    UnionType unionType0 = new UnionType((JSTypeRegistry) null, priorityQueue0);
    boolean boolean0 = unionType0.hasDisplayName();
    assertFalse(boolean0);
}","/**
 * @return true if the JSType has a user meaningful label.
 */"
"public final boolean isNumber() {
    return this.isSubtype(getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));
}","public void test02891() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    // Undeclared exception!
    try {
        voidType0.isNumber();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tests whether the type is a number (value or Object).
 * @return {@code this &lt;: (Number, number)}
 */"
"@Override
public boolean isOrdinaryFunction() {
    return referencedType.isOrdinaryFunction();
}","public void test02992() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.isOrdinaryFunction();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test02993() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.isOrdinaryFunction();
    assertFalse(templateType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test03094() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(voidType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""wc~Oc?(C"");
    boolean boolean0 = enumElementType0.canTestForShallowEqualityWith(voidType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test03095() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(voidType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, jSType0, ""wc~Oc?(C"");
    boolean boolean0 = enumElementType0.canTestForShallowEqualityWith(voidType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public final ObjectType dereference() {
    return ObjectType.cast(autobox());
}","public void test03196() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ObjectType objectType0 = booleanType0.dereference();
    assertNotNull(objectType0);
}","/**
 * Dereference a type for property access.
 *
 * Autoboxes the type, filters null/undefined, and returns the result
 * iff it's an object.
 */"
"public boolean isAllType() {
    return false;
}","public void test03197() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ObjectType objectType0 = booleanType0.dereference();
    assertFalse(objectType0.isAllType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test03198() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ObjectType objectType0 = booleanType0.dereference();
    assertFalse(objectType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test03199() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ObjectType objectType0 = booleanType0.dereference();
    assertFalse(objectType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test031100() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ObjectType objectType0 = booleanType0.dereference();
    assertFalse(objectType0.isNoObjectType());
}",""
"public boolean isNoType() {
    return false;
}","public void test031101() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ObjectType objectType0 = booleanType0.dereference();
    assertFalse(objectType0.isNoType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test032102() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    boolean boolean0 = numberType0.isNamedType();
    assertFalse(numberType0.isNoResolvedType());
}",""
"public boolean isAllType() {
    return false;
}","public void test032103() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    boolean boolean0 = numberType0.isNamedType();
    assertFalse(numberType0.isAllType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test032104() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    boolean boolean0 = numberType0.isNamedType();
    assertFalse(numberType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoType() {
    return false;
}","public void test032105() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    boolean boolean0 = numberType0.isNamedType();
    assertFalse(numberType0.isNoType());
}",""
"boolean isNamedType() {
    return false;
}","public void test032106() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    boolean boolean0 = numberType0.isNamedType();
    assertFalse(boolean0);
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test032107() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    boolean boolean0 = numberType0.isNamedType();
    assertFalse(numberType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test033108() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    voidType0.matchConstraint(voidType0);
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test034109() throws Throwable {
    AllType allType0 = new AllType((JSTypeRegistry) null);
    boolean boolean0 = allType0.matchesInt32Context();
    assertFalse(allType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean matchesInt32Context() {
    return matchesNumberContext();
}","public void test034110() throws Throwable {
    AllType allType0 = new AllType((JSTypeRegistry) null);
    boolean boolean0 = allType0.matchesInt32Context();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in a
 * 'Int32' context.  This context includes, for example, the operands of a
 * bitwise or operator.  Since we do not currently support integer types,
 * this is a synonym for {@code Number}.
 */"
"public boolean isInstanceType() {
    return false;
}","public void test035111() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isInstanceType();
    assertFalse(boolean0);
}","/**
 * Whether this type is an Instance object of some constructor.
 * Does not necessarily mean this is an {@link InstanceObjectType}.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test035112() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isInstanceType();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean isCheckedUnknownType() {
    return referencedType.isCheckedUnknownType();
}","public void test036113() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = proxyObjectType0.isCheckedUnknownType();
    assertFalse(boolean0);
}",""
"@Override
public boolean isAllType() {
    return referencedType.isAllType();
}","public void test036114() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = proxyObjectType0.isCheckedUnknownType();
    assertFalse(proxyObjectType0.isAllType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test036115() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = proxyObjectType0.isCheckedUnknownType();
    assertFalse(proxyObjectType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"boolean isTheObjectType() {
    return false;
}","public void test037116() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isTheObjectType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test037117() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.isTheObjectType();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test038118() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.UnionType"");
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, errorFunctionType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, instanceObjectType0, ""Not declared as a type name"");
    boolean boolean0 = errorFunctionType0.canTestForShallowEqualityWith(enumElementType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test038119() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.UnionType"");
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, errorFunctionType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, instanceObjectType0, ""Not declared as a type name"");
    boolean boolean0 = errorFunctionType0.canTestForShallowEqualityWith(enumElementType0);
    assertFalse(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test039120() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    stringType0.matchesUint32Context();
    assertFalse(stringType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isAllType() {
    return false;
}","public void test039121() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    stringType0.matchesUint32Context();
    assertFalse(stringType0.isAllType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test039122() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    stringType0.matchesUint32Context();
    assertFalse(stringType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test039123() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    stringType0.matchesUint32Context();
    assertFalse(stringType0.isNoObjectType());
}",""
"public boolean isNoType() {
    return false;
}","public void test039124() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    stringType0.matchesUint32Context();
    assertFalse(stringType0.isNoType());
}",""
"public boolean isEnumType() {
    return toMaybeEnumType() != null;
}","public void test040125() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noType0, noType0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null, indexedType0);
    boolean boolean0 = arrowType0.isEnumType();
    assertFalse(boolean0);
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test040126() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noType0, noType0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null, indexedType0);
    boolean boolean0 = arrowType0.isEnumType();
    assertFalse(arrowType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test040127() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noType0, noType0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null, indexedType0);
    boolean boolean0 = arrowType0.isEnumType();
    assertFalse(arrowType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isAllType() {
    return false;
}","public void test040128() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noType0, noType0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null, indexedType0);
    boolean boolean0 = arrowType0.isEnumType();
    assertFalse(arrowType0.isAllType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test040129() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noType0, noType0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null, indexedType0);
    boolean boolean0 = arrowType0.isEnumType();
    assertFalse(arrowType0.isNoObjectType());
}",""
"public boolean isNoType() {
    return false;
}","public void test040130() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noType0, noType0);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType((Node) null, indexedType0);
    boolean boolean0 = arrowType0.isEnumType();
    assertFalse(arrowType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test041131() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isNumberValueType();
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isAllType() {
    return false;
}","public void test041132() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isNumberValueType();
    assertFalse(noResolvedType0.isAllType());
}",""
"public boolean isNumberValueType() {
    return false;
}","public void test041133() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isNumberValueType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test042134() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test042135() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.forceResolve(simpleErrorReporter0, (StaticScope<JSType>) null);
    assertTrue(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test043136() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    voidType0.clearResolved();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test044137() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.isFunctionPrototypeType();
    assertFalse(arrowType0.isNoResolvedType());
}",""
"public boolean isFunctionPrototypeType() {
    return false;
}","public void test044138() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.isFunctionPrototypeType();
    assertFalse(boolean0);
}","/**
 * Whether this is the prototype of a function.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test044139() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.isFunctionPrototypeType();
    assertFalse(arrowType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test044140() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.isFunctionPrototypeType();
    assertFalse(arrowType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test044141() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.isFunctionPrototypeType();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isNoType() {
    return false;
}","public void test044142() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.isFunctionPrototypeType();
    assertFalse(arrowType0.isNoType());
}",""
"public boolean isAllType() {
    return false;
}","public void test044143() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.isFunctionPrototypeType();
    assertFalse(arrowType0.isAllType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test045144() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) voidType0, (JSType) voidType0, (JSType) voidType0, (JSType) voidType0, (JSType) voidType0, (JSType) voidType0, (JSType) voidType0, (JSType) voidType0, (JSType) voidType0);
    UnionType unionType0 = new UnionType((JSTypeRegistry) null, immutableList0);
    unionType0.toStringHelper(true);
    assertFalse(unionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean hasDisplayName() {
    String displayName = getDisplayName();
    return displayName != null && !displayName.isEmpty();
}","public void test046145() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(boolean0);
}","/**
 * @return true if the JSType has a user meaningful label.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test046146() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoType() {
    return false;
}","public void test046147() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isNoType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test046148() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test046149() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test046150() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isNoResolvedType());
}",""
"public boolean isAllType() {
    return false;
}","public void test046151() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isAllType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test047152() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""M%wwv73OYGw38^PiR"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test047153() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""M%wwv73OYGw38^PiR"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test047154() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""M%wwv73OYGw38^PiR"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isNoObjectType());
}",""
"public boolean hasDisplayName() {
    String displayName = getDisplayName();
    return displayName != null && !displayName.isEmpty();
}","public void test047155() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""M%wwv73OYGw38^PiR"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertTrue(boolean0);
}","/**
 * @return true if the JSType has a user meaningful label.
 */"
"public boolean isAllType() {
    return false;
}","public void test047156() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""M%wwv73OYGw38^PiR"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isAllType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test047157() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""M%wwv73OYGw38^PiR"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertTrue(errorFunctionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isNoType() {
    return false;
}","public void test047158() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""M%wwv73OYGw38^PiR"");
    boolean boolean0 = errorFunctionType0.hasDisplayName();
    assertFalse(errorFunctionType0.isNoType());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test048159() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    boolean boolean0 = noResolvedType0.canTestForShallowEqualityWith(parameterizedType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean isAllType() {
    return false;
}","public void test048160() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    boolean boolean0 = noResolvedType0.canTestForShallowEqualityWith(parameterizedType0);
    assertFalse(noResolvedType0.isAllType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test048161() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    boolean boolean0 = noResolvedType0.canTestForShallowEqualityWith(parameterizedType0);
    assertFalse(parameterizedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test049162() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "".LQv=]31fidt4-wJRV"");
    FunctionType functionType0 = errorFunctionType0.cloneWithoutArrowType();
    boolean boolean0 = errorFunctionType0.canTestForShallowEqualityWith(functionType0);
    assertFalse(functionType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test049163() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "".LQv=]31fidt4-wJRV"");
    FunctionType functionType0 = errorFunctionType0.cloneWithoutArrowType();
    boolean boolean0 = errorFunctionType0.canTestForShallowEqualityWith(functionType0);
    assertFalse(functionType0.isNoObjectType());
}",""
"public boolean isNoType() {
    return false;
}","public void test049164() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "".LQv=]31fidt4-wJRV"");
    FunctionType functionType0 = errorFunctionType0.cloneWithoutArrowType();
    boolean boolean0 = errorFunctionType0.canTestForShallowEqualityWith(functionType0);
    assertFalse(functionType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test049165() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "".LQv=]31fidt4-wJRV"");
    FunctionType functionType0 = errorFunctionType0.cloneWithoutArrowType();
    boolean boolean0 = errorFunctionType0.canTestForShallowEqualityWith(functionType0);
    assertFalse(functionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test049166() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "".LQv=]31fidt4-wJRV"");
    FunctionType functionType0 = errorFunctionType0.cloneWithoutArrowType();
    boolean boolean0 = errorFunctionType0.canTestForShallowEqualityWith(functionType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean isAllType() {
    return false;
}","public void test049167() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "".LQv=]31fidt4-wJRV"");
    FunctionType functionType0 = errorFunctionType0.cloneWithoutArrowType();
    boolean boolean0 = errorFunctionType0.canTestForShallowEqualityWith(functionType0);
    assertFalse(functionType0.isAllType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test050168() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isGlobalThisType();
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isGlobalThisType() {
    return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS);
}","public void test050169() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isGlobalThisType();
    assertFalse(boolean0);
}","/**
 * Returns true if this is a global this type.
 */"
"public boolean isAllType() {
    return false;
}","public void test050170() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isGlobalThisType();
    assertFalse(noResolvedType0.isAllType());
}",""
"public static FunctionType toMaybeFunctionType(JSType type) {
    return type == null ? null : type.toMaybeFunctionType();
}","public void test051171() throws Throwable {
    FunctionType functionType0 = JSType.toMaybeFunctionType((JSType) null);
    assertNull(functionType0);
}","/**
 * Null-safe version of toMaybeFunctionType().
 */"
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test052172() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(recordType0);
    assertTrue(recordType0.hasCachedValues());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test052173() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(recordType0);
    assertFalse(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test053174() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.isParameterizedType();
    assertFalse(voidType0.isNoResolvedType());
}",""
"public boolean isAllType() {
    return false;
}","public void test053175() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.isParameterizedType();
    assertFalse(voidType0.isAllType());
}",""
"public final boolean isParameterizedType() {
    return toMaybeParameterizedType() != null;
}","public void test053176() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.isParameterizedType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test053177() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.isParameterizedType();
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test053178() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.isParameterizedType();
    assertFalse(voidType0.isNoObjectType());
}",""
"public boolean isNoType() {
    return false;
}","public void test053179() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.isParameterizedType();
    assertFalse(voidType0.isNoType());
}",""
"public final boolean isParameterizedType() {
    return toMaybeParameterizedType() != null;
}","public void test054180() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    boolean boolean0 = parameterizedType0.isParameterizedType();
    assertTrue(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test054181() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    boolean boolean0 = parameterizedType0.isParameterizedType();
    assertFalse(parameterizedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isAllType() {
    return false;
}","public void test054182() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    boolean boolean0 = parameterizedType0.isParameterizedType();
    assertFalse(noResolvedType0.isAllType());
}",""
"public static ParameterizedType toMaybeParameterizedType(JSType type) {
    return type == null ? null : type.toMaybeParameterizedType();
}","public void test055183() throws Throwable {
    ParameterizedType parameterizedType0 = JSType.toMaybeParameterizedType((JSType) null);
    assertNull(parameterizedType0);
}","/**
 * Null-safe version of toMaybeParameterizedType().
 */"
"public final boolean isTemplateType() {
    return toMaybeTemplateType() != null;
}","public void test056184() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Named type with empty name component"");
    boolean boolean0 = templateType0.isTemplateType();
    assertTrue(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test056185() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Named type with empty name component"");
    boolean boolean0 = templateType0.isTemplateType();
    assertFalse(templateType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test057186() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    JSType.toMaybeTemplateType((JSType) voidType0);
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public static TemplateType toMaybeTemplateType(JSType type) {
    return type == null ? null : type.toMaybeTemplateType();
}","public void test058187() throws Throwable {
    TemplateType templateType0 = JSType.toMaybeTemplateType((JSType) null);
    assertNull(templateType0);
}","/**
 * Null-safe version of toMaybeTemplateType().
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test059188() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.hasAnyTemplateInternal();
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasAnyTemplateInternal() {
    return !getTemplateTypeNames().isEmpty() || typeOfThis.hasAnyTemplate() || call.hasAnyTemplate();
}","public void test059189() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.hasAnyTemplateInternal();
    assertFalse(boolean0);
}",""
"public boolean isAllType() {
    return false;
}","public void test059190() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.hasAnyTemplateInternal();
    assertFalse(noResolvedType0.isAllType());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test060191() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""`cP4d8V_>)XLj>4WLaT"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertFalse(boolean0);
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test060192() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""`cP4d8V_>)XLj>4WLaT"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertFalse(functionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isAllType() {
    return false;
}","public void test060193() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""`cP4d8V_>)XLj>4WLaT"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertFalse(functionType0.isAllType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test060194() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""`cP4d8V_>)XLj>4WLaT"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertFalse(functionType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test060195() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""`cP4d8V_>)XLj>4WLaT"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertFalse(functionType0.isNoObjectType());
}",""
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test060196() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""`cP4d8V_>)XLj>4WLaT"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertTrue(functionType0.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isNoType() {
    return false;
}","public void test060197() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""`cP4d8V_>)XLj>4WLaT"", (Node) null);
    boolean boolean0 = functionType0.isNominalConstructor();
    assertFalse(functionType0.isNoType());
}",""
"public boolean isAllType() {
    return false;
}","public void test061198() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isNominalConstructor();
    assertFalse(noResolvedType0.isAllType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test061199() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isNominalConstructor();
    assertFalse(noResolvedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test061200() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.isNominalConstructor();
    assertFalse(boolean0);
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"public boolean isNoType() {
    return false;
}","public void test062201() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Named type with empty name component"");
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(templateType0);
    assertFalse(voidType0.isNoType());
}",""
"public boolean isAllType() {
    return false;
}","public void test062202() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Named type with empty name component"");
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(templateType0);
    assertFalse(voidType0.isAllType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test062203() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Named type with empty name component"");
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(templateType0);
    assertFalse(voidType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test062204() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Named type with empty name component"");
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(templateType0);
    assertFalse(voidType0.isNoResolvedType());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test062205() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Named type with empty name component"");
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(templateType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test062206() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Named type with empty name component"");
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(templateType0);
    assertFalse(templateType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test063207() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(booleanType0.isNoObjectType());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test063208() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(booleanType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean isNoType() {
    return false;
}","public void test063209() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(booleanType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test063210() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isAllType() {
    return false;
}","public void test063211() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(booleanType0.isAllType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test063212() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test064213() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    boolean boolean0 = parameterizedType0.isEquivalentTo(noResolvedType0);
    assertFalse(parameterizedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isAllType() {
    return false;
}","public void test064214() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    boolean boolean0 = parameterizedType0.isEquivalentTo(noResolvedType0);
    assertFalse(noResolvedType0.isAllType());
}",""
"@Override
public boolean isEquivalentTo(JSType that) {
    return (super.isEquivalentTo(that) && JSType.isEquivalent(parameterType, that.toObjectType().getParameterType()));
}","public void test064215() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = new ParameterizedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    boolean boolean0 = parameterizedType0.isEquivalentTo(noResolvedType0);
    assertFalse(boolean0);
}",""
"public static boolean isEquivalent(JSType typeA, JSType typeB) {
    return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB);
}","public void test065216() throws Throwable {
    ParameterizedType parameterizedType0 = new ParameterizedType((JSTypeRegistry) null, (ObjectType) null, (JSType) null);
    boolean boolean0 = JSType.isEquivalent(parameterizedType0, parameterizedType0);
    assertTrue(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test065217() throws Throwable {
    ParameterizedType parameterizedType0 = new ParameterizedType((JSTypeRegistry) null, (ObjectType) null, (JSType) null);
    boolean boolean0 = JSType.isEquivalent(parameterizedType0, parameterizedType0);
    assertFalse(parameterizedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test066218() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.equals((Object) null);
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test066219() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.equals((Object) null);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test067220() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    NumberType numberType0 = new NumberType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.equals(numberType0);
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test067221() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    NumberType numberType0 = new NumberType((JSTypeRegistry) null);
    boolean boolean0 = voidType0.equals(numberType0);
    assertFalse(numberType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isAllType() {
    return false;
}","public void test068222() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.findPropertyType(""Unknown class name"");
    assertFalse(voidType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test068223() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.findPropertyType(""Unknown class name"");
    assertFalse(voidType0.isNoType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test068224() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.findPropertyType(""Unknown class name"");
    assertFalse(voidType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test068225() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.findPropertyType(""Unknown class name"");
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test068226() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.findPropertyType(""Unknown class name"");
    assertFalse(voidType0.isNoResolvedType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test069227() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Unknown class name"");
    enumElementType0.findPropertyType(""Unknown class name"");
    assertFalse(enumElementType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test069228() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Unknown class name"");
    enumElementType0.findPropertyType(""Unknown class name"");
    assertFalse(enumElementType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoType() {
    return false;
}","public void test069229() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Unknown class name"");
    enumElementType0.findPropertyType(""Unknown class name"");
    assertFalse(enumElementType0.isNoType());
}",""
"public boolean isAllType() {
    return false;
}","public void test069230() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Unknown class name"");
    enumElementType0.findPropertyType(""Unknown class name"");
    assertFalse(enumElementType0.isAllType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test069231() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Unknown class name"");
    enumElementType0.findPropertyType(""Unknown class name"");
    assertFalse(enumElementType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test070232() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canAssignTo(stringType0);
    assertFalse(voidType0.isNoResolvedType());
}",""
"public boolean canAssignTo(JSType that) {
    if (this.isSubtype(that)) {
        return true;
    }
    return false;
}","public void test070233() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canAssignTo(stringType0);
    assertFalse(boolean0);
}","/**
 * Tests whether values of {@code this} type can be safely assigned
 * to values of {@code that} type.<p>
 *
 * The default implementation verifies that {@code this} is a subtype
 * of {@code that}.<p>
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test070234() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canAssignTo(stringType0);
    assertFalse(voidType0.isNoObjectType());
}",""
"public boolean isNoType() {
    return false;
}","public void test070235() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canAssignTo(stringType0);
    assertFalse(voidType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test070236() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canAssignTo(stringType0);
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test071237() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(objectType0, objectType0);
    boolean boolean0 = parameterizedType0.canAssignTo(objectType0);
    assertFalse(parameterizedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test071238() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(objectType0, objectType0);
    boolean boolean0 = parameterizedType0.canAssignTo(objectType0);
    assertFalse(objectType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test071239() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(objectType0, objectType0);
    boolean boolean0 = parameterizedType0.canAssignTo(objectType0);
    assertFalse(objectType0.isNoObjectType());
}",""
"@Override
public boolean canAssignTo(JSType that) {
    return referencedType.canAssignTo(that);
}","public void test071240() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(objectType0, objectType0);
    boolean boolean0 = parameterizedType0.canAssignTo(objectType0);
    assertTrue(boolean0);
}",""
"public boolean isAllType() {
    return false;
}","public void test071241() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(objectType0, objectType0);
    boolean boolean0 = parameterizedType0.canAssignTo(objectType0);
    assertFalse(objectType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test071242() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(objectType0, objectType0);
    boolean boolean0 = parameterizedType0.canAssignTo(objectType0);
    assertFalse(objectType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test072243() throws Throwable {
    BooleanType booleanType0 = new BooleanType((JSTypeRegistry) null);
    AllType allType0 = new AllType((JSTypeRegistry) null);
    booleanType0.getTypesUnderEquality(allType0);
    assertFalse(allType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test072244() throws Throwable {
    BooleanType booleanType0 = new BooleanType((JSTypeRegistry) null);
    AllType allType0 = new AllType((JSTypeRegistry) null);
    booleanType0.getTypesUnderEquality(allType0);
    assertFalse(booleanType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test073245() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    noResolvedType0.getTypesUnderInequality(templateType0);
    assertFalse(templateType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isAllType() {
    return false;
}","public void test073246() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    noResolvedType0.getTypesUnderInequality(templateType0);
    assertFalse(noResolvedType0.isAllType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test073247() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    noResolvedType0.getTypesUnderInequality(templateType0);
    assertFalse(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test074248() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType.TypePair jSType_TypePair0 = noResolvedType0.getTypesUnderInequality(noResolvedType0);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"public boolean differsFrom(JSType that) {
    // if there are no unknowns, just use normal equality.
    if (!this.isUnknownType() && !that.isUnknownType()) {
        return !this.isEquivalentTo(that);
    }
    // otherwise, they're different iff one is unknown and the other is not.
    return this.isUnknownType() ^ that.isUnknownType();
}","public void test074249() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType.TypePair jSType_TypePair0 = noResolvedType0.getTypesUnderInequality(noResolvedType0);
    boolean boolean0 = jSType_TypePair0.typeA.differsFrom(jSType_TypePair0.typeB);
    assertFalse(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type.
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"public boolean isNoType() {
    return false;
}","public void test075250() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) booleanType0, (JSType) booleanType0, (JSType) booleanType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType0 = unionType0.collapseUnion();
    booleanType0.testForEqualityHelper(jSType0, unionType0);
    assertFalse(jSType0.isNoType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test075251() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) booleanType0, (JSType) booleanType0, (JSType) booleanType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType0 = unionType0.collapseUnion();
    booleanType0.testForEqualityHelper(jSType0, unionType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test075252() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) booleanType0, (JSType) booleanType0, (JSType) booleanType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType0 = unionType0.collapseUnion();
    booleanType0.testForEqualityHelper(jSType0, unionType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test075253() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) booleanType0, (JSType) booleanType0, (JSType) booleanType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType0 = unionType0.collapseUnion();
    booleanType0.testForEqualityHelper(jSType0, unionType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"public boolean isAllType() {
    return false;
}","public void test075254() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) booleanType0, (JSType) booleanType0, (JSType) booleanType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType0 = unionType0.collapseUnion();
    booleanType0.testForEqualityHelper(jSType0, unionType0);
    assertFalse(unionType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test075255() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) booleanType0, (JSType) booleanType0, (JSType) booleanType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    JSType jSType0 = unionType0.collapseUnion();
    booleanType0.testForEqualityHelper(jSType0, unionType0);
    assertFalse(booleanType0.isNoType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test076256() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    JSType jSType0 = errorFunctionType0.getReturnType();
    jSType0.testForEquality(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public boolean isAllType() {
    return false;
}","public void test076257() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    JSType jSType0 = errorFunctionType0.getReturnType();
    jSType0.testForEquality(errorFunctionType0);
    assertFalse(errorFunctionType0.isAllType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test077258() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.testForEquality(voidType0);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test078259() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    noType0.getTypesUnderInequality(noType0);
    assertTrue(noType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test079260() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    booleanType0.getTypesUnderEquality(noObjectType0);
    assertTrue(noObjectType0.hasCachedValues());
}",""
"public boolean isAllType() {
    return false;
}","public void test079261() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    booleanType0.getTypesUnderEquality(noObjectType0);
    assertFalse(booleanType0.isAllType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test080262() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    noType0.getTypesUnderInequality(voidType0);
    assertTrue(noType0.hasCachedValues());
}",""
"public boolean hasCachedValues() {
    return !unknown;
}","public void test081263() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    ObjectType objectType0 = jSTypeRegistry0.createNativeAnonymousObjectType();
    errorFunctionType0.testForEquality(objectType0);
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test081264() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, """");
    ObjectType objectType0 = jSTypeRegistry0.createNativeAnonymousObjectType();
    errorFunctionType0.testForEquality(objectType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public boolean hasCachedValues() {
    return !unknown;
}","public void test082265() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Named type with empty name component"");
    booleanType0.getTypesUnderEquality(enumElementType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test083266() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    voidType0.testForEquality(jSType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoType() {
    return false;
}","public void test083267() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    voidType0.testForEquality(jSType0);
    assertFalse(voidType0.isNoType());
}",""
"public boolean isAllType() {
    return false;
}","public void test083268() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    voidType0.testForEquality(jSType0);
    assertFalse(voidType0.isAllType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test083269() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    voidType0.testForEquality(jSType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"public final boolean isUnionType() {
    return toMaybeUnionType() != null;
}","public void test083270() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    voidType0.testForEquality(jSType0);
    assertTrue(jSType0.isUnionType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test083271() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    voidType0.testForEquality(jSType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test084272() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NO_OBJECT_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(functionType0);
    assertTrue(functionType0.hasCachedValues());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test084273() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NO_OBJECT_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(functionType0);
    assertFalse(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test085274() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(noType0);
    assertTrue(noType0.hasCachedValues());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test085275() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(noType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test086276() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    noResolvedType0.getLeastSupertype(booleanType0);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test087277() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalNullableType(noResolvedType0);
    noResolvedType0.getLeastSupertype(jSType0);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test088278() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    JSType jSType0 = JSType.getLeastSupertype((JSType) voidType0, (JSType) voidType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test089279() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.canTestForShallowEqualityWith(voidType0);
    assertFalse(voidType0.isNoResolvedType());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test089280() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.canTestForShallowEqualityWith(voidType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean isAllType() {
    return false;
}","public void test089281() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.canTestForShallowEqualityWith(voidType0);
    assertFalse(voidType0.isAllType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test089282() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.canTestForShallowEqualityWith(voidType0);
    assertFalse(templateType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoType() {
    return false;
}","public void test089283() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.canTestForShallowEqualityWith(voidType0);
    assertFalse(voidType0.isNoType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test089284() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.canTestForShallowEqualityWith(voidType0);
    assertFalse(voidType0.isNoObjectType());
}",""
"public boolean hasCachedValues() {
    return !unknown;
}","public void test090285() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.UnionType"");
    FunctionType functionType0 = errorFunctionType0.getSuperClassConstructor();
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, instanceObjectType0, ""Not declared as a type name"");
    boolean boolean0 = errorFunctionType0.canTestForShallowEqualityWith(enumElementType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test090286() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.UnionType"");
    FunctionType functionType0 = errorFunctionType0.getSuperClassConstructor();
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, instanceObjectType0, ""Not declared as a type name"");
    boolean boolean0 = errorFunctionType0.canTestForShallowEqualityWith(enumElementType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test091287() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""W4916m<QC*"");
    JSType jSType0 = jSTypeRegistry0.createOptionalType(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public boolean isNoType() {
    return false;
}","public void test091288() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""W4916m<QC*"");
    JSType jSType0 = jSTypeRegistry0.createOptionalType(errorFunctionType0);
    errorFunctionType0.testForEquality(jSType0);
    assertFalse(errorFunctionType0.isNoType());
}",""
"public boolean hasCachedValues() {
    return !unknown;
}","public void test092289() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Named type with empty name component"");
    JSType jSType0 = JSType.getLeastSupertype((JSType) voidType0, (JSType) enumElementType0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(jSType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test092290() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, booleanType0, ""Named type with empty name component"");
    JSType jSType0 = JSType.getLeastSupertype((JSType) voidType0, (JSType) enumElementType0);
    boolean boolean0 = booleanType0.canTestForShallowEqualityWith(jSType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test093291() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, true);
    boolean boolean0 = recordType0.canTestForShallowEqualityWith(booleanType0);
    assertTrue(recordType0.hasCachedValues());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test093292() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, true);
    boolean boolean0 = recordType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test094293() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, voidType0, ""Named type with empty name component"");
    boolean boolean0 = enumElementType0.canTestForShallowEqualityWith(booleanType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test094294() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, voidType0, ""Named type with empty name component"");
    boolean boolean0 = enumElementType0.canTestForShallowEqualityWith(booleanType0);
    assertFalse(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"static JSType filterNoResolvedType(JSType type) {
    if (type.isNoResolvedType()) {
        // inf(UnresolvedType1, UnresolvedType2) needs to resolve
        // to the base unresolved type, so that the relation is symmetric.
        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);
    } else if (type.isUnionType()) {
        UnionType unionType = type.toMaybeUnionType();
        boolean needsFiltering = false;
        for (JSType alt : unionType.getAlternates()) {
            if (alt.isNoResolvedType()) {
                needsFiltering = true;
                break;
            }
        }
        if (needsFiltering) {
            UnionTypeBuilder builder = new UnionTypeBuilder(type.registry);
            for (JSType alt : unionType.getAlternates()) {
                if (!alt.isNoResolvedType()) {
                    builder.addAlternate(alt);
                }
            }
            return builder.build();
        }
    }
    return type;
}","public void test095295() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = JSType.filterNoResolvedType(noResolvedType0);
    assertNotSame(jSType0, noResolvedType0);
}","/**
 * When computing infima, we may get a situation like
 * inf(Type1, Type2)
 * where both types are unresolved, so they're technically
 * subtypes of one another.
 *
 * If this happens, filter them down to NoResolvedType.
 */"
"public boolean isAllType() {
    return false;
}","public void test095296() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = JSType.filterNoResolvedType(noResolvedType0);
    assertFalse(jSType0.isAllType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test095297() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = JSType.filterNoResolvedType(noResolvedType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {
    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();
    if (literals.contains(outcome)) {
        return this;
    } else {
        return getNativeType(JSTypeNative.NO_TYPE);
    }
}","public void test096298() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    // Undeclared exception!
    try {
        voidType0.getRestrictedTypeGivenToBooleanOutcome(true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Computes the restricted type of this type knowing that the
 * {@code ToBoolean} predicate has a specific value. For more information
 * about the {@code ToBoolean} predicate, see
 * {@link #getPossibleToBooleanOutcomes}.
 *
 * @param outcome the value of the {@code ToBoolean} predicate
 *
 * @return the restricted type, or the Any Type if the underlying type could
 *         not have yielded this ToBoolean value
 *
 * TODO(user): Move this method to the SemanticRAI and use the visit
 * method of types to get the restricted type.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test097299() throws Throwable {
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    JSType jSType0 = voidType0.getRestrictedTypeGivenToBooleanOutcome(false);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test098300() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    booleanType0.getTypesUnderEquality(jSType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"public boolean isNoType() {
    return false;
}","public void test098301() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    booleanType0.getTypesUnderEquality(jSType0);
    assertFalse(booleanType0.isNoType());
}",""
"public final boolean isTemplateType() {
    return toMaybeTemplateType() != null;
}","public void test098302() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    booleanType0.getTypesUnderEquality(jSType0);
    assertFalse(booleanType0.isTemplateType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test098303() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    booleanType0.getTypesUnderEquality(jSType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test098304() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    booleanType0.getTypesUnderEquality(jSType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public boolean isAllType() {
    return false;
}","public void test098305() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(booleanType0);
    booleanType0.getTypesUnderEquality(jSType0);
    assertFalse(booleanType0.isAllType());
}",""
"public boolean hasCachedValues() {
    return !unknown;
}","public void test099306() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    ObjectType objectType0 = jSTypeRegistry0.createNativeAnonymousObjectType();
    JSType jSType0 = JSType.getLeastSupertype((JSType) voidType0, (JSType) objectType0);
    voidType0.getTypesUnderEquality(jSType0);
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test100307() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createNullableType(noResolvedType0);
    noResolvedType0.getTypesUnderInequality(jSType0);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"public boolean isNoType() {
    return false;
}","public void test101308() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getTypesUnderInequality(voidType0);
    assertFalse(booleanType0.isNoType());
}",""
"public boolean isAllType() {
    return false;
}","public void test101309() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getTypesUnderInequality(voidType0);
    assertFalse(booleanType0.isAllType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test101310() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getTypesUnderInequality(voidType0);
    assertFalse(booleanType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test101311() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    booleanType0.getTypesUnderInequality(voidType0);
    assertFalse(booleanType0.isNoResolvedType());
}",""
"public boolean isAllType() {
    return false;
}","public void test102312() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Qh"", 0, 1);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) nullType0, (JSType) errorFunctionType0, (JSType) namedType0, (JSType) errorFunctionType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    unionType0.getTypesUnderShallowInequality(nullType0);
    assertFalse(unionType0.isAllType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test102313() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Qh"", 0, 1);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) nullType0, (JSType) errorFunctionType0, (JSType) namedType0, (JSType) errorFunctionType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    unionType0.getTypesUnderShallowInequality(nullType0);
    assertFalse(unionType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test102314() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Qh"", 0, 1);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) nullType0, (JSType) errorFunctionType0, (JSType) namedType0, (JSType) errorFunctionType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    unionType0.getTypesUnderShallowInequality(nullType0);
    assertFalse(unionType0.isNoObjectType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test102315() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Qh"", 0, 1);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) nullType0, (JSType) errorFunctionType0, (JSType) namedType0, (JSType) errorFunctionType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    unionType0.getTypesUnderShallowInequality(nullType0);
    assertFalse(errorFunctionType0.hasCachedValues());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test102316() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Qh"", 0, 1);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) nullType0, (JSType) errorFunctionType0, (JSType) namedType0, (JSType) errorFunctionType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    unionType0.getTypesUnderShallowInequality(nullType0);
    assertFalse(unionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoType() {
    return false;
}","public void test102317() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Qh"", 0, 1);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) nullType0, (JSType) errorFunctionType0, (JSType) namedType0, (JSType) errorFunctionType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    unionType0.getTypesUnderShallowInequality(nullType0);
    assertFalse(unionType0.isNoType());
}",""
"public boolean isNominalType() {
    return false;
}","public void test102318() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Qh"");
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Not declared as a type name"", ""Qh"", 0, 1);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) errorFunctionType0, (JSType) errorFunctionType0, (JSType) nullType0, (JSType) errorFunctionType0, (JSType) namedType0, (JSType) errorFunctionType0);
    UnionType unionType0 = new UnionType(jSTypeRegistry0, immutableList0);
    unionType0.getTypesUnderShallowInequality(nullType0);
    assertFalse(unionType0.isNominalType());
}","/**
 * Whether this type is a nominal type (a named instance object or
 * a named enum).
 */"
"public boolean isAllType() {
    return false;
}","public void test103319() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.getTypesUnderShallowInequality(booleanType0);
    assertFalse(voidType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test103320() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.getTypesUnderShallowInequality(booleanType0);
    assertFalse(voidType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test103321() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.getTypesUnderShallowInequality(booleanType0);
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test103322() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.getTypesUnderShallowInequality(booleanType0);
    assertFalse(voidType0.isNoResolvedType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test103323() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    BooleanType booleanType0 = new BooleanType(jSTypeRegistry0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.getTypesUnderShallowInequality(booleanType0);
    assertFalse(voidType0.isNoObjectType());
}",""
"public boolean isAllType() {
    return false;
}","public void test104324() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.differsFrom(voidType0);
    assertFalse(voidType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test104325() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.differsFrom(voidType0);
    assertFalse(voidType0.isNoType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test104326() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.differsFrom(voidType0);
    assertFalse(voidType0.isNoObjectType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test104327() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.differsFrom(voidType0);
    assertFalse(templateType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean differsFrom(JSType that) {
    // if there are no unknowns, just use normal equality.
    if (!this.isUnknownType() && !that.isUnknownType()) {
        return !this.isEquivalentTo(that);
    }
    // otherwise, they're different iff one is unknown and the other is not.
    return this.isUnknownType() ^ that.isUnknownType();
}","public void test104328() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.differsFrom(voidType0);
    assertTrue(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type.
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test104329() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = templateType0.differsFrom(voidType0);
    assertFalse(voidType0.isNoResolvedType());
}",""
"public boolean isAllType() {
    return false;
}","public void test105330() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    boolean boolean0 = noResolvedType0.differsFrom(unknownType0);
    assertFalse(unknownType0.isAllType());
}",""
"public boolean isNoType() {
    return false;
}","public void test105331() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    boolean boolean0 = noResolvedType0.differsFrom(unknownType0);
    assertFalse(unknownType0.isNoType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test105332() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    boolean boolean0 = noResolvedType0.differsFrom(unknownType0);
    assertFalse(unknownType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test105333() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    boolean boolean0 = noResolvedType0.differsFrom(unknownType0);
    assertFalse(unknownType0.isNoResolvedType());
}",""
"public boolean differsFrom(JSType that) {
    // if there are no unknowns, just use normal equality.
    if (!this.isUnknownType() && !that.isUnknownType()) {
        return !this.isEquivalentTo(that);
    }
    // otherwise, they're different iff one is unknown and the other is not.
    return this.isUnknownType() ^ that.isUnknownType();
}","public void test105334() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    boolean boolean0 = noResolvedType0.differsFrom(unknownType0);
    assertTrue(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type.
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test105335() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    boolean boolean0 = noResolvedType0.differsFrom(unknownType0);
    assertFalse(unknownType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test106336() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    boolean boolean0 = jSType0.differsFrom(voidType0);
    assertFalse(voidType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test106337() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    boolean boolean0 = jSType0.differsFrom(voidType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"public boolean isNoType() {
    return false;
}","public void test106338() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    boolean boolean0 = jSType0.differsFrom(voidType0);
    assertFalse(voidType0.isNoType());
}",""
"public boolean isAllType() {
    return false;
}","public void test106339() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    boolean boolean0 = jSType0.differsFrom(voidType0);
    assertFalse(jSType0.isAllType());
}",""
"public boolean differsFrom(JSType that) {
    // if there are no unknowns, just use normal equality.
    if (!this.isUnknownType() && !that.isUnknownType()) {
        return !this.isEquivalentTo(that);
    }
    // otherwise, they're different iff one is unknown and the other is not.
    return this.isUnknownType() ^ that.isUnknownType();
}","public void test106340() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    boolean boolean0 = jSType0.differsFrom(voidType0);
    assertTrue(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type.
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test106341() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = voidType0.restrictByNotNullOrUndefined();
    boolean boolean0 = jSType0.differsFrom(voidType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test107342() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = noResolvedType0.canTestForShallowEqualityWith(instanceObjectType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test107343() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = noResolvedType0.canTestForShallowEqualityWith(instanceObjectType0);
    assertFalse(instanceObjectType0.isNoObjectType());
}",""
"public boolean isNoType() {
    return false;
}","public void test107344() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = noResolvedType0.canTestForShallowEqualityWith(instanceObjectType0);
    assertFalse(instanceObjectType0.isNoType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test107345() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = noResolvedType0.canTestForShallowEqualityWith(instanceObjectType0);
    assertFalse(instanceObjectType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoResolvedType() {
    return false;
}","public void test107346() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = noResolvedType0.canTestForShallowEqualityWith(instanceObjectType0);
    assertFalse(instanceObjectType0.isNoResolvedType());
}",""
"public boolean isAllType() {
    return false;
}","public void test107347() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = noResolvedType0.canTestForShallowEqualityWith(instanceObjectType0);
    assertFalse(instanceObjectType0.isAllType());
}",""
"public final boolean canTestForShallowEqualityWith(JSType that) {
    if (isEmptyType() || that.isEmptyType()) {
        return isSubtype(that) || that.isSubtype(this);
    }
    JSType inf = getGreatestSubtype(that);
    return !inf.isEmptyType() || // Our getGreatestSubtype relation on functions is pretty bad.
    // Let's just say it's always ok to compare two functions.
    // Once the TODO in FunctionType is fixed, we should be able to
    // remove this.
    inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","public void test108348() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(allType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean isAllType() {
    return false;
}","public void test108349() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(allType0);
    assertFalse(voidType0.isAllType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test108350() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(allType0);
    assertFalse(allType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNoType() {
    return false;
}","public void test108351() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(allType0);
    assertFalse(allType0.isNoType());
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test108352() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(allType0);
    assertFalse(allType0.isNoObjectType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test108353() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    boolean boolean0 = voidType0.canTestForShallowEqualityWith(allType0);
    assertFalse(allType0.isNoResolvedType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test109354() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.UnionType"");
    errorFunctionType0.resolveInternal(simpleErrorReporter0, errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"static final JSType safeResolve(JSType type, ErrorReporter t, StaticScope<JSType> scope) {
    return type == null ? null : type.resolve(t, scope);
}","public void test110355() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, (JSType) null);
    JSType jSType0 = JSType.safeResolve((JSType) null, simpleErrorReporter0, proxyObjectType0);
    assertNull(jSType0);
}","/**
 * A null-safe resolve.
 * @see #resolve
 */"
