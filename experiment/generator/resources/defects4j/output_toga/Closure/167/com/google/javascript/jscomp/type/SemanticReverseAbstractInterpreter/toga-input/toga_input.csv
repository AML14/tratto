focal_method,test_prefix,docstring
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test000() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    Node node0 = new Node(12);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test011() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(112);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, true);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test022() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(112);
    Node node1 = new Node(15, node0, node0, node0, node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}",""
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test033() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(16);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, true);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test044() throws Throwable {
    Node node0 = new Node(101);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, true);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test055() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(16);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test066() throws Throwable {
    Node node0 = new Node(101);
    Node node1 = new Node(12, node0, node0, 46, 35);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}",""
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test077() throws Throwable {
    Node node0 = new Node(15);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, true);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test088() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(51);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test099() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(51, 51, 51);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, true);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test1010() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(60, 60, 60);
    Node node1 = new Node(51, node0, node0, node0, node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}",""
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test1111() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(45);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test1212() throws Throwable {
    Node node0 = new Node(100, 100, 100);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test1313() throws Throwable {
    Node node0 = new Node(100);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, true);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test1414() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    Node node0 = new Node(38);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test1515() throws Throwable {
    Node node0 = new Node(101);
    Node node1 = new Node(12, node0, node0, 46, 35);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test1616() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(87, 87, 87);
    Node node1 = new Node(46, node0, node0, node0, node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}",""
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test1717() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    Node node0 = new Node(1661);
    Node node1 = new Node(45, node0, 4, 43);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, false);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test1818() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(13);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, true);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test1919() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(44);
    Node node1 = new Node(13, node0, node0, node0, node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test2020() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(44, 44, 44);
    Node node1 = new Node(13, node0, node0, node0, node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test2121() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    Node node0 = new Node(1661);
    Node node1 = new Node(45, node0, 4, 43);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}",""
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test2222() throws Throwable {
    Node node0 = new Node(1336);
    Node node1 = new Node(46, node0, 44, 46);
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, false);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test2323() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(17);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, true);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test2424() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(52, 52, 52);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test2525() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(62, 62, 62);
    Node node1 = new Node(52, node0, node0, node0, node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test2626() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(111);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test2727() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    Node node0 = Node.newString(33, """", 33, 33);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test2828() throws Throwable {
    Node node0 = Node.newNumber((double) 101);
    Node node1 = new Node(101, node0, 45, 15);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test2929() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(14);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, true);
}",""
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test3030() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(86);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, true);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test3131() throws Throwable {
    Node node0 = new Node(101);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test3232() throws Throwable {
    Node node0 = Node.newNumber((double) 100);
    Node node1 = new Node(100, node0, 45, 15);
    FlowScope flowScope0 = mock(FlowScope.class, new ViolatedAssumptionAnswer());
    doReturn((StaticSlot) null).when(flowScope0).findUniqueRefinedSlot(any(com.google.javascript.jscomp.type.FlowScope.class));
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, flowScope0, true);
}",""
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test3333() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(39, 39, 39);
    Node node1 = new Node(33, node0, node0, node0, node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, false);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test3434() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(26);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test3535() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(26);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, true);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test3636() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(56);
    Node node1 = Node.newString(""%>2GY"");
    Node node2 = new Node(51, node1, node0, node1);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node2, (FlowScope) null, true);
}",""
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test3737() throws Throwable {
    Node node0 = new Node(102, 102, 102);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    node0.setJSType(jSType0);
    Node node1 = new Node(12, node0, node0, 46, 35);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, false);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test3838() throws Throwable {
    Node node0 = new Node(102, 102, 102);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    node0.setJSType(jSType0);
    Node node1 = new Node(12, node0, node0, 46, 35);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test3939() throws Throwable {
    Node node0 = new Node((-1706), (-1706), (-1706));
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    node0.setJSType(jSType0);
    Node node1 = new Node(45, node0, node0, 49, 51);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, false);
}",""
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test4040() throws Throwable {
    Node node0 = new Node((-1706), (-1706), (-1706));
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.CHECKED_UNKNOWN_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    node0.setJSType(jSType0);
    Node node1 = new Node(45, node0, node0, 49, 51);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test4141() throws Throwable {
    Node node0 = new Node((-1014), (-1014), 12);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NO_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    node0.setJSType(jSType0);
    Node[] nodeArray0 = new Node[0];
    Node node1 = new Node(1, nodeArray0);
    Node node2 = new Node(46, node0, node1, 65023, 50);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node2, (FlowScope) null, true);
}",""
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test4242() throws Throwable {
    Node node0 = new Node(112, 112, 112);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    node0.setJSType(jSType0);
    Node node1 = new Node(100, node0, node0, 47, 1);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, false);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test4343() throws Throwable {
    Node node0 = new Node(161, 161, 161);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    node0.setJSType(jSType0);
    Node node1 = new Node(12, node0, node0, 46, 35);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    node1.getAncestors();
    node1.useSourceInfoFrom(node1);
    node1.addChildrenToBack(node1);
    semanticReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test4444() throws Throwable {
    Node node0 = new Node(112);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    node0.setJSType(functionType0);
    Node node1 = new Node(101, node0, node0, 2, 45);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test4545() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    Node node0 = new Node(1);
    node0.setJSType(functionType0);
    Node node1 = Node.newString(1, """", 16, 1900);
    Node node2 = new Node(46, node0, node1, 35, 12);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter1 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    semanticReverseAbstractInterpreter1.getPreciserScopeKnowingConditionOutcome(node2, (FlowScope) null, false);
    semanticReverseAbstractInterpreter1.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test4646() throws Throwable {
    Node node0 = new Node(102, 102, 915);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NO_OBJECT_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    Node node1 = new Node(4095, 915, 8);
    node1.setJSType(functionType0);
    Node node2 = new Node(12, node1, node0, 81, 29);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node2, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test4747() throws Throwable {
    Node node0 = new Node(13, 13, 13);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(googleCodingConvention0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, true);
    Node node1 = new Node(111, node0);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    node1.setJSDocInfo(jSDocInfo0);
    Node node2 = Node.newString((-507), ""sG"");
    Node node3 = new Node(36, node1, node1, node2);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, false);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test4848() throws Throwable {
    Node node0 = new Node(13, 13, 13);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    Node.newString(""Unknown class name"", 39, 53);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Node node1 = new Node(111, node0);
    Node node2 = Node.newString((-507), ""sG"");
    Node node3 = new Node(36, node1, node1, node2);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}",""
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test4949() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    Node node0 = new Node(32);
    Node node1 = new Node(12, node0, node0, node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, (FlowScope) null, true);
}",""
