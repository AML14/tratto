focal_method,test_prefix,docstring
"@Override
Node parseTestCode(String js) {
    initCompilerOptionsIfTesting();
    CompilerInput input = new CompilerInput(SourceFile.fromCode(""[testcode]"", js));
    if (inputsById == null) {
        inputsById = Maps.newHashMap();
    }
    putCompilerInput(input.getInputId(), input);
    return input.getAstRoot(this);
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.parseTestCode(""com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Multiple entries with same key: author=NOT_IMPLEMENTED and author=AUTHOR
        //
        verifyException(""com.google.common.collect.ImmutableMap"", e);
    }
}",""
"@Override
Node parseTestCode(String js) {
    initCompilerOptionsIfTesting();
    CompilerInput input = new CompilerInput(SourceFile.fromCode(""[testcode]"", js));
    if (inputsById == null) {
        inputsById = Maps.newHashMap();
    }
    putCompilerInput(input.getInputId(), input);
    return input.getAstRoot(this);
}","public void test022() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.parseTestCode(""com.google.jaascript.jscomp.TypeInfeence$TemplateTypeReplacer"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Multiple entries with same key: author=NOT_IMPLEMENTED and author=AUTHOR
        //
        verifyException(""com.google.common.collect.ImmutableMap"", e);
    }
}",""
"@Override
Node parseTestCode(String js) {
    initCompilerOptionsIfTesting();
    CompilerInput input = new CompilerInput(SourceFile.fromCode(""[testcode]"", js));
    if (inputsById == null) {
        inputsById = Maps.newHashMap();
    }
    putCompilerInput(input.getInputId(), input);
    return input.getAstRoot(this);
}","public void test044() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.parseTestCode(""com.google.javscript.jscomp.TypeInference$TemplateTypeReplacer"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Multiple entries with same key: author=NOT_IMPLEMENTED and author=AUTHOR
        //
        verifyException(""com.google.common.collect.ImmutableMap"", e);
    }
}",""
"@Override
Node parseTestCode(String js) {
    initCompilerOptionsIfTesting();
    CompilerInput input = new CompilerInput(SourceFile.fromCode(""[testcode]"", js));
    if (inputsById == null) {
        inputsById = Maps.newHashMap();
    }
    putCompilerInput(input.getInputId(), input);
    return input.getAstRoot(this);
}","public void test066() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.parseTestCode(""com.google.javascrpt.jscomp.TyeInfeence$TemplateTypeReplcer"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Multiple entries with same key: author=NOT_IMPLEMENTED and author=AUTHOR
        //
        verifyException(""com.google.common.collect.ImmutableMap"", e);
    }
}",""
"@Override
Node parseTestCode(String js) {
    initCompilerOptionsIfTesting();
    CompilerInput input = new CompilerInput(SourceFile.fromCode(""[testcode]"", js));
    if (inputsById == null) {
        inputsById = Maps.newHashMap();
    }
    putCompilerInput(input.getInputId(), input);
    return input.getAstRoot(this);
}","public void test099() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.parseTestCode(""com.google.javascriyt.jscobp.TypeInference$TemplateTypeReplacer"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Multiple entries with same key: author=NOT_IMPLEMENTED and author=AUTHOR
        //
        verifyException(""com.google.common.collect.ImmutableMap"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test1010() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = Scope.createGlobalScope(node0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer"", codingConvention_AssertionFunctionSpec0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(6, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 6
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
Node parseTestCode(String js) {
    initCompilerOptionsIfTesting();
    CompilerInput input = new CompilerInput(SourceFile.fromCode(""[testcode]"", js));
    if (inputsById == null) {
        inputsById = Maps.newHashMap();
    }
    putCompilerInput(input.getInputId(), input);
    return input.getAstRoot(this);
}","public void test2222() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.parseTestCode(""com.google.javasBript.jscomp.TypeInference$emplatTypeRplacer"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Multiple entries with same key: author=NOT_IMPLEMENTED and author=AUTHOR
        //
        verifyException(""com.google.common.collect.ImmutableMap"", e);
    }
}",""
"@Override
Node parseTestCode(String js) {
    initCompilerOptionsIfTesting();
    CompilerInput input = new CompilerInput(SourceFile.fromCode(""[testcode]"", js));
    if (inputsById == null) {
        inputsById = Maps.newHashMap();
    }
    putCompilerInput(input.getInputId(), input);
    return input.getAstRoot(this);
}","public void test2525() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.parseTestCode(""com.google.javascript.jscomp.TypeInfernnce$TemplateTypeReplacer"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Multiple entries with same key: author=NOT_IMPLEMENTED and author=AUTHOR
        //
        verifyException(""com.google.common.collect.ImmutableMap"", e);
    }
}",""
"@Override
Node parseTestCode(String js) {
    initCompilerOptionsIfTesting();
    CompilerInput input = new CompilerInput(SourceFile.fromCode(""[testcode]"", js));
    if (inputsById == null) {
        inputsById = Maps.newHashMap();
    }
    putCompilerInput(input.getInputId(), input);
    return input.getAstRoot(this);
}","public void test3939() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.parseTestCode(""prototype"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Multiple entries with same key: author=NOT_IMPLEMENTED and author=AUTHOR
        //
        verifyException(""com.google.common.collect.ImmutableMap"", e);
    }
}",""
"@Override
Node parseTestCode(String js) {
    initCompilerOptionsIfTesting();
    CompilerInput input = new CompilerInput(SourceFile.fromCode(""[testcode]"", js));
    if (inputsById == null) {
        inputsById = Maps.newHashMap();
    }
    putCompilerInput(input.getInputId(), input);
    return input.getAstRoot(this);
}","public void test5959() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.parseTestCode(""com.google.javscript.jscom.TypeInferece$TemplateTypeReplacer"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Multiple entries with same key: author=NOT_IMPLEMENTED and author=AUTHOR
        //
        verifyException(""com.google.common.collect.ImmutableMap"", e);
    }
}",""
"static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) {
    return right.union(left.intersection(BooleanLiteralSet.get(!condition)));
}","public void test9191() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
    assertEquals(BooleanLiteralSet.FALSE, booleanLiteralSet1);
}","/**
 * Infers the boolean literal set that can be taken by a
 * short-circuiting binary operation ({@code &&} or {@code ||}).
 * @param left the set of possible {@code ToBoolean} predicate results for
 *    the expression on the left side of the operator
 * @param right the set of possible {@code ToBoolean} predicate results for
 *    the expression on the right side of the operator
 * @param condition the left side {@code ToBoolean} predicate result that
 *    causes the right side to get evaluated (i.e. not short-circuited)
 * @return a set of possible {@code ToBoolean} predicate results for the
 *    entire expression
 */"
"static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) {
    return right.union(left.intersection(BooleanLiteralSet.get(!condition)));
}","public void test9292() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
    assertSame(booleanLiteralSet0, booleanLiteralSet1);
}","/**
 * Infers the boolean literal set that can be taken by a
 * short-circuiting binary operation ({@code &&} or {@code ||}).
 * @param left the set of possible {@code ToBoolean} predicate results for
 *    the expression on the left side of the operator
 * @param right the set of possible {@code ToBoolean} predicate results for
 *    the expression on the right side of the operator
 * @param condition the left side {@code ToBoolean} predicate result that
 *    causes the right side to get evaluated (i.e. not short-circuited)
 * @return a set of possible {@code ToBoolean} predicate results for the
 *    entire expression
 */"
