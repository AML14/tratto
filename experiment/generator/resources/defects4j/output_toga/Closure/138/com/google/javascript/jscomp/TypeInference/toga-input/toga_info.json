{
  "test0000" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0000() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(89, 89, 89);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node1 = new Node(100, node0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test0000"
  },
  "test0044" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0044() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node0 = new Node(120, 17, 0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test0044"
  },
  "test0088" : {
    "methodSignature" : "TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Collection<Var> unflowableVars)",
    "methodName" : "TypeInference",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0088() throws Throwable {\n    Node node0 = new Node(62);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Node node1 = new Node(1, node0);\n    JSType[] jSTypeArray0 = new JSType[0];\n    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeArray0);\n    scope0.declare(\"]*oxk\\\"/_\", node0, jSType0, (CompilerInput) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    Compiler compiler0 = new Compiler((PrintStream) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n}",
    "testName" : "test0088"
  },
  "test103103" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test103103() throws Throwable {\n    Node node0 = new Node(122, 122, 122);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Compiler compiler0 = new Compiler();\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = compiler0.parseTestCode(\"E2{\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test103103"
  },
  "test03636" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03636() throws Throwable {\n    Node node0 = new Node(81, 81, 81);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((PrintStream) null);\n    Compiler compiler0 = new Compiler(printStreamErrorManager0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node1 = new Node(28, (-2961), 30);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03636"
  },
  "test02424" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02424() throws Throwable {\n    Node node0 = new Node(74, 74, 74);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    Compiler compiler0 = new Compiler();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    Node node1 = new Node(14, node0, node0, node0, 40, 33);\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test02424"
  },
  "test01212" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01212() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;\n    controlFlowGraph0.connectIfNotFound((Node) null, controlFlowGraph_Branch0, (Node) null);\n    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();\n    typeInference0.branchedFlowThrough((Node) null, flowScope0);\n}",
    "testName" : "test01212"
  },
  "test04646" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04646() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(111, 111, 111);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node1 = new Node(42, node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04646"
  },
  "test117117" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test117117() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(122);\n    Node node1 = new Node(101, node0, node0, 1, 0);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test117117"
  },
  "test02828" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02828() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.getRoot();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(19, \"+\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02828"
  },
  "test113113" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test113113() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(96, 96, 100);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Node node1 = new Node(30, node0);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test113113"
  },
  "test01616" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01616() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(51, 51, 123);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(6, 7, 7);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01616"
  },
  "test03838" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03838() throws Throwable {\n    Node node0 = new Node(122, 122, 122);\n    Node node1 = new Node(30, node0, node0, node0);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Compiler compiler0 = new Compiler();\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test03838"
  },
  "test01818" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01818() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node0 = new Node(8, 27, 46);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test01818"
  },
  "test08484" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08484() throws Throwable {\n    Node node0 = new Node(98, 98, 98);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Compiler compiler0 = new Compiler();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node0, flowScope0);\n}",
    "testName" : "test08484"
  },
  "test05050" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05050() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(101, 101, 101);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);\n    Node node1 = new Node(46, 16, 6);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05050"
  },
  "test04040" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04040() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(122, (-671), 122);\n    Node node1 = new Node(34, node0, node0);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test04040"
  },
  "test08282" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08282() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node0 = new Node(95, (-1), 117);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test08282"
  },
  "test0011" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0011() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node0 = new Node(86, 0, 0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test0011"
  },
  "test0055" : {
    "methodSignature" : "TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Collection<Var> unflowableVars)",
    "methodName" : "TypeInference",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0055() throws Throwable {\n    Node node0 = new Node(122, 122, 122);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Compiler compiler0 = new Compiler();\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    Scope.Var scope_Var0 = scope0.declare(\"*1dnJG?,fw7di>\", node0, (JSType) null, (CompilerInput) null);\n    arrayList0.add(scope_Var0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);\n}",
    "testName" : "test0055"
  },
  "test0099" : {
    "methodSignature" : "TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope)",
    "methodName" : "TypeInference",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0099() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node((-117), (-117), (-117));\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Node node1 = new Node(117, node0);\n    scope0.declare(\"Te@GYj7bIY9\", node0, (JSType) null, (CompilerInput) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n}",
    "testName" : "test0099"
  },
  "test03232" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03232() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(99);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Node node1 = new Node(23, node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test03232"
  },
  "test02020" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02020() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(148);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node1 = new Node(10, 39, 19);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02020"
  },
  "test04444" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04444() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    Node node0 = Node.newString(\"Invalid token: \");\n    typeInference0.branchedFlowThrough(node0, flowScope0);\n}",
    "testName" : "test04444"
  },
  "test09898" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09898() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(111, 111, 111);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    Node node1 = new Node(118, node0);\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test09898"
  },
  "test03030" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03030() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(101, 101, 101);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node1 = new Node(21, node0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test03030"
  },
  "test02222" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02222() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node0 = new Node(12, 21, 129);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node0, flowScope0);\n}",
    "testName" : "test02222"
  },
  "test05252" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05252() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node((-584), (-584), (-584));\n    Node node1 = new Node(48, node0, node0, node0, node0, 33, 9);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(10);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test05252"
  },
  "test07474" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07474() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    Node node0 = Node.newString(84, \".J\\\\;|[=|:'l\\\"lIF!Gk\", 114, 20);\n    typeInference0.branchedFlowThrough(node0, flowScope0);\n}",
    "testName" : "test07474"
  },
  "test04242" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04242() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(122, 123, 123);\n    Node node1 = new Node(37, node0, node0, node0, node0, 34, 1);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node1, (ObjectType) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test04242"
  },
  "test01010" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01010() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(63);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;\n    controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node0, flowScope0);\n}",
    "testName" : "test01010"
  },
  "test06464" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06464() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(51, 118, 68);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node1 = new Node(68, 0, 0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test06464"
  },
  "test110110" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test110110() throws Throwable {\n    Node node0 = new Node(1767, 1767, 117);\n    Node node1 = Node.newNumber((double) 37);\n    Node node2 = new Node(93, node0, node1, 89, 47);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Compiler compiler0 = new Compiler();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node2, linkedFlowScope0);\n}",
    "testName" : "test110110"
  },
  "test118118" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test118118() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(101, (-1), (-1));\n    Node node1 = new Node(100, node0, node0, node0);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    node0.addChildToBack(node1);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test118118"
  },
  "test114114" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test114114() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(93, 93, 123);\n    Node node1 = new Node(32);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Stack<Scope.Var> stack0 = new Stack<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, stack0);\n    Node node2 = new Node(35, node1);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node2, linkedFlowScope0);\n}",
    "testName" : "test114114"
  },
  "test0022" : {
    "methodSignature" : "Multimap<Scope, Var> getAssignedOuterLocalVars()",
    "methodName" : "getAssignedOuterLocalVars",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0022() throws Throwable {\n    Logger logger0 = Logger.getLogger(\"wc.MP^5nK.NR%o-\");\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseTestCode(\"d1\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    Scope scope0 = new Scope(node0, compiler0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);\n    Multimap<Scope, Scope.Var> multimap0 = typeInference0.getAssignedOuterLocalVars();\n}",
    "testName" : "test0022"
  },
  "test0066" : {
    "methodSignature" : "TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Collection<Var> unflowableVars)",
    "methodName" : "TypeInference",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0066() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(96, 96, 100);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Scope.Var scope_Var0 = scope0.declare(\"K<\", node0, (JSType) null, (CompilerInput) null);\n    scope0.undeclare(scope_Var0);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    arrayList0.add(scope_Var0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n}",
    "testName" : "test0066"
  },
  "test101101" : {
    "methodSignature" : "FlowScope flowThrough(Node n, FlowScope input)",
    "methodName" : "flowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test101101() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(123, 5, (-3884));\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);\n}",
    "testName" : "test101101"
  },
  "test04747" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04747() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node0 = new Node(43, 0, 28);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test04747"
  },
  "test06969" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06969() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(90);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node1 = new Node(76, node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06969"
  },
  "test03737" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03737() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node0 = new Node(29, 42, 108);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test03737"
  },
  "test01515" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01515() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Node node0 = new Node(5);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node0, flowScope0);\n}",
    "testName" : "test01515"
  },
  "test06767" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06767() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node0 = new Node(71, 0, 0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test06767"
  },
  "test03535" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03535() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(51, 51, 123);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention) compiler0.defaultCodingConvention;\n    TightenTypes tightenTypes0 = new TightenTypes(compiler0);\n    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    Node node1 = new Node(26);\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test03535"
  },
  "test08989" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08989() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(103, 103, 103);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node1 = new Node(106, node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08989"
  },
  "test119119" : {
    "methodSignature" : "static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition)",
    "methodName" : "getBooleanOutcomes",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test119119() throws Throwable {\n    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;\n    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);\n}",
    "testName" : "test119119"
  },
  "test111111" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test111111() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(18, 18, 18);\n    Node node1 = new Node(37, node0, node0, node0, node0, 34, 1);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    Scope scope0 = new Scope(node1, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(4095);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test111111"
  },
  "test115115" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test115115() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node((-584), (-584), (-584));\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(35, node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test115115"
  },
  "test04949" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04949() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(101, 101, 101);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(45, node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04949"
  },
  "test01919" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01919() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(148, 148, 148);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(9, 19, (-2624));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01919"
  },
  "test02929" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02929() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node((-117), (-117), (-117));\n    Node node1 = new Node(20, 36, 18);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    Scope scope0 = new Scope(node1, (ObjectType) null);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02929"
  },
  "test09595" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09595() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(111, 111, (-5));\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);\n    Node node1 = new Node(114, node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09595"
  },
  "test06161" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06161() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node0 = new Node(65, 0, 0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test06161"
  },
  "test08383" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08383() throws Throwable {\n    Node node0 = new Node(74, 74, 74);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    Compiler compiler0 = new Compiler();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(97);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08383"
  },
  "test05151" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05151() throws Throwable {\n    Node node0 = new Node(74, 74, 74);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    Compiler compiler0 = new Compiler();\n    CodingConvention codingConvention0 = compiler0.getCodingConvention();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node1 = new Node(47, 28, 4095);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test05151"
  },
  "test0033" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0033() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(101, 101, 101);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node1 = new Node(33, 15, 4);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test0033"
  },
  "test0077" : {
    "methodSignature" : "TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope)",
    "methodName" : "TypeInference",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0077() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(51, 51, 51);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createScope(node0, (Scope) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n}",
    "testName" : "test0077"
  },
  "test07171" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07171() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node((-584), (-584), (-584));\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, hashSet0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(79, node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07171"
  },
  "test04343" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04343() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope((Node) null, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    JSType[] jSTypeArray0 = new JSType[3];\n    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);\n    typeInference0.branchedFlowThrough(node0, flowScope0);\n}",
    "testName" : "test04343"
  },
  "test09999" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09999() throws Throwable {\n    Node node0 = new Node(74, 74, 74);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Node node1 = new Node(119, node0);\n    Compiler compiler0 = new Compiler();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test09999"
  },
  "test104104" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test104104() throws Throwable {\n    Node node0 = new Node(81);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    Node node1 = new Node(126, node0);\n    Compiler compiler0 = new Compiler();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test104104"
  },
  "test03333" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03333() throws Throwable {\n    Node node0 = new Node(74);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Compiler compiler0 = new Compiler();\n    Node node1 = new Node(24, 7, 13);\n    Stack<Scope.Var> stack0 = new Stack<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, stack0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test03333"
  },
  "test08787" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08787() throws Throwable {\n    Node node0 = new Node(62);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    Compiler compiler0 = new Compiler();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    Node node1 = new Node(104, 31, 4);\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test08787"
  },
  "test100100" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test100100() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(51, (-60), 670);\n    Node node1 = new Node(121, node0, node0, 0, 12);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node1, (ObjectType) null);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test100100"
  },
  "test04141" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04141() throws Throwable {\n    Node node0 = new Node(74);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    Compiler compiler0 = new Compiler();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    Node node1 = new Node(36, 2, 100000);\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test04141"
  },
  "test09797" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09797() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node((-117), (-117), (-117));\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Node node1 = new Node(117, node0);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test09797"
  },
  "test03131" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03131() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(122, 122, 122);\n    Node node1 = new Node(22, node0, node0, node0, node0, 3, 14);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test03131"
  },
  "test08585" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08585() throws Throwable {\n    Node node0 = new Node(1767, 1767, 117);\n    Node node1 = new Node(102, node0, node0, 91, 47);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Compiler compiler0 = new Compiler();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test08585"
  },
  "test02121" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02121() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node((-593), (-593), (-593));\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(11, node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02121"
  },
  "test07575" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07575() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(111, 111, 111);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    Node node1 = new Node(85, node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07575"
  },
  "test108108" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test108108() throws Throwable {\n    Node node0 = new Node(27);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    Node node1 = new Node(130, node0);\n    Compiler compiler0 = new Compiler();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n    typeInference0.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test108108"
  },
  "test116116" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test116116() throws Throwable {\n    Node node0 = new Node(78);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    Compiler compiler0 = new Compiler();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(100, node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test116116"
  },
  "test112112" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test112112() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = new Node(148, 148, 148);\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    CodingConvention codingConvention0 = compiler0.getCodingConvention();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);\n    Scope scope0 = new Scope(node0, (ObjectType) null);\n    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(30, node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test112112"
  }
}