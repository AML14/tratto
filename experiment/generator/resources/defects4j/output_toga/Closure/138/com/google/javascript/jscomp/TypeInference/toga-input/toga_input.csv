focal_method,test_prefix,docstring
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(89, 89, 89);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(100, node0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // OR : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0011() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(86, 0, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"Multimap<Scope, Var> getAssignedOuterLocalVars() {
    return assignedOuterLocalVars;
}","public void test0022() throws Throwable {
    Logger logger0 = Logger.getLogger(""wc.MP^5nK.NR%o-"");
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseTestCode(""d1"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, compiler0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
    Multimap<Scope, Scope.Var> multimap0 = typeInference0.getAssignedOuterLocalVars();
    assertNotNull(multimap0);
}","/**
 * @return Local variables assigned in this scope, but which are declared in
 *     a scope outside of it. Hashed by the scope they're declared in.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0033() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(33, 15, 4);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0044() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(120, 17, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"// TODO(nicksantos): Create a builder for this class.
TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Collection<Var> unflowableVars) {
    super(cfg, new LinkedFlowScope.FlowScopeJoinOp());
    this.compiler = compiler;
    this.registry = compiler.getTypeRegistry();
    this.reverseInterpreter = reverseInterpreter;
    this.syntacticScope = functionScope;
    this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);
    for (Var unflowableVar : unflowableVars) {
        String name = unflowableVar.getName();
        if (functionScope.getVar(name) == unflowableVar) {
            this.unflowableVarNames.add(name);
        }
    }
    Iterator<Var> varIt = functionScope.getVars();
    while (varIt.hasNext()) {
        Var var = varIt.next();
        if (this.unflowableVarNames.contains(var.getName())) {
            continue;
        }
        // For each local variable declared with the VAR keyword, the entry
        // type is VOID.
        if (var.getParentNode() != null && // no declared type
        var.getType() == null && var.getParentNode().getType() == Token.VAR && !var.isExtern()) {
            this.functionScope.inferSlotType(var.getName(), getNativeType(VOID_TYPE));
        }
    }
    this.bottomScope = LinkedFlowScope.createEntryLattice(new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis()));
}","public void test0055() throws Throwable {
    Node node0 = new Node(122, 122, 122);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Scope.Var scope_Var0 = scope0.declare(""*1dnJG?,fw7di>"", node0, (JSType) null, (CompilerInput) null);
    arrayList0.add(scope_Var0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);
}","/**
 * @param unflowableVars Do not do infer flow on the types of these vars.
 */"
"// TODO(nicksantos): Create a builder for this class.
TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Collection<Var> unflowableVars) {
    super(cfg, new LinkedFlowScope.FlowScopeJoinOp());
    this.compiler = compiler;
    this.registry = compiler.getTypeRegistry();
    this.reverseInterpreter = reverseInterpreter;
    this.syntacticScope = functionScope;
    this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);
    for (Var unflowableVar : unflowableVars) {
        String name = unflowableVar.getName();
        if (functionScope.getVar(name) == unflowableVar) {
            this.unflowableVarNames.add(name);
        }
    }
    Iterator<Var> varIt = functionScope.getVars();
    while (varIt.hasNext()) {
        Var var = varIt.next();
        if (this.unflowableVarNames.contains(var.getName())) {
            continue;
        }
        // For each local variable declared with the VAR keyword, the entry
        // type is VOID.
        if (var.getParentNode() != null && // no declared type
        var.getType() == null && var.getParentNode().getType() == Token.VAR && !var.isExtern()) {
            this.functionScope.inferSlotType(var.getName(), getNativeType(VOID_TYPE));
        }
    }
    this.bottomScope = LinkedFlowScope.createEntryLattice(new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis()));
}","public void test0066() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(96, 96, 100);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Scope.Var scope_Var0 = scope0.declare(""K<"", node0, (JSType) null, (CompilerInput) null);
    scope0.undeclare(scope_Var0);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    arrayList0.add(scope_Var0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
}","/**
 * @param unflowableVars Do not do infer flow on the types of these vars.
 */"
"TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope) {
    this(compiler, cfg, reverseInterpreter, functionScope, ImmutableSet.<Var>of());
}","public void test0077() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 51, 51);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createScope(node0, (Scope) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
}",""
"// TODO(nicksantos): Create a builder for this class.
TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Collection<Var> unflowableVars) {
    super(cfg, new LinkedFlowScope.FlowScopeJoinOp());
    this.compiler = compiler;
    this.registry = compiler.getTypeRegistry();
    this.reverseInterpreter = reverseInterpreter;
    this.syntacticScope = functionScope;
    this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);
    for (Var unflowableVar : unflowableVars) {
        String name = unflowableVar.getName();
        if (functionScope.getVar(name) == unflowableVar) {
            this.unflowableVarNames.add(name);
        }
    }
    Iterator<Var> varIt = functionScope.getVars();
    while (varIt.hasNext()) {
        Var var = varIt.next();
        if (this.unflowableVarNames.contains(var.getName())) {
            continue;
        }
        // For each local variable declared with the VAR keyword, the entry
        // type is VOID.
        if (var.getParentNode() != null && // no declared type
        var.getType() == null && var.getParentNode().getType() == Token.VAR && !var.isExtern()) {
            this.functionScope.inferSlotType(var.getName(), getNativeType(VOID_TYPE));
        }
    }
    this.bottomScope = LinkedFlowScope.createEntryLattice(new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis()));
}","public void test0088() throws Throwable {
    Node node0 = new Node(62);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(1, node0);
    JSType[] jSTypeArray0 = new JSType[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeArray0);
    scope0.declare(""]*oxk\""/_"", node0, jSType0, (CompilerInput) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler((PrintStream) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
}","/**
 * @param unflowableVars Do not do infer flow on the types of these vars.
 */"
"TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope) {
    this(compiler, cfg, reverseInterpreter, functionScope, ImmutableSet.<Var>of());
}","public void test0099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-117), (-117), (-117));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(117, node0);
    scope0.declare(""Te@GYj7bIY9"", node0, (JSType) null, (CompilerInput) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01010() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(63);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
    controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ARRAYLIT : com.google.javascript.rhino.jstype.InstanceObjectType@0000000079 does not have a condition.
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01212() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
    controlFlowGraph0.connectIfNotFound((Node) null, controlFlowGraph_Branch0, (Node) null);
    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough((Node) null, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01515() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Node node0 = new Node(5);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GOTO does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01616() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 51, 123);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(6, 7, 7);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // IFEQ 7 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01818() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(8, 27, 46);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETNAME 27 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01919() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(148, 148, 148);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(9, 19, (-2624));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITOR : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02020() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(148);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(10, 39, 19);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITXOR 39 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02121() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-593), (-593), (-593));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(11, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITAND : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02222() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(12, 21, 129);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EQ 21 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02424() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(14, node0, node0, node0, 40, 33);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LT 40 : com.google.javascript.rhino.jstype.BooleanType@0000000268 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02828() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.getRoot();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(19, ""+"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RSH + : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02929() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-117), (-117), (-117));
    Node node1 = new Node(20, 36, 18);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // URSH 36 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03030() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(21, node0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03131() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122, 122, 122);
    Node node1 = new Node(22, node0, node0, node0, node0, 3, 14);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SUB 3 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03232() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(99);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(23, node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // MUL : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03333() throws Throwable {
    Node node0 = new Node(74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    Node node1 = new Node(24, 7, 13);
    Stack<Scope.Var> stack0 = new Stack<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, stack0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DIV 7 : com.google.javascript.rhino.jstype.NumberType@0000000270 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03535() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 51, 123);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention) compiler0.defaultCodingConvention;
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(26);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NOT : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03636() throws Throwable {
    Node node0 = new Node(81, 81, 81);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((PrintStream) null);
    Compiler compiler0 = new Compiler(printStreamErrorManager0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(28, (-2961), 30);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03737() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(29, 42, 108);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03838() throws Throwable {
    Node node0 = new Node(122, 122, 122);
    Node node1 = new Node(30, node0, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW : com.google.javascript.rhino.jstype.NoType@0000000070 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04040() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122, (-671), 122);
    Node node1 = new Node(34, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETPROP does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04141() throws Throwable {
    Node node0 = new Node(74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(36, 2, 100000);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETELEM 2 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04242() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122, 123, 123);
    Node node1 = new Node(37, node0, node0, node0, node0, 34, 1);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CALL 34 : com.google.javascript.rhino.jstype.NoType@0000000064 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04343() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    JSType[] jSTypeArray0 = new JSType[3];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LP : com.google.javascript.rhino.jstype.UnknownType@0000000043 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04444() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node0 = Node.newString(""Invalid token: "");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // STRING Invalid token:  : com.google.javascript.rhino.jstype.StringType@0000000042 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04646() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, 111);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(42, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // THIS does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04747() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(43, 0, 28);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FALSE 0 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04949() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(45, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05050() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
    Node node1 = new Node(46, 16, 6);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SHNE 16 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05151() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Compiler compiler0 = new Compiler();
    CodingConvention codingConvention0 = compiler0.getCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(47, 28, 4095);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // OBJECT 28 : com.google.javascript.rhino.jstype.InstanceObjectType@0000000429 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05252() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-584), (-584), (-584));
    Node node1 = new Node(48, node0, node0, node0, node0, 33, 9);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(10);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BINDNAME 33 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06161() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(65, 0, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06464() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 118, 68);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(68, 0, 0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // REF_CALL 0 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06767() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(71, 0, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ESCXMLATTR 0 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06969() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(90);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(76, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // REF_NS_NAME does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07171() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-584), (-584), (-584));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, hashSet0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(79, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LB does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07474() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node0 = Node.newString(84, "".J\\;|[=|:'l\""lIF!Gk"", 114, 20);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RP .J\\;|[=|:'l\""lIF!Gk 114 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07575() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, 111);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(85, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // COMMA : com.google.javascript.rhino.jstype.UnknownType@0000000043 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08282() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node0 = new Node(95, (-1), 117);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_MUL : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08383() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(97);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_MOD : com.google.javascript.rhino.jstype.NumberType@0000000270 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08484() throws Throwable {
    Node node0 = new Node(98, 98, 98);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08585() throws Throwable {
    Node node0 = new Node(1767, 1767, 117);
    Node node1 = new Node(102, node0, node0, 91, 47);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // INC 91 : com.google.javascript.rhino.jstype.NumberType@0000000271 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08787() throws Throwable {
    Node node0 = new Node(62);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(104, 31, 4);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DOT 31 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08989() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(103, 103, 103);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(106, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EXPORT does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09595() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, (-5));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
    Node node1 = new Node(114, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DO does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09797() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-117), (-117), (-117));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(117, node0);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CONTINUE does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09898() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, 111);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(118, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // VAR does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09999() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(119, node0);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // WITH does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test100100() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, (-60), 670);
    Node node1 = new Node(121, node0, node0, 0, 12);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FINALLY 0 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
FlowScope flowThrough(Node n, FlowScope input) {
    // If we have not walked a path from <entry> to <n>, then we don't
    // want to infer anything about this scope.
    if (input == bottomScope) {
        return input;
    }
    FlowScope output = input.createChildFlowScope();
    output = traverse(n, output);
    return output;
}","public void test101101() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(123, 5, (-3884));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
    assertNotSame(flowScope1, flowScope0);
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test103103() throws Throwable {
    Node node0 = new Node(122, 122, 122);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = compiler0.parseTestCode(""E2{"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BLOCK [sourcename: java.lang.String@0000000461] does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test104104() throws Throwable {
    Node node0 = new Node(81);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Node node1 = new Node(126, node0);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LABEL does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test108108() throws Throwable {
    Node node0 = new Node(27);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(130, node0);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EXPR_RESULT does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test110110() throws Throwable {
    Node node0 = new Node(1767, 1767, 117);
    Node node1 = Node.newNumber((double) 37);
    Node node2 = new Node(93, node0, node1, 89, 47);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_ADD 89 : com.google.javascript.rhino.jstype.UnknownType@0000000274 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test111111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(18, 18, 18);
    Node node1 = new Node(37, node0, node0, node0, node0, 34, 1);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(4095);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CALL 34 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test112112() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(148, 148, 148);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    CodingConvention codingConvention0 = compiler0.getCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(30, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test113113() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(96, 96, 100);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(30, node0);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test114114() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(93, 93, 123);
    Node node1 = new Node(32);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Stack<Scope.Var> stack0 = new Stack<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, stack0);
    Node node2 = new Node(35, node1);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GETELEM does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test115115() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-584), (-584), (-584));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(35, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GETELEM does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test116116() throws Throwable {
    Node node0 = new Node(78);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(100, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // OR does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test117117() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122);
    Node node1 = new Node(101, node0, node0, 1, 0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // AND 1 : com.google.javascript.rhino.jstype.VoidType@0000000045 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    if (item.getType() == Token.VAR) {
                        item = item.getFirstChild();
                    }
                    if (item.getType() == Token.NAME) {
                        FlowScope informed = output.createChildFlowScope();
                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));
                        newScope = informed;
                    }
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.getType() == Token.CASE) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.getType() == Token.AND || condition.getType() == Token.OR) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.getType() == Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test118118() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, (-1), (-1));
    Node node1 = new Node(100, node0, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    node0.addChildToBack(node1);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: StackOverflowError"");
    } catch (StackOverflowError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) {
    return right.union(left.intersection(BooleanLiteralSet.get(!condition)));
}","public void test119119() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
    assertSame(booleanLiteralSet1, booleanLiteralSet0);
}","/**
 * Infers the boolean literal set that can be taken by a
 * short-circuiting binary operation ({@code &&} or {@code ||}).
 * @param left the set of possible {@code ToBoolean} predicate results for
 *    the expression on the left side of the operator
 * @param right the set of possible {@code ToBoolean} predicate results for
 *    the expression on the right side of the operator
 * @param condition the left side {@code ToBoolean} predicate result that
 *    causes the right side to get evaluated (i.e. not short-circuited)
 * @return a set of possible {@code ToBoolean} predicate results for the
 *    entire expression
 */"
