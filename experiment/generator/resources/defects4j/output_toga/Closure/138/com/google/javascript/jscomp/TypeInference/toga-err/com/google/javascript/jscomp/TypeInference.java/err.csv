com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test01111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 51, 123);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention) compiler0.defaultCodingConvention;
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
    controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test01313() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, 995);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    node0.addChildrenToBack(node0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
    controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test01414() throws Throwable {
    Node node0 = new Node(122);
    Node node1 = new Node(4, node0, node0, node0, node0, 1, 33);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test01717() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(7);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test02323() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(13, (-2663), (-2614));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test02525() throws Throwable {
    Node node0 = new Node(15);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test02626() throws Throwable {
    Node node0 = new Node(122, 122, 122);
    Node node1 = new Node(16, node0, node0, node0, node0, 1, 33);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test02727() throws Throwable {
    Node node0 = new Node(17);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test03434() throws Throwable {
    Node node0 = new Node(1695, 1887, (-1314));
    Node node1 = new Node(25, node0, node0, node0, node0, 31, 84);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test03939() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(31, 31, 123);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test04545() throws Throwable {
    Node node0 = new Node(41);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test04848() throws Throwable {
    Node node0 = new Node(44);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test05353() throws Throwable {
    Node node0 = new Node(122, 122, 122);
    Node node1 = new Node(49, node0, node0, node0, node0, 1, 33);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test05454() throws Throwable {
    Node node0 = new Node(52);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test05555() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(54, 54, 54);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test05656() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(56, 56, 123);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(45);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test05757() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(57);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(33);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test05858() throws Throwable {
    Node node0 = new Node(58, 58, 58);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    Vector<Scope.Var> vector0 = new Vector<Scope.Var>(5, 40);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, vector0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test05959() throws Throwable {
    Node node0 = new Node(60);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test06060() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(61, 61, 61);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    ObjectType objectType0 = jSTypeRegistry0.createObjectType("""", (Node) null, (ObjectType) null);
    Scope scope0 = new Scope((Node) null, objectType0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test06262() throws Throwable {
    Node node0 = new Node(66);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test06363() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(67, 67, 67);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test06565() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(69, 42, 42);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test06666() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(70);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test06868() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(73, (-2949), (-2949));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test07070() throws Throwable {
    Node node0 = new Node(77);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test07272() throws Throwable {
    Node node0 = new Node(81, 81, 81);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test07373() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(82);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test07676() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(87, 71, (-2533));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test07777() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(88);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test07878() throws Throwable {
    Node node0 = new Node(90, 90, 90);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test07979() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(91, 42, 42);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test08080() throws Throwable {
    Node node0 = new Node(62, 62, 62);
    Node node1 = new Node(92, node0, node0, node0, node0, (-2313), 22);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test08181() throws Throwable {
    Node node0 = new Node(94);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test08686() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(103, 103, 995);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test08888() throws Throwable {
    Node node0 = new Node(105, 105, 105);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test09090() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(107);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test09191() throws Throwable {
    Node node0 = new Node(108);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test09292() throws Throwable {
    Node node0 = new Node(165, 165, 165);
    Node node1 = new Node(109, node0, node0, node0, node0, 1, 33);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test09393() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(112, (-2003), (-1891));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention) compiler0.defaultCodingConvention;
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test09494() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(113, 113, 113);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test09696() throws Throwable {
    Node node0 = new Node(122, 122, 122);
    Node node1 = new Node(115, node0, node0, node0, node0, 1, 33);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test102102() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(124);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test105105() throws Throwable {
    Node node0 = new Node(127, 127, 122);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test106106() throws Throwable {
    Node node0 = new Node(128, 128, 128);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test107107() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(129, 71, 129);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test109109() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122, 122, 122);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    node0.setJSDocInfo(jSDocInfo0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_138b/src/java/util/List.java
