project,bug_num,test_name,test_prefix,except_pred,assert_pred
project,0,test0000,"public void test0000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(89, 89, 89);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(100, node0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // OR : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test0011,"public void test0011() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(86, 0, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test0022,"public void test0022() throws Throwable {
    Logger logger0 = Logger.getLogger(""wc.MP^5nK.NR%o-"");
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseTestCode(""d1"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, compiler0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
    Multimap<Scope, Scope.Var> multimap0 = typeInference0.getAssignedOuterLocalVars();
    assertNotNull(multimap0);
}",0,
project,0,test0033,"public void test0033() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(33, 15, 4);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test0044,"public void test0044() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(120, 17, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test0055,"public void test0055() throws Throwable {
    Node node0 = new Node(122, 122, 122);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Scope.Var scope_Var0 = scope0.declare(""*1dnJG?,fw7di>"", node0, (JSType) null, (CompilerInput) null);
    arrayList0.add(scope_Var0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);
}",0,
project,0,test0066,"public void test0066() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(96, 96, 100);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Scope.Var scope_Var0 = scope0.declare(""K<"", node0, (JSType) null, (CompilerInput) null);
    scope0.undeclare(scope_Var0);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    arrayList0.add(scope_Var0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
}",0,
project,0,test0077,"public void test0077() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 51, 51);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createScope(node0, (Scope) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
}",0,
project,0,test0088,"public void test0088() throws Throwable {
    Node node0 = new Node(62);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(1, node0);
    JSType[] jSTypeArray0 = new JSType[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeArray0);
    scope0.declare(""]*oxk\""/_"", node0, jSType0, (CompilerInput) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler((PrintStream) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
}",0,
project,0,test0099,"public void test0099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-117), (-117), (-117));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(117, node0);
    scope0.declare(""Te@GYj7bIY9"", node0, (JSType) null, (CompilerInput) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
}",0,
project,0,test01010,"public void test01010() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(63);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
    controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ARRAYLIT : com.google.javascript.rhino.jstype.InstanceObjectType@0000000079 does not have a condition.
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",0,
project,0,test01212,"public void test01212() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
    controlFlowGraph0.connectIfNotFound((Node) null, controlFlowGraph_Branch0, (Node) null);
    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough((Node) null, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",0,
project,0,test01515,"public void test01515() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Node node0 = new Node(5);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GOTO does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test01616,"public void test01616() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 51, 123);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(6, 7, 7);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // IFEQ 7 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test01818,"public void test01818() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(8, 27, 46);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETNAME 27 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test01919,"public void test01919() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(148, 148, 148);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(9, 19, (-2624));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITOR : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02020,"public void test02020() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(148);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(10, 39, 19);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITXOR 39 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02121,"public void test02121() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-593), (-593), (-593));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(11, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITAND : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02222,"public void test02222() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(12, 21, 129);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EQ 21 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02424,"public void test02424() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(14, node0, node0, node0, 40, 33);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LT 40 : com.google.javascript.rhino.jstype.BooleanType@0000000268 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02828,"public void test02828() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.getRoot();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(19, ""+"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RSH + : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02929,"public void test02929() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-117), (-117), (-117));
    Node node1 = new Node(20, 36, 18);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // URSH 36 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test03030,"public void test03030() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(21, node0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test03131,"public void test03131() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122, 122, 122);
    Node node1 = new Node(22, node0, node0, node0, node0, 3, 14);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SUB 3 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test03232,"public void test03232() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(99);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(23, node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // MUL : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test03333,"public void test03333() throws Throwable {
    Node node0 = new Node(74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    Node node1 = new Node(24, 7, 13);
    Stack<Scope.Var> stack0 = new Stack<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, stack0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DIV 7 : com.google.javascript.rhino.jstype.NumberType@0000000270 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test03535,"public void test03535() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 51, 123);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention) compiler0.defaultCodingConvention;
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(26);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NOT : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test03636,"public void test03636() throws Throwable {
    Node node0 = new Node(81, 81, 81);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((PrintStream) null);
    Compiler compiler0 = new Compiler(printStreamErrorManager0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(28, (-2961), 30);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test03737,"public void test03737() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(29, 42, 108);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test03838,"public void test03838() throws Throwable {
    Node node0 = new Node(122, 122, 122);
    Node node1 = new Node(30, node0, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW : com.google.javascript.rhino.jstype.NoType@0000000070 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04040,"public void test04040() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122, (-671), 122);
    Node node1 = new Node(34, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETPROP does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04141,"public void test04141() throws Throwable {
    Node node0 = new Node(74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(36, 2, 100000);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETELEM 2 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04242,"public void test04242() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122, 123, 123);
    Node node1 = new Node(37, node0, node0, node0, node0, 34, 1);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CALL 34 : com.google.javascript.rhino.jstype.NoType@0000000064 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04343,"public void test04343() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    JSType[] jSTypeArray0 = new JSType[3];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LP : com.google.javascript.rhino.jstype.UnknownType@0000000043 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04444,"public void test04444() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node0 = Node.newString(""Invalid token: "");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // STRING Invalid token:  : com.google.javascript.rhino.jstype.StringType@0000000042 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04646,"public void test04646() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, 111);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(42, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // THIS does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04747,"public void test04747() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(43, 0, 28);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FALSE 0 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04949,"public void test04949() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(45, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test05050,"public void test05050() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
    Node node1 = new Node(46, 16, 6);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SHNE 16 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test05151,"public void test05151() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Compiler compiler0 = new Compiler();
    CodingConvention codingConvention0 = compiler0.getCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(47, 28, 4095);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // OBJECT 28 : com.google.javascript.rhino.jstype.InstanceObjectType@0000000429 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test05252,"public void test05252() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-584), (-584), (-584));
    Node node1 = new Node(48, node0, node0, node0, node0, 33, 9);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(10);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BINDNAME 33 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test06161,"public void test06161() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(65, 0, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test06464,"public void test06464() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 118, 68);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(68, 0, 0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // REF_CALL 0 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test06767,"public void test06767() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(71, 0, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ESCXMLATTR 0 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test06969,"public void test06969() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(90);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(76, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // REF_NS_NAME does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test07171,"public void test07171() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-584), (-584), (-584));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, hashSet0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(79, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LB does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test07474,"public void test07474() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node0 = Node.newString(84, "".J\\;|[=|:'l\""lIF!Gk"", 114, 20);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RP .J\\;|[=|:'l\""lIF!Gk 114 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test07575,"public void test07575() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, 111);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(85, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // COMMA : com.google.javascript.rhino.jstype.UnknownType@0000000043 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test08282,"public void test08282() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node0 = new Node(95, (-1), 117);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_MUL : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test08383,"public void test08383() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(97);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_MOD : com.google.javascript.rhino.jstype.NumberType@0000000270 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test08484,"public void test08484() throws Throwable {
    Node node0 = new Node(98, 98, 98);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test08585,"public void test08585() throws Throwable {
    Node node0 = new Node(1767, 1767, 117);
    Node node1 = new Node(102, node0, node0, 91, 47);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // INC 91 : com.google.javascript.rhino.jstype.NumberType@0000000271 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test08787,"public void test08787() throws Throwable {
    Node node0 = new Node(62);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(104, 31, 4);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DOT 31 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test08989,"public void test08989() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(103, 103, 103);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(106, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EXPORT does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test09595,"public void test09595() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, (-5));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
    Node node1 = new Node(114, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DO does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test09797,"public void test09797() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-117), (-117), (-117));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(117, node0);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CONTINUE does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test09898,"public void test09898() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, 111);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(118, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // VAR does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test09999,"public void test09999() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(119, node0);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // WITH does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test100100,"public void test100100() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, (-60), 670);
    Node node1 = new Node(121, node0, node0, 0, 12);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FINALLY 0 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test101101,"public void test101101() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(123, 5, (-3884));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
    assertNotSame(flowScope1, flowScope0);
}",0,
project,0,test103103,"public void test103103() throws Throwable {
    Node node0 = new Node(122, 122, 122);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = compiler0.parseTestCode(""E2{"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BLOCK [sourcename: java.lang.String@0000000461] does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",1,
project,0,test104104,"public void test104104() throws Throwable {
    Node node0 = new Node(81);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Node node1 = new Node(126, node0);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LABEL does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test108108,"public void test108108() throws Throwable {
    Node node0 = new Node(27);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(130, node0);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EXPR_RESULT does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test110110,"public void test110110() throws Throwable {
    Node node0 = new Node(1767, 1767, 117);
    Node node1 = Node.newNumber((double) 37);
    Node node2 = new Node(93, node0, node1, 89, 47);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_ADD 89 : com.google.javascript.rhino.jstype.UnknownType@0000000274 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test111111,"public void test111111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(18, 18, 18);
    Node node1 = new Node(37, node0, node0, node0, node0, 34, 1);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(4095);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CALL 34 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test112112,"public void test112112() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(148, 148, 148);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    CodingConvention codingConvention0 = compiler0.getCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(30, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test113113,"public void test113113() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(96, 96, 100);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(30, node0);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test114114,"public void test114114() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(93, 93, 123);
    Node node1 = new Node(32);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Stack<Scope.Var> stack0 = new Stack<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, stack0);
    Node node2 = new Node(35, node1);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GETELEM does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test115115,"public void test115115() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-584), (-584), (-584));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(35, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GETELEM does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test116116,"public void test116116() throws Throwable {
    Node node0 = new Node(78);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(100, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // OR does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test117117,"public void test117117() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122);
    Node node1 = new Node(101, node0, node0, 1, 0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // AND 1 : com.google.javascript.rhino.jstype.VoidType@0000000045 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test118118,"public void test118118() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, (-1), (-1));
    Node node1 = new Node(100, node0, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    node0.addChildToBack(node1);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: StackOverflowError"");
    } catch (StackOverflowError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",0,
project,0,test119119,"public void test119119() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
    assertSame(booleanLiteralSet1, booleanLiteralSet0);
}",0,
