focal_method,test_prefix,docstring
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test000() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node((-1474), (-1474), (-1474));
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(29, Node.JSDOC_INFO_PROP);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"boolean areMatchingExits(Node nodeThis, Node nodeThat) {
    return nodeThis.isEquivalentTo(nodeThat) && (!isExceptionPossible(nodeThis) || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));
}","public void test011() throws Throwable {
    Node node0 = new Node(49);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.areMatchingExits(node0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ControlFlowAnalysis"", e);
    }
}","/**
 * Check whether one exit can be replaced with another. Verify:
 * 1) They are identical expressions
 * 2) If an exception is possible that the statements, the original
 * and the potential replacement are in the same exception handler.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test022() throws Throwable {
    Node node0 = new Node(4, 55, 40);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test033() throws Throwable {
    Node node0 = Node.newNumber(479.7);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = new Node(26, node0, node0, node0, node0, 49, 40);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test044() throws Throwable {
    Node node0 = new Node(43);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isAssignAdd() {
    return this.getType() == Token.ASSIGN_ADD;
}","public void test055() throws Throwable {
    Node node0 = new Node(44, 44, 44);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isAssignAdd());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test066() throws Throwable {
    Node node0 = new Node(49);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isEmpty() {
    return this.getType() == Token.EMPTY;
}","public void test077() throws Throwable {
    Node node0 = new Node(63);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isEmpty());
}",""
"public boolean isThrow() {
    return this.getType() == Token.THROW;
}","public void test088() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(85, 85, 85);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isThrow());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test099() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node((-1474), (-1474), (-1474));
    Node node1 = new Node(108, node0, node0, node0, node0, 39, 46);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1010() throws Throwable {
    Node node0 = new Node(113, 113, 113);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1111() throws Throwable {
    Node node0 = new Node(114);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1212() throws Throwable {
    Node node0 = new Node(130, 130, 130);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1313() throws Throwable {
    Node node0 = Node.newNumber((-4193.0));
    Node node1 = new Node(4, 55, 40);
    Node node2 = new Node(8, node1, node0, 15, 53);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isAnd() {
    return this.getType() == Token.AND;
}","public void test1414() throws Throwable {
    Node node0 = new Node(30, 30, 30);
    Compiler compiler0 = new Compiler();
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isAnd());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1515() throws Throwable {
    Node node0 = Node.newNumber(1626.0);
    Node node1 = new Node(37, node0, node0, node0, node0, 53, 37);
    Compiler compiler0 = new Compiler();
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1616() throws Throwable {
    Node node0 = new Node(115, 115, 115);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // malformed 'for' statement FOR 115
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1717() throws Throwable {
    Node node0 = new Node(43, 43, 43);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node1 = new Node(115, node0, node0, node0, node0, 52, 55);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // malformed 'for' statement FOR 52
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1818() throws Throwable {
    Node node0 = new Node(115, 115, 115);
    node0.addChildToFront(node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // malformed 'for' statement FOR 115
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1919() throws Throwable {
    Node node0 = new Node(37, 53, 100);
    Compiler compiler0 = new Compiler();
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2020() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node0 = new Node(85, 85, 85);
    Node node1 = new Node(85, node0, node0, node0, node0, 55, 40);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertNotNull(node2);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test2021() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node0 = new Node(85, 85, 85);
    Node node1 = new Node(85, node0, node0, node0, node0, 55, 40);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node2.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"public int getType() {
    return type;
}","public void test2122() throws Throwable {
    Node node0 = Node.newNumber(0.0);
    Node node1 = new Node(125, node0, node0, node0, node0, 53, 125);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(125, node2.getType());
}",""
"public boolean isBlock() {
    return this.getType() == Token.BLOCK;
}","public void test2223() throws Throwable {
    Node node0 = new Node(38, 38, 38);
    Compiler compiler0 = new Compiler();
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isBlock());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2324() throws Throwable {
    Node node0 = Node.newNumber(0.0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = new Node(4, node0, node0, node0, node0, 54, 30);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"boolean isPure(Node n) {
    return n == null || (!NodeUtil.canBeSideEffected(n) && !mayHaveSideEffects(n));
}","public void test2425() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.isPure((Node) null);
    assertTrue(boolean0);
}","/**
 * @return Whether the expression does not produces and can not be affected
 * by side-effects.
 */"
"boolean isPure(Node n) {
    return n == null || (!NodeUtil.canBeSideEffected(n) && !mayHaveSideEffects(n));
}","public void test2526() throws Throwable {
    Node node0 = new Node(115, 115, 115);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.isPure(node0);
    assertFalse(boolean0);
}","/**
 * @return Whether the expression does not produces and can not be affected
 * by side-effects.
 */"
"boolean isPure(Node n) {
    return n == null || (!NodeUtil.canBeSideEffected(n) && !mayHaveSideEffects(n));
}","public void test2627() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Y"");
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    peepholeSubstituteAlternateSyntax0.isPure(node0);
}","/**
 * @return Whether the expression does not produces and can not be affected
 * by side-effects.
 */"
"boolean isPure(Node n) {
    return n == null || (!NodeUtil.canBeSideEffected(n) && !mayHaveSideEffects(n));
}","public void test2728() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node0 = Node.newString(""\u2028"");
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.isPure(node0);
    assertTrue(boolean0);
}","/**
 * @return Whether the expression does not produces and can not be affected
 * by side-effects.
 */"
"boolean areMatchingExits(Node nodeThis, Node nodeThat) {
    return nodeThis.isEquivalentTo(nodeThat) && (!isExceptionPossible(nodeThis) || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));
}","public void test2829() throws Throwable {
    Node node0 = Node.newNumber(0.0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node1 = new Node(4, node0, node0, node0, node0, 54, 30);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.areMatchingExits(node1, node1);
    assertTrue(boolean0);
}","/**
 * Check whether one exit can be replaced with another. Verify:
 * 1) They are identical expressions
 * 2) If an exception is possible that the statements, the original
 * and the potential replacement are in the same exception handler.
 */"
"boolean areMatchingExits(Node nodeThis, Node nodeThat) {
    return nodeThis.isEquivalentTo(nodeThat) && (!isExceptionPossible(nodeThis) || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));
}","public void test2930() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = Node.newNumber(0.0);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.areMatchingExits(node0, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Check whether one exit can be replaced with another. Verify:
 * 1) They are identical expressions
 * 2) If an exception is possible that the statements, the original
 * and the potential replacement are in the same exception handler.
 */"
"boolean isExceptionPossible(Node n) {
    // TODO(johnlenz): maybe use ControlFlowAnalysis.mayThrowException?
    Preconditions.checkState(n.isReturn() || n.isThrow());
    return n.isThrow() || (n.hasChildren() && !NodeUtil.isLiteralValue(n.getLastChild(), true));
}","public void test3031() throws Throwable {
    Node node0 = new Node(4);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.isExceptionPossible(node0);
    assertFalse(boolean0);
}",""
"boolean isExceptionPossible(Node n) {
    // TODO(johnlenz): maybe use ControlFlowAnalysis.mayThrowException?
    Preconditions.checkState(n.isReturn() || n.isThrow());
    return n.isThrow() || (n.hasChildren() && !NodeUtil.isLiteralValue(n.getLastChild(), true));
}","public void test3132() throws Throwable {
    Node node0 = new Node(115, 115, 115);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = new Node(4, node0, node0, node0, node0, 16, 441);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.isExceptionPossible(node1);
    assertTrue(boolean0);
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3233() throws Throwable {
    Node node0 = Node.newNumber(479.7);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    node0.setType(46);
    Node node1 = new Node(26, node0, node0, node0, node0, 49, 40);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3334() throws Throwable {
    Node node0 = Node.newNumber((-2584.919495491));
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    node0.setType(45);
    Node node1 = new Node(26, node0, node0, node0, node0, 49, 40);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3435() throws Throwable {
    Node node0 = Node.newNumber(0.0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node1 = new Node(26, node0, node0, node0, node0, 0, 40);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertNotNull(node2);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test3436() throws Throwable {
    Node node0 = Node.newNumber(0.0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node1 = new Node(26, node0, node0, node0, node0, 0, 40);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(40, node2.getCharno());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3537() throws Throwable {
    Node node0 = Node.newNumber(0.0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = new Node(108, node0, node0, node0, node0, 12, 4095);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertNotNull(node2);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test3538() throws Throwable {
    Node node0 = Node.newNumber(0.0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = new Node(108, node0, node0, node0, node0, 12, 4095);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertTrue(node2.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3639() throws Throwable {
    Node node0 = Node.newNumber((-1.0));
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    node0.setType(26);
    Node node1 = new Node(26, node0, node0, node0, node0, 16, 2);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3740() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(98);
    Node node1 = new Node(98, node0, node0, node0, node0, 55, 55);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3841() throws Throwable {
    Node node0 = new Node(44);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3942() throws Throwable {
    Node node0 = new Node(63);
    Node node1 = new Node(63, node0, node0, node0, node0, 4095, 39);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(46, Node.IS_NAMESPACE);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isFor() {
    return this.getType() == Token.FOR;
}","public void test4043() throws Throwable {
    Node node0 = new Node(63);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isFor());
}",""
"static boolean containsUnicodeEscape(String s) {
    String esc = REGEXP_ESCAPER.regexpEscape(s);
    for (int i = -1; (i = esc.indexOf(""\\u"", i + 1)) >= 0; ) {
        int nSlashes = 0;
        while (i - nSlashes > 0 && '\\' == esc.charAt(i - nSlashes - 1)) {
            ++nSlashes;
        }
        // if there are an even number of slashes before the \ u then it is a
        // Unicode literal.
        if (0 == (nSlashes & 1)) {
            return true;
        }
    }
    return false;
}","public void test4144() throws Throwable {
    boolean boolean0 = PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(""bcR4Qsho-Mo(G?"");
    assertTrue(boolean0);
}","/**
 * true if the JavaScript string would contain a Unicode escape when written
 * out as the body of a regular expression literal.
 */"
