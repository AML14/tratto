focal_method,test_prefix,docstring
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test000() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""language version"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = Node.newString(""language version"", 130, 12);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.EOC;
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertTrue(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean hasParsedJSDocInfo() {
    return jsdocBuilder.isPopulated();
}","public void test011() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""error reporter"", 12);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = Node.newString(""language version"", 130, 12);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.hasParsedJSDocInfo();
    assertFalse(boolean0);
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test022() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""language version"", 5, 160);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = JsDocInfoParser.parseTypeString(""error reporter"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test023() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""language version"", 5, 160);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = JsDocInfoParser.parseTypeString(""error reporter"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    jsDocInfoParser0.getFileOverviewJSDocInfo();
    assertEquals(0, node0.getSourcePosition());
}",""
"public boolean isString() {
    return this.getType() == Token.STRING;
}","public void test024() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""language version"", 5, 160);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = JsDocInfoParser.parseTypeString(""error reporter"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    jsDocInfoParser0.getFileOverviewJSDocInfo();
    assertTrue(node0.isString());
}",""
"void setFileLevelJsDocBuilder(Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {
    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;
}","public void test035() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("") {\n"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, toolErrorReporter0);
    jsDocInfoParser0.setFileLevelJsDocBuilder((Node.FileLevelJsDocBuilder) null);
}","/**
 * Sets the JsDocBuilder for the file-level (root) node of this parse. The
 * parser uses the builder to append any preserve annotations it encounters
 * in JsDoc comments.
 *
 * @param fileLevelJsDocBuilder
 */"
"public boolean isExterns() {
    return getFlag(MASK_EXTERNS);
}","public void test046() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""language version"", 1, 150);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = Node.newString(10, ""language version"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    jsDocInfoParser0.setFileOverviewJSDocInfo(jSDocInfo0);
    assertFalse(jSDocInfo0.isExterns());
}","/**
 * Returns whether the {@code @externs} annotation is present on this
 * {@link JSDocInfo}.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test057() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(A\""C+\n"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test068() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{5NFv8OUHN:k?%nN"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test079() throws Throwable {
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Charset charset0 = Charset.defaultCharset();
    Set<String> set0 = charset0.aliases();
    Config config0 = new Config(set0, set0, true, config_LanguageMode0, false);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""K|oPruG,U,{7!)K,"", 1007);
    Token.CommentType token_CommentType0 = Token.CommentType.HTML;
    Comment comment0 = new Comment(1007, 1007, token_CommentType0, ""i<Mhk"");
    Node node0 = Node.newString(""nzhh \""eKp"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, errorCollector0);
    jsDocInfoParser0.parseInlineTypeDoc();
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test0810() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""error reporter"", 110);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = JsDocInfoParser.parseTypeString(""language version"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test0811() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""error reporter"", 110);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = JsDocInfoParser.parseTypeString(""language version"");
    node0.setSourceFileForTesting(""msg.end.annotation.expected"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"public int getType() {
    return type;
}","public void test0812() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""error reporter"", 110);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = JsDocInfoParser.parseTypeString(""language version"");
    node0.setSourceFileForTesting(""msg.end.annotation.expected"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertEquals(40, node0.getType());
}",""
"public int getSourcePosition() {
    return sourcePosition;
}","public void test0813() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""error reporter"", 110);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = JsDocInfoParser.parseTypeString(""language version"");
    node0.setSourceFileForTesting(""msg.end.annotation.expected"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertEquals(0, node0.getSourcePosition());
}",""
"public JSDocInfo parseInlineTypeDoc() {
    skipEOLs();
    JsDocToken token = next();
    int lineno = stream.getLineno();
    int startCharno = stream.getCharno();
    Node typeAst = parseTypeExpression(token);
    recordTypeNode(lineno, startCharno, typeAst, token == JsDocToken.LC);
    JSTypeExpression expr = createJSTypeExpression(typeAst);
    if (expr != null) {
        jsdocBuilder.recordType(expr);
        return retrieveAndResetParsedJSDocInfo();
    }
    return null;
}","public void test0914() throws Throwable {
    Locale locale0 = Locale.CANADA;
    Set<String> set0 = locale0.getUnicodeLocaleAttributes();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""QC{Y7&u#F"", 22);
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(set0, set0, true, config_LanguageMode0, true);
    Token.CommentType token_CommentType0 = Token.CommentType.LINE;
    Comment comment0 = new Comment(1, 2, token_CommentType0, ""msg.jsdoc.modifies"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, (Node) null, config0, toolErrorReporter0);
    jsDocInfoParser0.parseInlineTypeDoc();
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.parseInlineTypeDoc();
    assertNull(jSDocInfo0);
}","/**
 * Parse a description as a {@code @type}.
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test1015() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("") {\n"", 37, 38);
    HashSet<String> hashSet0 = new HashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(hashSet0, hashSet0, false, config_LanguageMode0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), token == JsDocToken.LC, false);
}","public void test1116() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(1664, ""zj+\n"");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""@gLp{fr/EZPa"", 0, (-1794726114));
    Token.CommentType token_CommentType0 = Token.CommentType.HTML;
    Comment comment0 = new Comment((-1882502395), (-3483), token_CommentType0, ""zj+\n"");
    ContextFactory contextFactory0 = ContextFactory.getGlobal();
    Context context0 = contextFactory0.enterContext();
    ErrorReporter errorReporter0 = context0.getErrorReporter();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, errorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.ANNOTATION;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertNull(node1);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test1117() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(1664, ""zj+\n"");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""@gLp{fr/EZPa"", 0, (-1794726114));
    Token.CommentType token_CommentType0 = Token.CommentType.HTML;
    Comment comment0 = new Comment((-1882502395), (-3483), token_CommentType0, ""zj+\n"");
    ContextFactory contextFactory0 = ContextFactory.getGlobal();
    Context context0 = contextFactory0.enterContext();
    ErrorReporter errorReporter0 = context0.getErrorReporter();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, errorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.ANNOTATION;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), token == JsDocToken.LC, false);
}","public void test1218() throws Throwable {
    Node node0 = Node.newString(""[diA4p?q|"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("") {\n"", 37, 38);
    HashSet<String> hashSet0 = new HashSet<String>(100);
    jsDocTokenStream0.getRemainingJSDocLine();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(hashSet0, hashSet0, false, config_LanguageMode0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.ANNOTATION;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertNull(node1);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test1219() throws Throwable {
    Node node0 = Node.newString(""[diA4p?q|"");
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("") {\n"", 37, 38);
    HashSet<String> hashSet0 = new HashSet<String>(100);
    jsDocTokenStream0.getRemainingJSDocLine();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(hashSet0, hashSet0, false, config_LanguageMode0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.ANNOTATION;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test1320() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""@*"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""(3/wN5yg+["", 100, (-1008));
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test1421() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""*"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = JsDocInfoParser.parseTypeString(""*"");
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), token == JsDocToken.LC, false);
}","public void test1522() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""language version"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = Node.newString(""language version"", 130, 12);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertNotNull(node1);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test1523() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""language version"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = Node.newString(""language version"", 130, 12);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(0, node1.getSourcePosition());
}",""
"public int getType() {
    return type;
}","public void test1524() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""language version"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, false);
    Node node0 = Node.newString(""language version"", 130, 12);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(40, node1.getType());
}",""
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test1625() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""!"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test1726() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("","");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString("","");
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test1827() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("":)}"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test1928() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("" {\n"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test2029() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""($$S2rL&u0b^|"");
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""($$S2rL&u0b^|"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test2130() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""?5}|Z!El.,?g"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""?5}|Z!El.,?g"");
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test2231() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""]&G=\""'"", 42);
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test2332() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""}\n"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test2433() throws Throwable {
    Node node0 = Node.newString(""U!iA4qM|"");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""=#dIcS]#?kPG3Ju"");
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, false);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test2534() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""*"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""*"");
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test2635() throws Throwable {
    HashSet<String> hashSet0 = new HashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(hashSet0, hashSet0, true, config_LanguageMode0, true);
    Node node0 = JsDocInfoParser.parseTypeString(""t/Ij^G "");
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""t/Ij^G "", 30);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), token == JsDocToken.LC, false);
}","public void test2736() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""]q=<'"");
    Token.CommentType token_CommentType0 = Token.CommentType.JSDOC;
    Comment comment0 = new Comment(12, 16, token_CommentType0, ""]q=<'"");
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, true);
    Context context0 = new Context();
    ErrorReporter errorReporter0 = context0.getErrorReporter();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, (Node) null, config0, errorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node0 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertNull(node0);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test2837() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""5s'3O`<}}"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, false);
    Node node0 = Node.newString("""", 305, 305);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(0, node1.getSourcePosition());
}",""
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), token == JsDocToken.LC, false);
}","public void test2838() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""5s'3O`<}}"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, false);
    Node node0 = Node.newString("""", 305, 305);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertNotNull(node1);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"public int getType() {
    return type;
}","public void test2839() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""5s'3O`<}}"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, false);
    Node node0 = Node.newString("""", 305, 305);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.LC;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(40, node1.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test2940() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""~|||(g$n_&meda"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3041() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""C.<RYqh^1*s(su"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3142() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""C.<{Y=qh^1(s"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test3143() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""C.<{Y=qh^1(s"");
    assertEquals(40, node0.getType());
}",""
"public int getSourcePosition() {
    return sourcePosition;
}","public void test3144() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""C.<{Y=qh^1(s"");
    assertEquals(0, node0.getSourcePosition());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3245() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""C.<RYqh^10,"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getSourcePosition() {
    return sourcePosition;
}","public void test3246() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""C.<RYqh^10,"");
    assertEquals(0, node0.getSourcePosition());
}",""
"public int getType() {
    return type;
}","public void test3247() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""C.<RYqh^10,"");
    assertEquals(40, node0.getType());
}",""
"public int getType() {
    return type;
}","public void test3348() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("","", 48, 4);
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorCollector0);
    JsDocToken jsDocToken0 = JsDocToken.QMARK;
    Node node0 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(304, node0.getType());
}",""
"public int getType() {
    return type;
}","public void test3449() throws Throwable {
    Node node0 = Node.newString(""U!iA4qM|"");
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""=#dIcS]#?kPG3Ju"");
    TreeSet<String> treeSet0 = new TreeSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(treeSet0, treeSet0, true, config_LanguageMode0, false);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, errorCollector0);
    JsDocToken jsDocToken0 = JsDocToken.QMARK;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(304, node1.getType());
}",""
"public int getType() {
    return type;
}","public void test3550() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""]&G=\""'"", 42);
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorCollector0);
    JsDocToken jsDocToken0 = JsDocToken.QMARK;
    Node node0 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(304, node0.getType());
}",""
"public int getType() {
    return type;
}","public void test3651() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?}h[A(!$:|1HTlqYiXC"");
    assertEquals(304, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3652() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?}h[A(!$:|1HTlqYiXC"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test3753() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("")}rK"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocToken jsDocToken0 = JsDocToken.QMARK;
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorCollector0);
    Node node0 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(304, node0.getType());
}",""
"public JSDocInfo parseInlineTypeDoc() {
    skipEOLs();
    JsDocToken token = next();
    int lineno = stream.getLineno();
    int startCharno = stream.getCharno();
    Node typeAst = parseTypeExpression(token);
    recordTypeNode(lineno, startCharno, typeAst, token == JsDocToken.LC);
    JSTypeExpression expr = createJSTypeExpression(typeAst);
    if (expr != null) {
        jsdocBuilder.recordType(expr);
        return retrieveAndResetParsedJSDocInfo();
    }
    return null;
}","public void test3854() throws Throwable {
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Charset charset0 = Charset.defaultCharset();
    Set<String> set0 = charset0.aliases();
    Config config0 = new Config(set0, set0, true, config_LanguageMode0, false);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""K|oPruG,U,{7!)K,"", 1007);
    Token.CommentType token_CommentType0 = Token.CommentType.HTML;
    Comment comment0 = new Comment(1007, 1007, token_CommentType0, ""i<Mhk"");
    Node node0 = Node.newString(""nzhh \""eKp"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, errorCollector0);
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.parseInlineTypeDoc();
    assertNotNull(jSDocInfo0);
}","/**
 * Parse a description as a {@code @type}.
 */"
"public boolean hasChildren() {
    return first != null;
}","public void test3855() throws Throwable {
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Charset charset0 = Charset.defaultCharset();
    Set<String> set0 = charset0.aliases();
    Config config0 = new Config(set0, set0, true, config_LanguageMode0, false);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""K|oPruG,U,{7!)K,"", 1007);
    Token.CommentType token_CommentType0 = Token.CommentType.HTML;
    Comment comment0 = new Comment(1007, 1007, token_CommentType0, ""i<Mhk"");
    Node node0 = Node.newString(""nzhh \""eKp"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, errorCollector0);
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.parseInlineTypeDoc();
    JsDocToken jsDocToken0 = JsDocToken.QMARK;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertFalse(node1.hasChildren());
}",""
"public int getType() {
    return type;
}","public void test3856() throws Throwable {
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Charset charset0 = Charset.defaultCharset();
    Set<String> set0 = charset0.aliases();
    Config config0 = new Config(set0, set0, true, config_LanguageMode0, false);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""K|oPruG,U,{7!)K,"", 1007);
    Token.CommentType token_CommentType0 = Token.CommentType.HTML;
    Comment comment0 = new Comment(1007, 1007, token_CommentType0, ""i<Mhk"");
    Node node0 = Node.newString(""nzhh \""eKp"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, errorCollector0);
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.parseInlineTypeDoc();
    JsDocToken jsDocToken0 = JsDocToken.QMARK;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertEquals(304, node1.getType());
}",""
"public int getType() {
    return type;
}","public void test3957() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?>"");
    assertEquals(304, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3958() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?>"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test4059() throws Throwable {
    Context context0 = new Context();
    ErrorReporter errorReporter0 = context0.getErrorReporter();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""language version"");
    Locale locale0 = Locale.forLanguageTag(""[diAJq>|"");
    Set<String> set0 = locale0.getUnicodeLocaleAttributes();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(set0, set0, false, config_LanguageMode0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.EOC;
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    JsDocToken jsDocToken1 = JsDocToken.QMARK;
    Node node0 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken1);
    assertEquals(304, node0.getType());
}",""
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), token == JsDocToken.LC, false);
}","public void test4060() throws Throwable {
    Context context0 = new Context();
    ErrorReporter errorReporter0 = context0.getErrorReporter();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""language version"");
    Locale locale0 = Locale.forLanguageTag(""[diAJq>|"");
    Set<String> set0 = locale0.getUnicodeLocaleAttributes();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(set0, set0, false, config_LanguageMode0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.EOC;
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    JsDocToken jsDocToken1 = JsDocToken.QMARK;
    Node node0 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken1);
    assertNotNull(node0);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"public int getLineno() {
    return extractLineno(sourcePosition);
}","public void test4061() throws Throwable {
    Context context0 = new Context();
    ErrorReporter errorReporter0 = context0.getErrorReporter();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""language version"");
    Locale locale0 = Locale.forLanguageTag(""[diAJq>|"");
    Set<String> set0 = locale0.getUnicodeLocaleAttributes();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT3;
    Config config0 = new Config(set0, set0, false, config_LanguageMode0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, (Node) null, config0, errorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.EOC;
    jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    JsDocToken jsDocToken1 = JsDocToken.QMARK;
    Node node0 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken1);
    assertEquals((-1), node0.getLineno());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4162() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""!"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test4263() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""2r`+S!"");
    assertEquals(306, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4364() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""function ("");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test4465() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""null"");
    assertEquals(40, node0.getType());
}",""
"public int getSourcePosition() {
    return sourcePosition;
}","public void test4466() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""null"");
    assertEquals(0, node0.getSourcePosition());
}",""
"public int getType() {
    return type;
}","public void test4567() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""undefined"");
    assertEquals(40, node0.getType());
}",""
"public int getSourcePosition() {
    return sourcePosition;
}","public void test4568() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""undefined"");
    assertEquals(0, node0.getSourcePosition());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4669() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""function"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4770() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(V8,&r?z|<,C08F5|mJ"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4871() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(Q|i5'T$LbCuSi9b\"""");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test4972() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""o|~1KW@}d"");
    assertEquals(301, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4973() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""o|~1KW@}d"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test4974() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""o|~1KW@}d"");
    assertFalse(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5075() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(Lorg/mozilla/javascript/Context;Lorg/mozilla/javascript/Scriptable;)V"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test5076() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(Lorg/mozilla/javascript/Context;Lorg/mozilla/javascript/Scriptable;)V"");
    assertTrue(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"public int getType() {
    return type;
}","public void test5077() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(Lorg/mozilla/javascript/Context;Lorg/mozilla/javascript/Scriptable;)V"");
    assertEquals(301, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5178() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[R+,Q"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), token == JsDocToken.LC, false);
}","public void test5279() throws Throwable {
    TreeSet<String> treeSet0 = new TreeSet<String>();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""..."", 19, 19);
    Token.CommentType token_CommentType0 = Token.CommentType.JSDOC;
    Comment comment0 = new Comment(19, 20, token_CommentType0, ""..."");
    Node node0 = Node.newString("""", 21, 1);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5;
    Config config0 = new Config(treeSet0, linkedHashSet0, true, config_LanguageMode0, true);
    ErrorCollector errorCollector0 = new ErrorCollector();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, comment0, node0, config0, errorCollector0);
    JsDocToken jsDocToken0 = JsDocToken.LB;
    // Undeclared exception!
    try {
        jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.head.ast.ErrorCollector"", e);
    }
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5380() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""["");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5481() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[f]qAY"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test5482() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[f]qAY"");
    assertEquals(308, node0.getType());
}",""
"public boolean hasChildren() {
    return first != null;
}","public void test5483() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[f]qAY"");
    assertTrue(node0.hasChildren());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5584() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString("" {\n"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test5685() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{t}F0&5"");
    assertEquals(309, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5686() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{t}F0&5"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public boolean hasChildren() {
    return first != null;
}","public void test5687() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{t}F0&5"");
    assertTrue(node0.hasChildren());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5788() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{/C,)JV{3IvwkWN*"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test5889() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{5NFv8OUHCN:]?%nN"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test5990() throws Throwable {
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""%n*/}OU.|s "", 322);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, false, config_LanguageMode0, true);
    Node node0 = Node.newString((-215), ""(e8,m]zv^^<CC70Uh,"", (-1221), (-1138));
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertTrue(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"Node parseAndRecordTypeNode(JsDocToken token) {
    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), token == JsDocToken.LC, false);
}","public void test6091() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""@*"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""(3/wN5yg+["", 100, (-1008));
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    jsDocTokenStream0.getChar();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.EOL;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    assertNull(node1);
}","/**
 * Looks for a type expression at the current token and if found,
 * returns it. Note that this method consumes input.
 *
 * @param token The current token.
 * @return The type expression found or null if none.
 */"
"boolean parse() {
    state = State.SEARCHING_ANNOTATION;
    skipEOLs();
    JsDocToken token = next();
    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
        ExtractionInfo blockInfo = extractBlockComment(token);
        token = blockInfo.token;
        if (!blockInfo.string.isEmpty()) {
            jsdocBuilder.recordBlockDescription(blockInfo.string);
        }
    } else {
        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
            // Mark that there was a description, but don't bother marking
            // what it was.
            jsdocBuilder.recordBlockDescription("""");
        }
    }
    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());
}","public void test6092() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""@*"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config.LanguageMode config_LanguageMode0 = Config.LanguageMode.ECMASCRIPT5_STRICT;
    Config config0 = new Config(linkedHashSet0, linkedHashSet0, true, config_LanguageMode0, true);
    Node node0 = Node.newString(""(3/wN5yg+["", 100, (-1008));
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    jsDocTokenStream0.getChar();
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, (Comment) null, node0, config0, toolErrorReporter0);
    JsDocToken jsDocToken0 = JsDocToken.EOL;
    Node node1 = jsDocInfoParser0.parseAndRecordTypeNode(jsDocToken0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
