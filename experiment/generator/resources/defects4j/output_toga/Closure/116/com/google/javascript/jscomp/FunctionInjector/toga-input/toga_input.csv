focal_method,test_prefix,docstring
"@Override
Node parseSyntheticCode(String fileName, String js) {
    initCompilerOptionsIfTesting();
    return parse(SourceFile.fromCode(fileName, js));
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, false, false, false);
    GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
    // Undeclared exception!
    try {
        compiler0.parseSyntheticCode(""eM6;%l)8fT"", ""$VALUES"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // duplicate key: desc
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"void maybePrepareCall(Node callNode) {
    CallSiteType callSiteType = classifyCallSite(callNode);
    callSiteType.prepare(this, callNode);
}","public void test011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, true, true, true);
    // Undeclared exception!
    try {
        functionInjector0.maybePrepareCall((Node) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.FunctionInjector"", e);
    }
}","/**
 * If required, rewrite the statement containing the call expression.
 * @see ExpressionDecomposer#canExposeExpression
 */"
"@Override
Node parseSyntheticCode(String fileName, String js) {
    initCompilerOptionsIfTesting();
    return parse(SourceFile.fromCode(fileName, js));
}","public void test022() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, false, false, false);
    GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
    Set<String> set0 = NameAnalyzer.DEFAULT_GLOBAL_NAMES;
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
    // Undeclared exception!
    try {
        compiler0.parseSyntheticCode(""$VALUES"", ""$VALUES"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // duplicate key: desc
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
Node parseSyntheticCode(String fileName, String js) {
    initCompilerOptionsIfTesting();
    return parse(SourceFile.fromCode(fileName, js));
}","public void test033() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, true, true, true);
    GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
    Set<String> set0 = NameAnalyzer.DEFAULT_GLOBAL_NAMES;
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
    // Undeclared exception!
    try {
        compiler0.parseSyntheticCode(""lastIndexOf"", ""lastIndexOf"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // duplicate key: desc
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
Node parseSyntheticCode(String fileName, String js) {
    initCompilerOptionsIfTesting();
    return parse(SourceFile.fromCode(fileName, js));
}","public void test044() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, false, false, false);
    GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
    // Undeclared exception!
    try {
        compiler0.parseSyntheticCode(""eM6;%l)8fT"", ""$VALUES"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // duplicate key: desc
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"boolean inliningLowersCost(JSModule fnModule, Node fnNode, Collection<? extends Reference> refs, Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {
    int referenceCount = refs.size();
    if (referenceCount == 0) {
        return true;
    }
    int referencesUsingBlockInlining = 0;
    boolean checkModules = isRemovable && fnModule != null;
    JSModuleGraph moduleGraph = compiler.getModuleGraph();
    for (Reference ref : refs) {
        if (ref.mode == InliningMode.BLOCK) {
            referencesUsingBlockInlining++;
        }
        // Check if any of the references cross the module boundaries.
        if (checkModules && ref.module != null) {
            if (ref.module != fnModule && !moduleGraph.dependsOn(ref.module, fnModule)) {
                // Calculate the cost as if the function were non-removable,
                // if it still lowers the cost inline it.
                isRemovable = false;
                // no need to check additional modules.
                checkModules = false;
            }
        }
    }
    int referencesUsingDirectInlining = referenceCount - referencesUsingBlockInlining;
    // Don't bother calculating the cost of function for simple functions where
    // possible.
    // However, when inlining a complex function, even a single reference may be
    // larger than the original function if there are many returns (resulting
    // in additional assignments) or many parameters that need to be aliased
    // so use the cost estimating.
    if (referenceCount == 1 && isRemovable && referencesUsingDirectInlining == 1) {
        return true;
    }
    int callCost = estimateCallCost(fnNode, referencesThis);
    int overallCallCost = callCost * referenceCount;
    int costDeltaDirect = inlineCostDelta(fnNode, namesToAlias, InliningMode.DIRECT);
    int costDeltaBlock = inlineCostDelta(fnNode, namesToAlias, InliningMode.BLOCK);
    return doesLowerCost(fnNode, overallCallCost, referencesUsingDirectInlining, costDeltaDirect, referencesUsingBlockInlining, costDeltaBlock, isRemovable);
}","public void test055() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, false, false, false);
    JSModule jSModule0 = new JSModule("""");
    Node node0 = Node.newString("""");
    HashSet<FunctionInjector.Reference> hashSet0 = new HashSet<FunctionInjector.Reference>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    FunctionInjector.InliningMode functionInjector_InliningMode0 = FunctionInjector.InliningMode.DIRECT;
    FunctionInjector.Reference functionInjector_Reference0 = new FunctionInjector.Reference(node0, jSModule0, functionInjector_InliningMode0);
    ImmutableList<FunctionInjector.Reference> immutableList0 = ImmutableList.of(functionInjector_Reference0, functionInjector_Reference0);
    hashSet0.addAll(immutableList0);
    boolean boolean0 = functionInjector0.inliningLowersCost(jSModule0, node0, hashSet0, compilerOptions0.aliasableStrings, true, false);
    assertTrue(boolean0);
}","/**
 * Determine if inlining the function is likely to reduce the code size.
 * @param namesToAlias
 */"
"boolean inliningLowersCost(JSModule fnModule, Node fnNode, Collection<? extends Reference> refs, Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {
    int referenceCount = refs.size();
    if (referenceCount == 0) {
        return true;
    }
    int referencesUsingBlockInlining = 0;
    boolean checkModules = isRemovable && fnModule != null;
    JSModuleGraph moduleGraph = compiler.getModuleGraph();
    for (Reference ref : refs) {
        if (ref.mode == InliningMode.BLOCK) {
            referencesUsingBlockInlining++;
        }
        // Check if any of the references cross the module boundaries.
        if (checkModules && ref.module != null) {
            if (ref.module != fnModule && !moduleGraph.dependsOn(ref.module, fnModule)) {
                // Calculate the cost as if the function were non-removable,
                // if it still lowers the cost inline it.
                isRemovable = false;
                // no need to check additional modules.
                checkModules = false;
            }
        }
    }
    int referencesUsingDirectInlining = referenceCount - referencesUsingBlockInlining;
    // Don't bother calculating the cost of function for simple functions where
    // possible.
    // However, when inlining a complex function, even a single reference may be
    // larger than the original function if there are many returns (resulting
    // in additional assignments) or many parameters that need to be aliased
    // so use the cost estimating.
    if (referenceCount == 1 && isRemovable && referencesUsingDirectInlining == 1) {
        return true;
    }
    int callCost = estimateCallCost(fnNode, referencesThis);
    int overallCallCost = callCost * referenceCount;
    int costDeltaDirect = inlineCostDelta(fnNode, namesToAlias, InliningMode.DIRECT);
    int costDeltaBlock = inlineCostDelta(fnNode, namesToAlias, InliningMode.BLOCK);
    return doesLowerCost(fnNode, overallCallCost, referencesUsingDirectInlining, costDeltaDirect, referencesUsingBlockInlining, costDeltaBlock, isRemovable);
}","public void test066() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, true, true, true);
    ArrayDeque<FunctionInjector.Reference> arrayDeque0 = new ArrayDeque<FunctionInjector.Reference>();
    boolean boolean0 = functionInjector0.inliningLowersCost((JSModule) null, (Node) null, arrayDeque0, (Set<String>) null, true, true);
    assertTrue(boolean0);
}","/**
 * Determine if inlining the function is likely to reduce the code size.
 * @param namesToAlias
 */"
"boolean inliningLowersCost(JSModule fnModule, Node fnNode, Collection<? extends Reference> refs, Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {
    int referenceCount = refs.size();
    if (referenceCount == 0) {
        return true;
    }
    int referencesUsingBlockInlining = 0;
    boolean checkModules = isRemovable && fnModule != null;
    JSModuleGraph moduleGraph = compiler.getModuleGraph();
    for (Reference ref : refs) {
        if (ref.mode == InliningMode.BLOCK) {
            referencesUsingBlockInlining++;
        }
        // Check if any of the references cross the module boundaries.
        if (checkModules && ref.module != null) {
            if (ref.module != fnModule && !moduleGraph.dependsOn(ref.module, fnModule)) {
                // Calculate the cost as if the function were non-removable,
                // if it still lowers the cost inline it.
                isRemovable = false;
                // no need to check additional modules.
                checkModules = false;
            }
        }
    }
    int referencesUsingDirectInlining = referenceCount - referencesUsingBlockInlining;
    // Don't bother calculating the cost of function for simple functions where
    // possible.
    // However, when inlining a complex function, even a single reference may be
    // larger than the original function if there are many returns (resulting
    // in additional assignments) or many parameters that need to be aliased
    // so use the cost estimating.
    if (referenceCount == 1 && isRemovable && referencesUsingDirectInlining == 1) {
        return true;
    }
    int callCost = estimateCallCost(fnNode, referencesThis);
    int overallCallCost = callCost * referenceCount;
    int costDeltaDirect = inlineCostDelta(fnNode, namesToAlias, InliningMode.DIRECT);
    int costDeltaBlock = inlineCostDelta(fnNode, namesToAlias, InliningMode.BLOCK);
    return doesLowerCost(fnNode, overallCallCost, referencesUsingDirectInlining, costDeltaDirect, referencesUsingBlockInlining, costDeltaBlock, isRemovable);
}","public void test077() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector.InliningMode functionInjector_InliningMode0 = FunctionInjector.InliningMode.DIRECT;
    FunctionInjector.Reference functionInjector_Reference0 = new FunctionInjector.Reference((Node) null, (JSModule) null, functionInjector_InliningMode0);
    ImmutableList<FunctionInjector.Reference> immutableList0 = ImmutableList.of(functionInjector_Reference0);
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, true, true, false);
    LinkedListMultimap<String, Object> linkedListMultimap0 = LinkedListMultimap.create();
    Set<String> set0 = linkedListMultimap0.keySet();
    // Undeclared exception!
    try {
        functionInjector0.inliningLowersCost((JSModule) null, (Node) null, immutableList0, set0, false, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}","/**
 * Determine if inlining the function is likely to reduce the code size.
 * @param namesToAlias
 */"
"boolean inliningLowersCost(JSModule fnModule, Node fnNode, Collection<? extends Reference> refs, Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {
    int referenceCount = refs.size();
    if (referenceCount == 0) {
        return true;
    }
    int referencesUsingBlockInlining = 0;
    boolean checkModules = isRemovable && fnModule != null;
    JSModuleGraph moduleGraph = compiler.getModuleGraph();
    for (Reference ref : refs) {
        if (ref.mode == InliningMode.BLOCK) {
            referencesUsingBlockInlining++;
        }
        // Check if any of the references cross the module boundaries.
        if (checkModules && ref.module != null) {
            if (ref.module != fnModule && !moduleGraph.dependsOn(ref.module, fnModule)) {
                // Calculate the cost as if the function were non-removable,
                // if it still lowers the cost inline it.
                isRemovable = false;
                // no need to check additional modules.
                checkModules = false;
            }
        }
    }
    int referencesUsingDirectInlining = referenceCount - referencesUsingBlockInlining;
    // Don't bother calculating the cost of function for simple functions where
    // possible.
    // However, when inlining a complex function, even a single reference may be
    // larger than the original function if there are many returns (resulting
    // in additional assignments) or many parameters that need to be aliased
    // so use the cost estimating.
    if (referenceCount == 1 && isRemovable && referencesUsingDirectInlining == 1) {
        return true;
    }
    int callCost = estimateCallCost(fnNode, referencesThis);
    int overallCallCost = callCost * referenceCount;
    int costDeltaDirect = inlineCostDelta(fnNode, namesToAlias, InliningMode.DIRECT);
    int costDeltaBlock = inlineCostDelta(fnNode, namesToAlias, InliningMode.BLOCK);
    return doesLowerCost(fnNode, overallCallCost, referencesUsingDirectInlining, costDeltaDirect, referencesUsingBlockInlining, costDeltaBlock, isRemovable);
}","public void test088() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, true, true, true);
    GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
    Set<String> set0 = gatherRawExports0.getExportedVariableNames();
    FunctionInjector.InliningMode functionInjector_InliningMode0 = FunctionInjector.InliningMode.DIRECT;
    FunctionInjector.Reference functionInjector_Reference0 = new FunctionInjector.Reference((Node) null, (JSModule) null, functionInjector_InliningMode0);
    ImmutableList<FunctionInjector.Reference> immutableList0 = ImmutableList.of(functionInjector_Reference0, functionInjector_Reference0, functionInjector_Reference0, functionInjector_Reference0, functionInjector_Reference0);
    // Undeclared exception!
    try {
        functionInjector0.inliningLowersCost((JSModule) null, (Node) null, immutableList0, set0, true, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}","/**
 * Determine if inlining the function is likely to reduce the code size.
 * @param namesToAlias
 */"
"boolean inliningLowersCost(JSModule fnModule, Node fnNode, Collection<? extends Reference> refs, Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {
    int referenceCount = refs.size();
    if (referenceCount == 0) {
        return true;
    }
    int referencesUsingBlockInlining = 0;
    boolean checkModules = isRemovable && fnModule != null;
    JSModuleGraph moduleGraph = compiler.getModuleGraph();
    for (Reference ref : refs) {
        if (ref.mode == InliningMode.BLOCK) {
            referencesUsingBlockInlining++;
        }
        // Check if any of the references cross the module boundaries.
        if (checkModules && ref.module != null) {
            if (ref.module != fnModule && !moduleGraph.dependsOn(ref.module, fnModule)) {
                // Calculate the cost as if the function were non-removable,
                // if it still lowers the cost inline it.
                isRemovable = false;
                // no need to check additional modules.
                checkModules = false;
            }
        }
    }
    int referencesUsingDirectInlining = referenceCount - referencesUsingBlockInlining;
    // Don't bother calculating the cost of function for simple functions where
    // possible.
    // However, when inlining a complex function, even a single reference may be
    // larger than the original function if there are many returns (resulting
    // in additional assignments) or many parameters that need to be aliased
    // so use the cost estimating.
    if (referenceCount == 1 && isRemovable && referencesUsingDirectInlining == 1) {
        return true;
    }
    int callCost = estimateCallCost(fnNode, referencesThis);
    int overallCallCost = callCost * referenceCount;
    int costDeltaDirect = inlineCostDelta(fnNode, namesToAlias, InliningMode.DIRECT);
    int costDeltaBlock = inlineCostDelta(fnNode, namesToAlias, InliningMode.BLOCK);
    return doesLowerCost(fnNode, overallCallCost, referencesUsingDirectInlining, costDeltaDirect, referencesUsingBlockInlining, costDeltaBlock, isRemovable);
}","public void test099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, false, false, false);
    JSModule jSModule0 = new JSModule("""");
    Node node0 = Node.newString("""");
    HashSet<FunctionInjector.Reference> hashSet0 = new HashSet<FunctionInjector.Reference>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    FunctionInjector.InliningMode functionInjector_InliningMode0 = FunctionInjector.InliningMode.BLOCK;
    FunctionInjector.Reference functionInjector_Reference0 = new FunctionInjector.Reference(node0, jSModule0, functionInjector_InliningMode0);
    ImmutableList<FunctionInjector.Reference> immutableList0 = ImmutableList.of(functionInjector_Reference0, functionInjector_Reference0);
    hashSet0.addAll(immutableList0);
    // Undeclared exception!
    try {
        functionInjector0.inliningLowersCost(jSModule0, node0, hashSet0, compilerOptions0.aliasableStrings, true, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Determine if inlining the function is likely to reduce the code size.
 * @param namesToAlias
 */"
"boolean inliningLowersCost(JSModule fnModule, Node fnNode, Collection<? extends Reference> refs, Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {
    int referenceCount = refs.size();
    if (referenceCount == 0) {
        return true;
    }
    int referencesUsingBlockInlining = 0;
    boolean checkModules = isRemovable && fnModule != null;
    JSModuleGraph moduleGraph = compiler.getModuleGraph();
    for (Reference ref : refs) {
        if (ref.mode == InliningMode.BLOCK) {
            referencesUsingBlockInlining++;
        }
        // Check if any of the references cross the module boundaries.
        if (checkModules && ref.module != null) {
            if (ref.module != fnModule && !moduleGraph.dependsOn(ref.module, fnModule)) {
                // Calculate the cost as if the function were non-removable,
                // if it still lowers the cost inline it.
                isRemovable = false;
                // no need to check additional modules.
                checkModules = false;
            }
        }
    }
    int referencesUsingDirectInlining = referenceCount - referencesUsingBlockInlining;
    // Don't bother calculating the cost of function for simple functions where
    // possible.
    // However, when inlining a complex function, even a single reference may be
    // larger than the original function if there are many returns (resulting
    // in additional assignments) or many parameters that need to be aliased
    // so use the cost estimating.
    if (referenceCount == 1 && isRemovable && referencesUsingDirectInlining == 1) {
        return true;
    }
    int callCost = estimateCallCost(fnNode, referencesThis);
    int overallCallCost = callCost * referenceCount;
    int costDeltaDirect = inlineCostDelta(fnNode, namesToAlias, InliningMode.DIRECT);
    int costDeltaBlock = inlineCostDelta(fnNode, namesToAlias, InliningMode.BLOCK);
    return doesLowerCost(fnNode, overallCallCost, referencesUsingDirectInlining, costDeltaDirect, referencesUsingBlockInlining, costDeltaBlock, isRemovable);
}","public void test1010() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, true, true, true);
    JSModule jSModule0 = new JSModule(""3h`"");
    Node node0 = Node.newString(""3h`"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    FunctionInjector.InliningMode functionInjector_InliningMode0 = FunctionInjector.InliningMode.DIRECT;
    FunctionInjector.Reference functionInjector_Reference0 = new FunctionInjector.Reference(node0, (JSModule) null, functionInjector_InliningMode0);
    ImmutableList<FunctionInjector.Reference> immutableList0 = ImmutableList.of(functionInjector_Reference0, functionInjector_Reference0, functionInjector_Reference0, functionInjector_Reference0, functionInjector_Reference0);
    // Undeclared exception!
    try {
        functionInjector0.inliningLowersCost(jSModule0, node0, immutableList0, compilerOptions0.stripNameSuffixes, true, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Determine if inlining the function is likely to reduce the code size.
 * @param namesToAlias
 */"
"boolean inliningLowersCost(JSModule fnModule, Node fnNode, Collection<? extends Reference> refs, Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {
    int referenceCount = refs.size();
    if (referenceCount == 0) {
        return true;
    }
    int referencesUsingBlockInlining = 0;
    boolean checkModules = isRemovable && fnModule != null;
    JSModuleGraph moduleGraph = compiler.getModuleGraph();
    for (Reference ref : refs) {
        if (ref.mode == InliningMode.BLOCK) {
            referencesUsingBlockInlining++;
        }
        // Check if any of the references cross the module boundaries.
        if (checkModules && ref.module != null) {
            if (ref.module != fnModule && !moduleGraph.dependsOn(ref.module, fnModule)) {
                // Calculate the cost as if the function were non-removable,
                // if it still lowers the cost inline it.
                isRemovable = false;
                // no need to check additional modules.
                checkModules = false;
            }
        }
    }
    int referencesUsingDirectInlining = referenceCount - referencesUsingBlockInlining;
    // Don't bother calculating the cost of function for simple functions where
    // possible.
    // However, when inlining a complex function, even a single reference may be
    // larger than the original function if there are many returns (resulting
    // in additional assignments) or many parameters that need to be aliased
    // so use the cost estimating.
    if (referenceCount == 1 && isRemovable && referencesUsingDirectInlining == 1) {
        return true;
    }
    int callCost = estimateCallCost(fnNode, referencesThis);
    int overallCallCost = callCost * referenceCount;
    int costDeltaDirect = inlineCostDelta(fnNode, namesToAlias, InliningMode.DIRECT);
    int costDeltaBlock = inlineCostDelta(fnNode, namesToAlias, InliningMode.BLOCK);
    return doesLowerCost(fnNode, overallCallCost, referencesUsingDirectInlining, costDeltaDirect, referencesUsingBlockInlining, costDeltaBlock, isRemovable);
}","public void test1111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, false, false, false);
    JSModule jSModule0 = new JSModule("""");
    Node node0 = Node.newString("""");
    HashSet<FunctionInjector.Reference> hashSet0 = new HashSet<FunctionInjector.Reference>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    FunctionInjector.InliningMode functionInjector_InliningMode0 = FunctionInjector.InliningMode.BLOCK;
    JSModule jSModule1 = new JSModule("""");
    FunctionInjector.Reference functionInjector_Reference0 = new FunctionInjector.Reference(node0, jSModule1, functionInjector_InliningMode0);
    ImmutableList<FunctionInjector.Reference> immutableList0 = ImmutableList.of(functionInjector_Reference0, functionInjector_Reference0);
    hashSet0.addAll(immutableList0);
    // Undeclared exception!
    try {
        functionInjector0.inliningLowersCost(jSModule0, node0, hashSet0, compilerOptions0.aliasableStrings, true, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.FunctionInjector"", e);
    }
}","/**
 * Determine if inlining the function is likely to reduce the code size.
 * @param namesToAlias
 */"
"public void setKnownConstants(Set<String> knownConstants) {
    // This is only expected to be set once. The same set should be used
    // when evaluating call-sites and inlining calls.
    Preconditions.checkState(this.knownConstants.isEmpty());
    this.knownConstants = knownConstants;
}","public void test1212() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    FunctionInjector functionInjector0 = new FunctionInjector(compiler0, supplier0, true, true, true);
    HashSet<String> hashSet0 = new HashSet<String>();
    functionInjector0.setKnownConstants(hashSet0);
    hashSet0.add(""?x5F"");
    // Undeclared exception!
    try {
        functionInjector0.setKnownConstants(hashSet0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Store the names of known constants to be used when classifying call-sites
 * in expressions.
 */"
