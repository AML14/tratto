focal_method,test_prefix,docstring
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test000() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(47);
    node0.setType(85);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(2, Node.FLAG_THIS_UNMODIFIED);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test011() throws Throwable {
    Node node0 = Node.newString(4, ""miss&ng goog.getCssName around literal ''{0}''"");
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(49, Node.DIRECT_EVAL);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test022() throws Throwable {
    Node node0 = new Node(43, 43, 43);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test033() throws Throwable {
    Node node0 = new Node(44);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test044() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node0 = Node.newNumber(0.0);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(39, Node.EMPTY_BLOCK);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isRegExp() {
    return this.getType() == Token.REGEXP;
}","public void test055() throws Throwable {
    Node node0 = new Node(30);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Compiler compiler0 = new Compiler();
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isRegExp());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test066() throws Throwable {
    Node node0 = new Node(37);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Compiler compiler0 = new Compiler();
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test077() throws Throwable {
    Node node0 = new Node(37);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    node0.addChildToFront(node0);
    Compiler compiler0 = new Compiler();
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test088() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node0 = new Node(47);
    node0.setType(85);
    Node node1 = new Node(29, node0, node0, node0, node0, 40, 30);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node2.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test089() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node0 = new Node(47);
    node0.setType(85);
    Node node1 = new Node(29, node0, node0, node0, node0, 40, 30);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertNotNull(node2);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isTypeOf() {
    return this.getType() == Token.TYPEOF;
}","public void test0910() throws Throwable {
    Node node0 = new Node(38, 38, 38);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Compiler compiler0 = new Compiler();
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isTypeOf());
}",""
"public boolean isCall() {
    return this.getType() == Token.CALL;
}","public void test1011() throws Throwable {
    Node node0 = new Node(37, 37, 37);
    Node node1 = new Node(4, node0, node0, node0, node0, 8, 15);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertFalse(node2.isCall());
}",""
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test1112() throws Throwable {
    Node node0 = new Node(43, 43, 43);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(43, node1.getCharno());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1213() throws Throwable {
    Node node0 = new Node(63);
    node0.addChildToFront(node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(4, Node.FLAG_ARGUMENTS_UNMODIFIED);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.RETURN:
            return tryReduceReturn(node);
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1314() throws Throwable {
    Node node0 = new Node(63);
    Node node1 = Node.newString("""");
    node0.addChildToFront(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(42, Node.SIDE_EFFECT_FLAGS);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isAdd() {
    return this.getType() == Token.ADD;
}","public void test1415() throws Throwable {
    Node node0 = new Node(63, 63, 63);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isAdd());
}","/**
 * AST type check methods **
 */"
"static boolean containsUnicodeEscape(String s) {
    String esc = REGEXP_ESCAPER.regexpEscape(s);
    for (int i = -1; (i = esc.indexOf(""\\u"", i + 1)) >= 0; ) {
        int nSlashes = 0;
        while (i - nSlashes > 0 && '\\' == esc.charAt(i - nSlashes - 1)) {
            ++nSlashes;
        }
        // if there are an even number of slashes before the \ u then it is a
        // Unicode literal.
        if (0 == (nSlashes & 1)) {
            return true;
        }
    }
    return false;
}","public void test1516() throws Throwable {
    boolean boolean0 = PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(""s1}hD8y_MOh}oR[|,"");
    assertFalse(boolean0);
}","/**
 * true if the JavaScript string would contain a Unicode escape when written
 * out as the body of a regular expression literal.
 */"
"static boolean containsUnicodeEscape(String s) {
    String esc = REGEXP_ESCAPER.regexpEscape(s);
    for (int i = -1; (i = esc.indexOf(""\\u"", i + 1)) >= 0; ) {
        int nSlashes = 0;
        while (i - nSlashes > 0 && '\\' == esc.charAt(i - nSlashes - 1)) {
            ++nSlashes;
        }
        // if there are an even number of slashes before the \ u then it is a
        // Unicode literal.
        if (0 == (nSlashes & 1)) {
            return true;
        }
    }
    return false;
}","public void test1617() throws Throwable {
    boolean boolean0 = PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(""tT;(< ,vN9~{TwrG"");
    assertTrue(boolean0);
}","/**
 * true if the JavaScript string would contain a Unicode escape when written
 * out as the body of a regular expression literal.
 */"
