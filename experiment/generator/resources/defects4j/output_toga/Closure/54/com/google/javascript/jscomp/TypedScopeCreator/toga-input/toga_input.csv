focal_method,test_prefix,docstring
"public boolean isLocal() {
    return !isGlobal();
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""p$>b"", ""p$>b"");
    Node node1 = new Node(37, node0, node0, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node1, (Scope) null);
    assertFalse(scope0.isLocal());
}","/**
 * Returns whether this is a local scope (i.e. not the global scope).
 */"
"@Override
public Scope createScope(Node root, Scope parent) {
    // Constructing the global scope is very different than constructing
    // inner scopes, because only global scopes can contain named classes that
    // show up in the type registry.
    Scope newScope = null;
    AbstractScopeBuilder scopeBuilder = null;
    if (parent == null) {
        // Find all the classes in the global scope.
        newScope = createInitialScope(root);
        GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
        scopeBuilder = globalScopeBuilder;
        NodeTraversal.traverse(compiler, root, scopeBuilder);
    } else {
        newScope = new Scope(parent, root);
        LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
        scopeBuilder = localScopeBuilder;
        localScopeBuilder.build();
    }
    scopeBuilder.resolveStubDeclarations();
    scopeBuilder.resolveTypes();
    // Gather the properties in each function that we found in the
    // global scope, if that function has a @this type that we can
    // build properties on.
    for (Node functionNode : scopeBuilder.nonExternFunctions) {
        JSType type = functionNode.getJSType();
        if (type != null && type.isFunctionType()) {
            FunctionType fnType = type.toMaybeFunctionType();
            ObjectType fnThisType = fnType.getTypeOfThis();
            if (!fnThisType.isUnknownType()) {
                NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType));
            }
        }
    }
    if (parent == null) {
        codingConvention.defineDelegateProxyPrototypeProperties(typeRegistry, newScope, delegateProxyPrototypes, delegateCallingConventions);
    }
    return newScope;
}","public void test011() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""Y"");
    Node node0 = new Node(120);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    // Undeclared exception!
    try {
        typedScopeCreator0.createScope(node0, (Scope) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates a scope with all types declared. Declares newly discovered types
 * and type properties in the type registry.
 */"
"public int getVarCount() {
    return vars.size();
}","public void test022() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""mg.unde.wit"");
    Node node1 = new Node(64);
    Node node2 = new Node(4, node0, node0, node1);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node2, (Scope) null);
    assertEquals(33, scope0.getVarCount());
}","/**
 * Returns number of variables in this scope
 */"
"void patchGlobalScope(Scope globalScope, Node scriptRoot) {
    // Preconditions: This is supposed to be called only on (named) SCRIPT nodes
    // and a global typed scope should have been generated already.
    Preconditions.checkState(scriptRoot.getType() == Token.SCRIPT);
    Preconditions.checkNotNull(globalScope);
    Preconditions.checkState(globalScope.isGlobal());
    // TODO(bashir): Variable declaration is not the only side effect of last
    // global scope generation but here we only wipe that part off!
    // Remove all variables that were previously declared in this scripts.
    String scriptName = NodeUtil.getSourceName(scriptRoot);
    Preconditions.checkNotNull(scriptName);
    // First find all vars to remove then remove them because of iterator!
    Iterator<Var> varIter = globalScope.getVars();
    List<Var> varsToRemove = Lists.newArrayList();
    while (varIter.hasNext()) {
        Var oldVar = varIter.next();
        if (scriptName.equals(oldVar.getInputName())) {
            varsToRemove.add(oldVar);
        }
    }
    for (Var var : varsToRemove) {
        globalScope.undeclare(var);
    }
    // Now re-traverse the given script.
    GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(globalScope);
    NodeTraversal.traverse(compiler, scriptRoot, scopeBuilder);
}","public void test033() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""icj=OiO/Zrzc&-~UIaz"");
    Node node1 = new Node(1, node0, node0, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    // Undeclared exception!
    try {
        typedScopeCreator0.patchGlobalScope((Scope) null, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Patches a given global scope by removing variables previously declared in
 * a script and re-traversing a new version of that script.
 *
 * @param globalScope The global scope generated by {@code createScope}.
 * @param scriptRoot The script that is modified.
 */"
"public int getVarCount() {
    return vars.size();
}","public void test044() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""7c3hN"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    typedScopeCreator0.patchGlobalScope(scope0, node0);
    assertEquals(32, scope0.getVarCount());
}","/**
 * Returns number of variables in this scope
 */"
"public int getVarCount() {
    return vars.size();
}","public void test055() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""<non-file>"");
    Node node0 = compiler0.parse(jSSourceFile0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    typedScopeCreator0.patchGlobalScope(scope0, node0);
    assertEquals(0, scope0.getVarCount());
}","/**
 * Returns number of variables in this scope
 */"
"public int getVarCount() {
    return vars.size();
}","public void test066() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""pmag.unef=vt"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node0, (Scope) null);
    assertEquals(32, scope0.getVarCount());
}","/**
 * Returns number of variables in this scope
 */"
"@Override
public Scope createScope(Node root, Scope parent) {
    // Constructing the global scope is very different than constructing
    // inner scopes, because only global scopes can contain named classes that
    // show up in the type registry.
    Scope newScope = null;
    AbstractScopeBuilder scopeBuilder = null;
    if (parent == null) {
        // Find all the classes in the global scope.
        newScope = createInitialScope(root);
        GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
        scopeBuilder = globalScopeBuilder;
        NodeTraversal.traverse(compiler, root, scopeBuilder);
    } else {
        newScope = new Scope(parent, root);
        LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
        scopeBuilder = localScopeBuilder;
        localScopeBuilder.build();
    }
    scopeBuilder.resolveStubDeclarations();
    scopeBuilder.resolveTypes();
    // Gather the properties in each function that we found in the
    // global scope, if that function has a @this type that we can
    // build properties on.
    for (Node functionNode : scopeBuilder.nonExternFunctions) {
        JSType type = functionNode.getJSType();
        if (type != null && type.isFunctionType()) {
            FunctionType fnType = type.toMaybeFunctionType();
            ObjectType fnThisType = fnType.getTypeOfThis();
            if (!fnThisType.isUnknownType()) {
                NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType));
            }
        }
    }
    if (parent == null) {
        codingConvention.defineDelegateProxyPrototypeProperties(typeRegistry, newScope, delegateProxyPrototypes, delegateCallingConventions);
    }
    return newScope;
}","public void test077() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""1#zQ d'r~-&Z7jj^>1{"");
    Node node1 = new Node(105, node0, node0, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    // Undeclared exception!
    try {
        typedScopeCreator0.createScope(node1, scope0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates a scope with all types declared. Declares newly discovered types
 * and type properties in the type registry.
 */"
"public boolean isLocal() {
    return !isGlobal();
}","public void test088() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""icj=OiO/Zrzc&-~UIaz"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node0, (Scope) null);
    assertFalse(scope0.isLocal());
}","/**
 * Returns whether this is a local scope (i.e. not the global scope).
 */"
"public boolean isGlobal() {
    return parent == null;
}","public void test099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""p$GLbi["", ""p$GLbi["");
    Node node1 = new Node(41, node0, node0, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node1, (Scope) null);
    assertTrue(scope0.isGlobal());
}","/**
 * Returns whether this is the global scope.
 */"
"public boolean isGlobal() {
    return parent == null;
}","public void test1010() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("":hcku>@6J$%4lLm"");
    Node node1 = new Node(43, node0, node0, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node1, (Scope) null);
    assertTrue(scope0.isGlobal());
}","/**
 * Returns whether this is the global scope.
 */"
"public int getVarCount() {
    return vars.size();
}","public void test1111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" "");
    Node node1 = new Node(44, node0, node0, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node1, (Scope) null);
    assertEquals(32, scope0.getVarCount());
}","/**
 * Returns number of variables in this scope
 */"
"public int getVarCount() {
    return vars.size();
}","public void test1212() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("":hcku>@c<6J$%4VLm"");
    Node node1 = new Node(47, node0, node0, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node1, (Scope) null);
    assertEquals(32, scope0.getVarCount());
}","/**
 * Returns number of variables in this scope
 */"
"public int getVarCount() {
    return vars.size();
}","public void test1313() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.googA.comYn.io.Betreams"");
    Node node1 = new Node(69, node0, node0, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node1, (Scope) null);
    assertEquals(33, scope0.getVarCount());
}","/**
 * Returns number of variables in this scope
 */"
"public boolean isLocal() {
    return !isGlobal();
}","public void test1414() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""SUPPRESS_DOC"");
    Node node1 = new Node(122, node0, node0, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node1, (Scope) null);
    assertFalse(scope0.isLocal());
}","/**
 * Returns whether this is a local scope (i.e. not the global scope).
 */"
"@Override
public Scope createScope(Node root, Scope parent) {
    // Constructing the global scope is very different than constructing
    // inner scopes, because only global scopes can contain named classes that
    // show up in the type registry.
    Scope newScope = null;
    AbstractScopeBuilder scopeBuilder = null;
    if (parent == null) {
        // Find all the classes in the global scope.
        newScope = createInitialScope(root);
        GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
        scopeBuilder = globalScopeBuilder;
        NodeTraversal.traverse(compiler, root, scopeBuilder);
    } else {
        newScope = new Scope(parent, root);
        LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
        scopeBuilder = localScopeBuilder;
        localScopeBuilder.build();
    }
    scopeBuilder.resolveStubDeclarations();
    scopeBuilder.resolveTypes();
    // Gather the properties in each function that we found in the
    // global scope, if that function has a @this type that we can
    // build properties on.
    for (Node functionNode : scopeBuilder.nonExternFunctions) {
        JSType type = functionNode.getJSType();
        if (type != null && type.isFunctionType()) {
            FunctionType fnType = type.toMaybeFunctionType();
            ObjectType fnThisType = fnType.getTypeOfThis();
            if (!fnThisType.isUnknownType()) {
                NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType));
            }
        }
    }
    if (parent == null) {
        codingConvention.defineDelegateProxyPrototypeProperties(typeRegistry, newScope, delegateProxyPrototypes, delegateCallingConventions);
    }
    return newScope;
}","public void test1515() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""5&r"", ""5&r"");
    node0.addSuppression(""5&r"");
    Node node1 = new Node(118, node0, node0, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    // Undeclared exception!
    try {
        typedScopeCreator0.createScope(node1, (Scope) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //   Node(VAR): 5&r:-1:-1
        // [source unknown]
        //   Parent: NULL
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates a scope with all types declared. Declares newly discovered types
 * and type properties in the type registry.
 */"
"@Override
public Scope createScope(Node root, Scope parent) {
    // Constructing the global scope is very different than constructing
    // inner scopes, because only global scopes can contain named classes that
    // show up in the type registry.
    Scope newScope = null;
    AbstractScopeBuilder scopeBuilder = null;
    if (parent == null) {
        // Find all the classes in the global scope.
        newScope = createInitialScope(root);
        GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
        scopeBuilder = globalScopeBuilder;
        NodeTraversal.traverse(compiler, root, scopeBuilder);
    } else {
        newScope = new Scope(parent, root);
        LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
        scopeBuilder = localScopeBuilder;
        localScopeBuilder.build();
    }
    scopeBuilder.resolveStubDeclarations();
    scopeBuilder.resolveTypes();
    // Gather the properties in each function that we found in the
    // global scope, if that function has a @this type that we can
    // build properties on.
    for (Node functionNode : scopeBuilder.nonExternFunctions) {
        JSType type = functionNode.getJSType();
        if (type != null && type.isFunctionType()) {
            FunctionType fnType = type.toMaybeFunctionType();
            ObjectType fnThisType = fnType.getTypeOfThis();
            if (!fnThisType.isUnknownType()) {
                NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType));
            }
        }
    }
    if (parent == null) {
        codingConvention.defineDelegateProxyPrototypeProperties(typeRegistry, newScope, delegateProxyPrototypes, delegateCallingConventions);
    }
    return newScope;
}","public void test1616() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""lI@NSM"");
    Node node1 = compiler0.parseSyntheticCode(""lI@NSM"");
    Node node2 = new Node(118, node0, node0, node1);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    // Undeclared exception!
    try {
        typedScopeCreator0.createScope(node2, (Scope) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //   Node(VAR):  [synthetic:1] :-1:-1
        // [source unknown]
        //   Parent: NULL
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates a scope with all types declared. Declares newly discovered types
 * and type properties in the type registry.
 */"
"@Override
public Scope createScope(Node root, Scope parent) {
    // Constructing the global scope is very different than constructing
    // inner scopes, because only global scopes can contain named classes that
    // show up in the type registry.
    Scope newScope = null;
    AbstractScopeBuilder scopeBuilder = null;
    if (parent == null) {
        // Find all the classes in the global scope.
        newScope = createInitialScope(root);
        GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
        scopeBuilder = globalScopeBuilder;
        NodeTraversal.traverse(compiler, root, scopeBuilder);
    } else {
        newScope = new Scope(parent, root);
        LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
        scopeBuilder = localScopeBuilder;
        localScopeBuilder.build();
    }
    scopeBuilder.resolveStubDeclarations();
    scopeBuilder.resolveTypes();
    // Gather the properties in each function that we found in the
    // global scope, if that function has a @this type that we can
    // build properties on.
    for (Node functionNode : scopeBuilder.nonExternFunctions) {
        JSType type = functionNode.getJSType();
        if (type != null && type.isFunctionType()) {
            FunctionType fnType = type.toMaybeFunctionType();
            ObjectType fnThisType = fnType.getTypeOfThis();
            if (!fnThisType.isUnknownType()) {
                NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType));
            }
        }
    }
    if (parent == null) {
        codingConvention.defineDelegateProxyPrototypeProperties(typeRegistry, newScope, delegateProxyPrototypes, delegateCallingConventions);
    }
    return newScope;
}","public void test1717() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""lI@NSM"");
    Node node1 = compiler0.parseSyntheticCode(""lI@NSM"");
    Node node2 = new Node(118, node0, node0, node1);
    node2.addSuppression(""lI@NSM"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    // Undeclared exception!
    try {
        typedScopeCreator0.createScope(node2, (Scope) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //   Node(VAR):  [synthetic:1] :-1:-1
        // [source unknown]
        //   Parent: NULL
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates a scope with all types declared. Declares newly discovered types
 * and type properties in the type registry.
 */"
"@Override
public Scope createScope(Node root, Scope parent) {
    // Constructing the global scope is very different than constructing
    // inner scopes, because only global scopes can contain named classes that
    // show up in the type registry.
    Scope newScope = null;
    AbstractScopeBuilder scopeBuilder = null;
    if (parent == null) {
        // Find all the classes in the global scope.
        newScope = createInitialScope(root);
        GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
        scopeBuilder = globalScopeBuilder;
        NodeTraversal.traverse(compiler, root, scopeBuilder);
    } else {
        newScope = new Scope(parent, root);
        LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
        scopeBuilder = localScopeBuilder;
        localScopeBuilder.build();
    }
    scopeBuilder.resolveStubDeclarations();
    scopeBuilder.resolveTypes();
    // Gather the properties in each function that we found in the
    // global scope, if that function has a @this type that we can
    // build properties on.
    for (Node functionNode : scopeBuilder.nonExternFunctions) {
        JSType type = functionNode.getJSType();
        if (type != null && type.isFunctionType()) {
            FunctionType fnType = type.toMaybeFunctionType();
            ObjectType fnThisType = fnType.getTypeOfThis();
            if (!fnThisType.isUnknownType()) {
                NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType));
            }
        }
    }
    if (parent == null) {
        codingConvention.defineDelegateProxyPrototypeProperties(typeRegistry, newScope, delegateProxyPrototypes, delegateCallingConventions);
    }
    return newScope;
}","public void test1818() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""5&r"", ""5&r"");
    node0.addSuppression(""5&r"");
    Node node1 = new Node(118, node0, node0, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    node1.clonePropsFrom(node0);
    // Undeclared exception!
    try {
        typedScopeCreator0.createScope(node1, (Scope) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //   Node(VAR): 5&r:-1:-1
        // [source unknown]
        //   Parent: NULL
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates a scope with all types declared. Declares newly discovered types
 * and type properties in the type registry.
 */"
"public int getVarCount() {
    return vars.size();
}","public void test1919() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorNode"");
    Node node0 = compiler0.parseSyntheticCode(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorNode"", ""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorNode"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node0, (Scope) null);
    assertEquals(33, scope0.getVarCount());
}","/**
 * Returns number of variables in this scope
 */"
"@Override
public Scope createScope(Node root, Scope parent) {
    // Constructing the global scope is very different than constructing
    // inner scopes, because only global scopes can contain named classes that
    // show up in the type registry.
    Scope newScope = null;
    AbstractScopeBuilder scopeBuilder = null;
    if (parent == null) {
        // Find all the classes in the global scope.
        newScope = createInitialScope(root);
        GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
        scopeBuilder = globalScopeBuilder;
        NodeTraversal.traverse(compiler, root, scopeBuilder);
    } else {
        newScope = new Scope(parent, root);
        LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
        scopeBuilder = localScopeBuilder;
        localScopeBuilder.build();
    }
    scopeBuilder.resolveStubDeclarations();
    scopeBuilder.resolveTypes();
    // Gather the properties in each function that we found in the
    // global scope, if that function has a @this type that we can
    // build properties on.
    for (Node functionNode : scopeBuilder.nonExternFunctions) {
        JSType type = functionNode.getJSType();
        if (type != null && type.isFunctionType()) {
            FunctionType fnType = type.toMaybeFunctionType();
            ObjectType fnThisType = fnType.getTypeOfThis();
            if (!fnThisType.isUnknownType()) {
                NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType));
            }
        }
    }
    if (parent == null) {
        codingConvention.defineDelegateProxyPrototypeProperties(typeRegistry, newScope, delegateProxyPrototypes, delegateCallingConventions);
    }
    return newScope;
}","public void test2020() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""com.google.common.io.ByteStreams"", ""com.google.common.io.ByteStreams"");
    Node node0 = compiler0.parse(jSSourceFile0);
    LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
    linkedList0.add(jSSourceFile0);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.init((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
    // Undeclared exception!
    try {
        typedScopeCreator0.createScope(node0, (Scope) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypedScopeCreator"", e);
    }
}","/**
 * Creates a scope with all types declared. Declares newly discovered types
 * and type properties in the type registry.
 */"
"public int getVarCount() {
    return vars.size();
}","public void test2121() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBulder$CollectProperti;s"");
    Node node1 = compiler0.parseTestCode(""com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBulder$CollectProperti;s"");
    Node node2 = new Node(104, node0, node0, node1);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createScope(node2, (Scope) null);
    assertEquals(33, scope0.getVarCount());
}","/**
 * Returns number of variables in this scope
 */"
"@Override
public Scope createScope(Node root, Scope parent) {
    // Constructing the global scope is very different than constructing
    // inner scopes, because only global scopes can contain named classes that
    // show up in the type registry.
    Scope newScope = null;
    AbstractScopeBuilder scopeBuilder = null;
    if (parent == null) {
        // Find all the classes in the global scope.
        newScope = createInitialScope(root);
        GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
        scopeBuilder = globalScopeBuilder;
        NodeTraversal.traverse(compiler, root, scopeBuilder);
    } else {
        newScope = new Scope(parent, root);
        LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
        scopeBuilder = localScopeBuilder;
        localScopeBuilder.build();
    }
    scopeBuilder.resolveStubDeclarations();
    scopeBuilder.resolveTypes();
    // Gather the properties in each function that we found in the
    // global scope, if that function has a @this type that we can
    // build properties on.
    for (Node functionNode : scopeBuilder.nonExternFunctions) {
        JSType type = functionNode.getJSType();
        if (type != null && type.isFunctionType()) {
            FunctionType fnType = type.toMaybeFunctionType();
            ObjectType fnThisType = fnType.getTypeOfThis();
            if (!fnThisType.isUnknownType()) {
                NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType));
            }
        }
    }
    if (parent == null) {
        codingConvention.defineDelegateProxyPrototypeProperties(typeRegistry, newScope, delegateProxyPrototypes, delegateCallingConventions);
    }
    return newScope;
}","public void test2222() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences"");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    Node node1 = jSTypeRegistry0.createParameters((List<JSType>) linkedList0);
    Node node2 = new Node(4, node1, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    // Undeclared exception!
    try {
        typedScopeCreator0.createScope(node2, scope0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Creates a scope with all types declared. Declares newly discovered types
 * and type properties in the type registry.
 */"
"public int getVarCount() {
    return vars.size();
}","public void test2323() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences"");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    Node node1 = jSTypeRegistry0.createParameters((List<JSType>) linkedList0);
    Node node2 = new Node(4, node1, node0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    Node node3 = new Node(14, node2, 2, 4095);
    Scope scope1 = typedScopeCreator0.createScope(node3, scope0);
    assertEquals(1, scope1.getVarCount());
}","/**
 * Returns number of variables in this scope
 */"
