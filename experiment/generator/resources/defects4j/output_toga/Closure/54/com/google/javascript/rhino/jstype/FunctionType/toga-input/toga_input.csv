focal_method,test_prefix,docstring
"@Override
public <T> T visit(Visitor<T> visitor) {
    return visitor.caseFunctionType(this);
}","public void test000() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.RANGE_ERROR_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, objectType0, objectType0);
    FunctionType functionType0 = indexedType0.getConstructor();
    // Undeclared exception!
    try {
        functionType0.visit((Visitor<EnumType>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.FunctionType"", e);
    }
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test011() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewThisType(noResolvedType0, noResolvedType0);
    functionType0.toString();
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test012() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithNewThisType(noResolvedType0, noResolvedType0);
    functionType0.toString();
    assertFalse(noResolvedType0.isInterface());
}",""
"public boolean hasEqualCallType(FunctionType otherType) {
    return this.call.isEquivalentTo(otherType.call);
}","public void test023() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    NoType noType0 = (NoType) voidType0.restrictByNotNullOrUndefined();
    // Undeclared exception!
    try {
        noType0.hasEqualCallType((FunctionType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.FunctionType"", e);
    }
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test034() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    noType0.isReturnTypeInferred();
    assertFalse(noType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test045() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.isInstanceType();
    assertFalse(noResolvedType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test056() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = noType0.canBeCalled();
    assertFalse(noType0.isInterface());
}",""
"@Override
public boolean canBeCalled() {
    return true;
}","public void test057() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    boolean boolean0 = noType0.canBeCalled();
    assertTrue(boolean0);
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test068() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""u8LcDMI'F"", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    assertTrue(functionType0.hasCachedValues());
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test069() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""u8LcDMI'F"", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType1.isSubtype(functionType0);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test0610() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""u8LcDMI'F"", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType1.isSubtype(functionType0);
    assertFalse(functionType1.equals((Object) functionType0));
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtype(this, that)) {
        return true;
    }
    if (that.isFunctionType()) {
        FunctionType other = that.toMaybeFunctionType();
        if (other.isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        boolean treatThisTypesAsCovariant = // If either one of these is a ctor, skip 'this' checking.
        this.isConstructor() || other.isConstructor() || // An interface 'this'-type is non-restrictive.
        // In practical terms, if C implements I, and I has a method m,
        // then any m doesn't necessarily have to C#m's 'this'
        // type doesn't need to match I.
        (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || // If one of the 'this' types is covariant of the other,
        // then we'll treat them as covariant (see comment above).
        other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);
        return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test0611() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""u8LcDMI'F"", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType1.isSubtype(functionType0);
    assertTrue(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test0612() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""u8LcDMI'F"", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) linkedList0);
    boolean boolean0 = functionType1.isSubtype(functionType0);
    assertTrue(functionType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test0713() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.getExtendedInterfacesCount();
    assertFalse(noResolvedType0.isInterface());
}",""
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test0814() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    Node node0 = Node.newNumber((double) 0);
    noResolvedType0.setSource(node0);
    assertFalse(noResolvedType0.isInterface());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test0915() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) voidType0, jSTypeArray0);
    functionType0.getLeastSupertype(functionType0);
    assertFalse(functionType0.hasCachedValues());
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test0916() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) voidType0, jSTypeArray0);
    functionType0.getLeastSupertype(functionType0);
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public List<FunctionType> getSubTypes() {
    return subTypes;
}","public void test1017() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    List<FunctionType> list0 = noResolvedType0.getSubTypes();
    assertNull(list0);
}","/**
 * Returns a list of types that are subtypes of this type. This is only valid
 * for constructor functions, and may be null. This allows a downward
 * traversal of the subtype graph.
 */"
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test1118() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    Node node0 = Node.newString(105, ""E $ToxbTxzb 1OZiEZ{"");
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType(""Not declared as a type name"", node0, node0, (JSType) noResolvedType0);
    assertFalse(functionType0.isOrdinaryFunction());
}",""
"public FunctionType createConstructorType(String name, Node source, Node parameters, JSType returnType) {
    return new FunctionType(this, name, source, createArrowType(parameters, returnType), null, null, true, false);
}","public void test1219() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    Node node0 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) linkedList0);
    // Undeclared exception!
    try {
        jSTypeRegistry0.createConstructorType(""Not declared as a constructor"", node0, node0, (JSType) noResolvedType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates a constructor function type.
 * @param name the function's name or {@code null} to indicate that the
 *     function is anonymous.
 * @param source the node defining this function. Its type
 *     ({@link Node#getType()}) must be {@link Token#FUNCTION}.
 * @param parameters the function's parameters or {@code null}
 *     to indicate that the parameter types are unknown.
 * @param returnType the function's return type or {@code null} to indicate
 *     that the return type is unknown.
 */"
"public FunctionType createInterfaceType(String name, Node source) {
    return FunctionType.forInterface(this, name, source);
}","public void test1320() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = new Node(105);
    // Undeclared exception!
    try {
        jSTypeRegistry0.createInterfaceType((String) null, node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates an interface function type.
 * @param name the function's name
 * @param source the node defining this function. Its type
 *     ({@link Node#getType()}) must be {@link Token#FUNCTION}.
 */"
"static FunctionType forInterface(JSTypeRegistry registry, String name, Node source) {
    return new FunctionType(registry, name, source);
}","public void test1421() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newString(""Unknown class name"");
    // Undeclared exception!
    try {
        FunctionType.forInterface(jSTypeRegistry0, ""Not declared as a type name"", node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates an instance for a function that is an interface.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test1522() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public JSType getLeastSupertype(JSType that) {
    return supAndInfHelper(that, true);
}","public void test1523() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    JSType jSType0 = jSTypeRegistry0.createNullableType(functionType0);
    JSType jSType1 = functionType0.getLeastSupertype(jSType0);
    assertSame(jSType1, jSType0);
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test1524() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    JSType jSType0 = jSTypeRegistry0.createNullableType(functionType0);
    JSType jSType1 = functionType0.getLeastSupertype(jSType0);
    assertTrue(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test1525() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    JSType jSType0 = jSTypeRegistry0.createNullableType(functionType0);
    JSType jSType1 = functionType0.getLeastSupertype(jSType0);
    assertFalse(functionType0.isConstructor());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test1626() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType[] jSTypeArray0 = new JSType[0];
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) objectType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    JSType jSType0 = functionType0.getLeastSupertype(functionType1);
    assertTrue(functionType1.hasCachedValues());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test1627() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType[] jSTypeArray0 = new JSType[0];
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) objectType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    JSType jSType0 = functionType0.getLeastSupertype(functionType1);
    assertTrue(jSType0.equals((Object) functionType0));
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test1728() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    LinkedList<ObjectType> linkedList0 = new LinkedList<ObjectType>();
    linkedList0.add((ObjectType) noResolvedType0);
    noResolvedType0.setImplementedInterfaces(linkedList0);
    boolean boolean0 = noResolvedType0.hasImplementedInterfaces();
    assertFalse(noResolvedType0.hasCachedValues());
}",""
"public boolean hasImplementedInterfaces() {
    if (!implementedInterfaces.isEmpty()) {
        return true;
    }
    FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null;
    if (superCtor != null) {
        return superCtor.hasImplementedInterfaces();
    }
    return false;
}","public void test1729() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    LinkedList<ObjectType> linkedList0 = new LinkedList<ObjectType>();
    linkedList0.add((ObjectType) noResolvedType0);
    noResolvedType0.setImplementedInterfaces(linkedList0);
    boolean boolean0 = noResolvedType0.hasImplementedInterfaces();
    assertTrue(boolean0);
}",""
"public boolean hasImplementedInterfaces() {
    if (!implementedInterfaces.isEmpty()) {
        return true;
    }
    FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null;
    if (superCtor != null) {
        return superCtor.hasImplementedInterfaces();
    }
    return false;
}","public void test1830() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""com.google.common.base.Predicates$CompositionPredicate"", (Node) null);
    boolean boolean0 = functionType0.hasImplementedInterfaces();
    assertFalse(boolean0);
}",""
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test1831() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""com.google.common.base.Predicates$CompositionPredicate"", (Node) null);
    boolean boolean0 = functionType0.hasImplementedInterfaces();
    assertFalse(functionType0.isConstructor());
}",""
"public int getMinArguments() {
    // NOTE(nicksantos): There are some native functions that have optional
    // parameters before required parameters. This algorithm finds the position
    // of the last required parameter.
    int i = 0;
    int min = 0;
    for (Node n : getParameters()) {
        i++;
        if (!n.isOptionalArg() && !n.isVarArgs()) {
            min = i;
        }
    }
    return min;
}","public void test1932() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    int int0 = errorFunctionType0.getMinArguments();
    assertEquals(0, int0);
}","/**
 * Gets the minimum number of arguments that this function requires.
 */"
"public int getMinArguments() {
    // NOTE(nicksantos): There are some native functions that have optional
    // parameters before required parameters. This algorithm finds the position
    // of the last required parameter.
    int i = 0;
    int min = 0;
    for (Node n : getParameters()) {
        i++;
        if (!n.isOptionalArg() && !n.isVarArgs()) {
            min = i;
        }
    }
    return min;
}","public void test2033() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    int int0 = noResolvedType0.getMinArguments();
    assertEquals(0, int0);
}","/**
 * Gets the minimum number of arguments that this function requires.
 */"
"public int getMinArguments() {
    // NOTE(nicksantos): There are some native functions that have optional
    // parameters before required parameters. This algorithm finds the position
    // of the last required parameter.
    int i = 0;
    int min = 0;
    for (Node n : getParameters()) {
        i++;
        if (!n.isOptionalArg() && !n.isVarArgs()) {
            min = i;
        }
    }
    return min;
}","public void test2134() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    LinkedHashSet<JSType> linkedHashSet0 = new LinkedHashSet<JSType>();
    UnionType unionType0 = new UnionType(jSTypeRegistry0, linkedHashSet0);
    JSType[] jSTypeArray0 = new JSType[2];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) unionType0, false, jSTypeArray0);
    int int0 = functionType0.getMinArguments();
    assertEquals(2, int0);
}","/**
 * Gets the minimum number of arguments that this function requires.
 */"
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test2135() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    LinkedHashSet<JSType> linkedHashSet0 = new LinkedHashSet<JSType>();
    UnionType unionType0 = new UnionType(jSTypeRegistry0, linkedHashSet0);
    JSType[] jSTypeArray0 = new JSType[2];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) unionType0, false, jSTypeArray0);
    int int0 = functionType0.getMinArguments();
    assertTrue(functionType0.isOrdinaryFunction());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test2236() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "":c"");
    int int0 = errorFunctionType0.getMaxArguments();
    assertEquals(3, int0);
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test2337() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, (List<JSType>) linkedList0);
    int int0 = functionType0.getMaxArguments();
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test2338() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, (List<JSType>) linkedList0);
    int int0 = functionType0.getMaxArguments();
    assertEquals(0, int0);
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test2439() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    int int0 = noResolvedType0.getMaxArguments();
    assertEquals(Integer.MAX_VALUE, int0);
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public final boolean defineInferredProperty(String propertyName, JSType type, Node propertyNode) {
    if (hasProperty(propertyName)) {
        JSType originalType = getPropertyType(propertyName);
        type = originalType == null ? type : originalType.getLeastSupertype(type);
    }
    boolean result = defineProperty(propertyName, type, true, propertyNode);
    // All property definitions go through this method
    // or defineDeclaredProperty. Because the properties defined an an
    // object can affect subtyping, it's slightly more efficient
    // to register this after defining the property.
    registry.registerPropertyOnType(propertyName, this);
    return result;
}","public void test2540() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "":c"");
    Node node0 = new Node(0, 0, 0);
    ArrowType arrowType0 = new ArrowType(jSTypeRegistry0, node0, errorFunctionType0);
    boolean boolean0 = errorFunctionType0.defineInferredProperty(""prototype"", arrowType0, node0);
    assertFalse(boolean0);
}","/**
 * Defines a property whose type is inferred.
 * @param propertyName the property's name
 * @param type the type
 * @param propertyNode the node corresponding to the inferred definition of
 *        property that might later be accessed using {@code getPropertyNode}.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test2641() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.hasImplementedInterfaces();
    noResolvedType0.getOwnPropertyNames();
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"public boolean isNoType() {
    return false;
}","public void test2843() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Named type with empty name component"");
    noResolvedType0.setPrototypeBasedOn(templateType0);
    ObjectType objectType0 = noResolvedType0.getTopMostDefiningType(""Not declared as a type name"");
    assertFalse(objectType0.isNoType());
}",""
"@Override
public final boolean isFunctionPrototypeType() {
    return getOwnerFunction() != null;
}","public void test2944() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    functionType0.setPrototypeBasedOn(noResolvedType0);
    assertTrue(noResolvedType0.isFunctionPrototypeType());
}",""
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test2945() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    functionType0.setPrototypeBasedOn(noResolvedType0);
    functionType0.getTopMostDefiningType(""Not declared as a constructor"");
    assertFalse(functionType0.isConstructor());
}",""
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test3046() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, noResolvedType0, noResolvedType0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Named type with empty name component"", (Node) null);
    functionType0.setPrototypeBasedOn(indexedType0);
    assertFalse(functionType0.isConstructor());
}",""
"public boolean setPrototype(PrototypeObjectType prototype) {
    if (prototype == null) {
        return false;
    }
    // getInstanceType fails if the function is not a constructor
    if (isConstructor() && prototype == getInstanceType()) {
        return false;
    }
    boolean replacedPrototype = prototype != null;
    this.prototype = prototype;
    this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
    this.prototype.setOwnerFunction(this);
    // Disassociating the old prototype makes this easier to debug--
    // we don't have to worry about two prototypes running around.
    if (isConstructor() || isInterface()) {
        FunctionType superClass = getSuperClassConstructor();
        if (superClass != null) {
            superClass.addSubType(this);
        }
        if (isInterface()) {
            for (ObjectType interfaceType : getExtendedInterfaces()) {
                if (interfaceType.getConstructor() != null) {
                    interfaceType.getConstructor().addSubType(this);
                }
            }
        }
    }
    if (replacedPrototype) {
        clearCachedValues();
    }
    return true;
}","public void test3147() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    boolean boolean0 = noObjectType0.setPrototype((PrototypeObjectType) null);
    assertFalse(boolean0);
}","/**
 * Sets the prototype.
 * @param prototype the prototype. If this value is {@code null} it will
 *        silently be discarded.
 */"
"public boolean setPrototype(PrototypeObjectType prototype) {
    if (prototype == null) {
        return false;
    }
    // getInstanceType fails if the function is not a constructor
    if (isConstructor() && prototype == getInstanceType()) {
        return false;
    }
    boolean replacedPrototype = prototype != null;
    this.prototype = prototype;
    this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
    this.prototype.setOwnerFunction(this);
    // Disassociating the old prototype makes this easier to debug--
    // we don't have to worry about two prototypes running around.
    if (isConstructor() || isInterface()) {
        FunctionType superClass = getSuperClassConstructor();
        if (superClass != null) {
            superClass.addSubType(this);
        }
        if (isInterface()) {
            for (ObjectType interfaceType : getExtendedInterfaces()) {
                if (interfaceType.getConstructor() != null) {
                    interfaceType.getConstructor().addSubType(this);
                }
            }
        }
    }
    if (replacedPrototype) {
        clearCachedValues();
    }
    return true;
}","public void test3248() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    boolean boolean0 = noResolvedType0.setPrototype(noResolvedType0);
    assertFalse(boolean0);
}","/**
 * Sets the prototype.
 * @param prototype the prototype. If this value is {@code null} it will
 *        silently be discarded.
 */"
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test3349() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GREATEST_FUNCTION_TYPE;
    FunctionType functionType0 = (FunctionType) jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    functionType0.getAllImplementedInterfaces();
    assertFalse(functionType0.isConstructor());
}",""
"public Iterable<ObjectType> getAllImplementedInterfaces() {
    // Store them in a linked hash set, so that the compile job is
    // deterministic.
    Set<ObjectType> interfaces = Sets.newLinkedHashSet();
    for (ObjectType type : getImplementedInterfaces()) {
        addRelatedInterfaces(type, interfaces);
    }
    return interfaces;
}","public void test3450() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    LinkedList<ObjectType> linkedList0 = new LinkedList<ObjectType>();
    linkedList0.add((ObjectType) noResolvedType0);
    noResolvedType0.setImplementedInterfaces(linkedList0);
    Iterable<ObjectType> iterable0 = noResolvedType0.getAllImplementedInterfaces();
    assertNotNull(iterable0);
}","/**
 * Returns all interfaces implemented by a class or its superclass and any
 * superclasses for any of those interfaces. If this is called before all
 * types are resolved, it may return an incomplete set.
 */"
"public Iterable<ObjectType> getAllExtendedInterfaces() {
    // Store them in a linked hash set, so that the compile job is
    // deterministic.
    Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet();
    for (ObjectType interfaceType : getExtendedInterfaces()) {
        addRelatedExtendedInterfaces(interfaceType, extendedInterfaces);
    }
    return extendedInterfaces;
}","public void test3551() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    Iterable<ObjectType> iterable0 = noResolvedType0.getAllExtendedInterfaces();
    assertNotNull(iterable0);
}","/**
 * Returns all extended interfaces declared by an interfaces or its super-
 * interfaces. If this is called before all types are resolved, it may return
 * an incomplete set.
 */"
"public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException {
    if (isInterface()) {
        this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces);
    } else {
        throw new UnsupportedOperationException();
    }
}","public void test3652() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    LinkedList<ObjectType> linkedList0 = new LinkedList<ObjectType>();
    try {
        noResolvedType0.setExtendedInterfaces(linkedList0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.FunctionType"", e);
    }
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test3753() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    LinkedList<ObjectType> linkedList0 = new LinkedList<ObjectType>();
    functionType0.setExtendedInterfaces(linkedList0);
    assertFalse(functionType0.isNoResolvedType());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test3854() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    errorFunctionType0.getPropertyType(""call"");
    errorFunctionType0.getPropertyType(""call"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test3955() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""0"");
    errorFunctionType0.getPropertyType(""apply"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4056() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    Node node0 = Node.newString(0, ""Not declared as a type name"", 1, 0);
    boolean boolean0 = errorFunctionType0.defineProperty(""prototype"", noResolvedType0, false, node0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) {
    if (""prototype"".equals(name)) {
        ObjectType objType = type.toObjectType();
        if (objType != null) {
            if (objType.isEquivalentTo(prototype)) {
                return true;
            }
            this.setPrototypeBasedOn(objType);
            return true;
        } else {
            return false;
        }
    }
    return super.defineProperty(name, type, inferred, propertyNode);
}","public void test4057() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    Node node0 = Node.newString(0, ""Not declared as a type name"", 1, 0);
    boolean boolean0 = errorFunctionType0.defineProperty(""prototype"", noResolvedType0, false, node0);
    assertTrue(boolean0);
}",""
"@Override
boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) {
    if (""prototype"".equals(name)) {
        ObjectType objType = type.toObjectType();
        if (objType != null) {
            if (objType.isEquivalentTo(prototype)) {
                return true;
            }
            this.setPrototypeBasedOn(objType);
            return true;
        } else {
            return false;
        }
    }
    return super.defineProperty(name, type, inferred, propertyNode);
}","public void test4158() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    errorFunctionType0.setPrototype(noResolvedType0);
    Node node0 = Node.newString(""prototype"", 0, 0);
    boolean boolean0 = errorFunctionType0.defineProperty(""prototype"", noResolvedType0, true, node0);
    assertTrue(boolean0);
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4259() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    NoResolvedType noResolvedType1 = (NoResolvedType) noResolvedType0.getLeastSupertype(noResolvedType0);
    assertFalse(noResolvedType1.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4360() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""@Q%JOg76D=8}"");
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) errorFunctionType0, jSTypeArray0);
    JSType jSType0 = functionType0.getLeastSupertype(errorFunctionType0);
    jSType0.getTypesUnderShallowEquality(functionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test4361() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""@Q%JOg76D=8}"");
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) errorFunctionType0, jSTypeArray0);
    JSType jSType0 = functionType0.getLeastSupertype(errorFunctionType0);
    jSType0.getTypesUnderShallowEquality(functionType0);
    assertFalse(errorFunctionType0.isOrdinaryFunction());
}",""
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test4462() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    JSType[] jSTypeArray0 = new JSType[1];
    jSTypeArray0[0] = (JSType) templateType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) templateType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noResolvedType0, jSTypeArray0);
    functionType1.getLeastSupertype(functionType0);
    assertFalse(functionType1.isConstructor());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4463() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    JSType[] jSTypeArray0 = new JSType[1];
    jSTypeArray0[0] = (JSType) templateType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) templateType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noResolvedType0, jSTypeArray0);
    functionType1.getLeastSupertype(functionType0);
    assertFalse(functionType1.hasCachedValues());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test4464() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    JSType[] jSTypeArray0 = new JSType[1];
    jSTypeArray0[0] = (JSType) templateType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) templateType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noResolvedType0, jSTypeArray0);
    functionType1.getLeastSupertype(functionType0);
    assertFalse(functionType1.equals((Object) functionType0));
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test4465() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""Unknown class name"");
    JSType[] jSTypeArray0 = new JSType[1];
    jSTypeArray0[0] = (JSType) templateType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) templateType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noResolvedType0, jSTypeArray0);
    functionType1.getLeastSupertype(functionType0);
    assertTrue(functionType1.isOrdinaryFunction());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4566() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[1];
    jSTypeArray0[0] = (JSType) noResolvedType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noResolvedType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) null, jSTypeArray0);
    functionType0.getLeastSupertype(functionType1);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4667() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSType[] jSTypeArray0 = new JSType[0];
    JSTypeNative jSTypeNative0 = JSTypeNative.GREATEST_FUNCTION_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) objectType0, jSTypeArray0);
    functionType0.getGreatestSubtype(objectType0);
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4768() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noResolvedType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    functionType0.getLeastSupertype(functionType1);
    assertTrue(noResolvedType0.hasCachedValues());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test4769() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noResolvedType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    functionType0.getLeastSupertype(functionType1);
    assertFalse(functionType1.equals((Object) functionType0));
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4870() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noResolvedType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    functionType1.getGreatestSubtype(functionType0);
    assertTrue(functionType1.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4971() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noResolvedType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    functionType1.getLeastSupertype(functionType0);
    assertTrue(functionType1.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test5072() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
    JSType[] jSTypeArray0 = new JSType[1];
    jSTypeArray0[0] = (JSType) voidType0;
    FunctionType functionType0 = jSTypeRegistry1.createFunctionTypeWithVarArgs((JSType) voidType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    functionType1.getLeastSupertype(functionType0);
    assertTrue(functionType1.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test5173() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""0sFaob88Vlyu="");
    ErrorFunctionType errorFunctionType1 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    JSType jSType0 = errorFunctionType1.getLeastSupertype(errorFunctionType0);
    errorFunctionType1.getTypesUnderShallowEquality(jSType0);
    assertTrue(errorFunctionType1.hasCachedValues());
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test5274() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, jSTypeArray0);
    functionType0.getLeastSupertype(jSType0);
    assertTrue(functionType0.isOrdinaryFunction());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test5275() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, jSTypeArray0);
    functionType0.getLeastSupertype(jSType0);
    assertFalse(functionType0.hasCachedValues());
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test5276() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, jSTypeArray0);
    functionType0.getLeastSupertype(jSType0);
    assertFalse(functionType0.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test5377() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    JSType jSType0 = errorFunctionType0.getPropertyType(""call"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public JSType getGreatestSubtype(JSType that) {
    if (that.isRecordType()) {
        // Record types have their own implementation of getGreatestSubtype.
        return that.getGreatestSubtype(this);
    }
    return getGreatestSubtype(this, that);
}","public void test5378() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    JSType jSType0 = errorFunctionType0.getPropertyType(""call"");
    JSType jSType1 = jSType0.getGreatestSubtype(errorFunctionType0);
    assertNotSame(jSType0, jSType1);
}","/**
 * Gets the greatest subtype of {@code this} and {@code that}.
 * The greatest subtype is the meet (&#8743;) or infimum of both types in the
 * type lattice.<p>
 * Examples
 * <ul>
 * <li>{@code Number &#8743; Any} = {@code Any}</li>
 * <li>{@code number &#8743; Object} = {@code Any}</li>
 * <li>{@code Number &#8743; Object} = {@code Number}</li>
 * </ul>
 * @return {@code this &#8744; that}
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test5479() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) voidType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry1.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    functionType1.getTypesUnderShallowEquality(functionType0);
    assertTrue(functionType1.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test5580() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) voidType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry1.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    functionType1.getLeastSupertype(functionType0);
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test5581() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) voidType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry1.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    functionType1.getLeastSupertype(functionType0);
    assertTrue(functionType1.hasCachedValues());
}",""
"public FunctionType getSuperClassConstructor() {
    Preconditions.checkArgument(isConstructor() || isInterface());
    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();
    if (maybeSuperInstanceType == null) {
        return null;
    }
    return maybeSuperInstanceType.getConstructor();
}","public void test5682() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    FunctionType functionType0 = (FunctionType) errorFunctionType0.getPropertyType(""call"");
    // Undeclared exception!
    try {
        functionType0.getSuperClassConstructor();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Given a constructor or an interface type, get its superclass constructor
 * or {@code null} if none exists.
 */"
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test5783() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    NoResolvedType noResolvedType1 = (NoResolvedType) FunctionType.getTopDefiningInterface(noResolvedType0, ""`KoSXS|b%n@0["");
    assertTrue(noResolvedType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"public ObjectType getTopMostDefiningType(String propertyName) {
    Preconditions.checkState(isConstructor() || isInterface());
    Preconditions.checkArgument(getPrototype().hasProperty(propertyName));
    FunctionType ctor = this;
    if (isInterface()) {
        return getTopDefiningInterface(this.getInstanceType(), propertyName);
    }
    ObjectType topInstanceType = ctor.getInstanceType();
    while (true) {
        topInstanceType = ctor.getInstanceType();
        ctor = ctor.getSuperClassConstructor();
        if (ctor == null || !ctor.getPrototype().hasProperty(propertyName)) {
            break;
        }
    }
    return topInstanceType;
}","public void test5884() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    // Undeclared exception!
    try {
        noResolvedType0.getTopMostDefiningType(""Not declared as a type name"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Given a constructor or an interface type and a property, finds the
 * top-most superclass that has the property defined (including this
 * constructor).
 */"
"public ObjectType getTopMostDefiningType(String propertyName) {
    Preconditions.checkState(isConstructor() || isInterface());
    Preconditions.checkArgument(getPrototype().hasProperty(propertyName));
    FunctionType ctor = this;
    if (isInterface()) {
        return getTopDefiningInterface(this.getInstanceType(), propertyName);
    }
    ObjectType topInstanceType = ctor.getInstanceType();
    while (true) {
        topInstanceType = ctor.getInstanceType();
        ctor = ctor.getSuperClassConstructor();
        if (ctor == null || !ctor.getPrototype().hasProperty(propertyName)) {
            break;
        }
    }
    return topInstanceType;
}","public void test5985() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noType0, jSTypeArray0);
    // Undeclared exception!
    try {
        functionType0.getTopMostDefiningType(""Unknown class name"");
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Given a constructor or an interface type and a property, finds the
 * top-most superclass that has the property defined (including this
 * constructor).
 */"
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtype(this, that)) {
        return true;
    }
    if (that.isFunctionType()) {
        FunctionType other = that.toMaybeFunctionType();
        if (other.isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        boolean treatThisTypesAsCovariant = // If either one of these is a ctor, skip 'this' checking.
        this.isConstructor() || other.isConstructor() || // An interface 'this'-type is non-restrictive.
        // In practical terms, if C implements I, and I has a method m,
        // then any m doesn't necessarily have to C#m's 'this'
        // type doesn't need to match I.
        (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || // If one of the 'this' types is covariant of the other,
        // then we'll treat them as covariant (see comment above).
        other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);
        return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test6086() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""g"");
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, errorFunctionType0, errorFunctionType0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""g"", (Node) null);
    boolean boolean0 = functionType0.isSubtype(indexedType0);
    assertFalse(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test6087() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""g"");
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, errorFunctionType0, errorFunctionType0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""g"", (Node) null);
    boolean boolean0 = functionType0.isSubtype(indexedType0);
    assertFalse(functionType0.isConstructor());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test6188() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a constructor"", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) noType0, (List<JSType>) linkedList0);
    functionType1.getLeastSupertype(functionType0);
    assertFalse(functionType1.hasCachedValues());
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test6189() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a constructor"", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) noType0, (List<JSType>) linkedList0);
    functionType1.getLeastSupertype(functionType0);
    assertTrue(functionType1.isOrdinaryFunction());
}",""
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test6190() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a constructor"", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) noType0, (List<JSType>) linkedList0);
    functionType1.getLeastSupertype(functionType0);
    assertFalse(functionType1.equals((Object) functionType0));
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test6191() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a constructor"", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) noType0, (List<JSType>) linkedList0);
    functionType1.getLeastSupertype(functionType0);
    assertFalse(noType0.hasCachedValues());
}",""
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test6192() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a constructor"", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) noType0, (List<JSType>) linkedList0);
    functionType1.getLeastSupertype(functionType0);
    assertFalse(functionType1.isConstructor());
}",""
"@Override
public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
}","public void test6193() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a constructor"", (Node) null);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) noType0, (List<JSType>) linkedList0);
    functionType1.getLeastSupertype(functionType0);
    assertFalse(functionType0.isOrdinaryFunction());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test6294() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    LinkedList<ObjectType> linkedList0 = new LinkedList<ObjectType>();
    LinkedList<JSType> linkedList1 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) voidType0, (List<JSType>) linkedList1);
    linkedList0.add((ObjectType) functionType0);
    functionType0.setImplementedInterfaces(linkedList0);
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Named type with empty name component"", voidType0);
    FunctionType functionType1 = (FunctionType) functionType0.resolveInternal(simpleErrorReporter0, enumType0);
    assertFalse(functionType1.hasCachedValues());
}",""
"@Override
public int hashCode() {
    return isInterface() ? getReferenceName().hashCode() : call.hashCode();
}","public void test6395() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    functionType0.hashCode();
}",""
"@Override
public String toString() {
    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return ""Function"";
    }
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();
    if (hasKnownTypeOfThis) {
        if (isConstructor()) {
            b.append(""new:"");
        } else {
            b.append(""this:"");
        }
        b.append(typeOfThis.toString());
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        if (p.isVarArgs()) {
            appendVarArgsString(b, p.getJSType());
        } else {
            b.append(p.getJSType().toString());
        }
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            if (p.isVarArgs()) {
                appendVarArgsString(b, p.getJSType());
            } else {
                b.append(p.getJSType().toString());
            }
            p = p.getNext();
        }
    }
    b.append(""): "");
    b.append(call.returnType);
    return b.toString();
}","public void test6496() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    String string0 = functionType0.toString();
    assertEquals(""Function"", string0);
}","/**
 * Informally, a function is represented by
 * {@code function (params): returnType} where the {@code params} is a comma
 * separated list of types, the first one being a special
 * {@code this:T} if the function expects a known type for {@code this}.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test6597() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "":c"");
    errorFunctionType0.toString();
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
}","public void test6698() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""Not declared as a constructor"", (Node) null);
    functionType0.toString();
    assertFalse(functionType0.isConstructor());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test6699() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""Not declared as a constructor"", (Node) null);
    functionType0.toString();
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test67100() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[1];
    jSTypeArray0[0] = (JSType) voidType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) voidType0, jSTypeArray0);
    functionType0.toString();
    assertFalse(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test68101() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[2];
    jSTypeArray0[0] = (JSType) voidType0;
    jSTypeArray0[1] = (JSType) voidType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) voidType0, jSTypeArray0);
    functionType0.toString();
    assertFalse(functionType0.hasCachedValues());
}",""
"public boolean isNullType() {
    return false;
}","public void test69102() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithNewThisType(functionType0, functionType0);
    assertFalse(functionType1.isNullType());
}",""
"@Override
public boolean isNativeObjectType() {
    return referencedObjType == null ? false : referencedObjType.isNativeObjectType();
}","public void test70103() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.RANGE_ERROR_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, objectType0, objectType0);
    indexedType0.isPropertyInExterns(""Function"");
    assertTrue(indexedType0.isNativeObjectType());
}",""
"public boolean hasInstanceType() {
    return isConstructor() || isInterface();
}","public void test71104() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noResolvedType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    functionType0.setPrototypeBasedOn(functionType1);
    assertFalse(functionType1.hasInstanceType());
}","/**
 * Returns whether this function type has an instance type.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test71105() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[0];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noResolvedType0, jSTypeArray0);
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) functionType0, jSTypeArray0);
    functionType0.setPrototypeBasedOn(functionType1);
    assertFalse(functionType1.hasCachedValues());
}",""
"public boolean resetImplicitPrototype(JSType type, ObjectType newImplicitProto) {
    if (type instanceof PrototypeObjectType) {
        PrototypeObjectType poType = (PrototypeObjectType) type;
        if (!poType.hasCachedValues()) {
            poType.setImplicitPrototype(newImplicitProto);
            return true;
        }
    }
    return false;
}","public void test72106() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.STRING_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    boolean boolean0 = jSTypeRegistry0.resetImplicitPrototype(functionType0, functionType0);
    assertFalse(boolean0);
}","/**
 * Set the implicit prototype if it's possible to do so.
 * @return True if we were able to set the implicit prototype successfully,
 *     false if it was not possible to do so for some reason. There are
 *     a few different reasons why this could fail: for example, numbers
 *     can't be implicit prototypes, and we don't want to change the implicit
 *     prototype if other classes have already subclassed this one.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test73107() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    JSType jSType0 = JSType.getGreatestSubtype((JSType) errorFunctionType0, (JSType) noObjectType0);
    boolean boolean0 = jSTypeRegistry0.resetImplicitPrototype(jSType0, errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public boolean resetImplicitPrototype(JSType type, ObjectType newImplicitProto) {
    if (type instanceof PrototypeObjectType) {
        PrototypeObjectType poType = (PrototypeObjectType) type;
        if (!poType.hasCachedValues()) {
            poType.setImplicitPrototype(newImplicitProto);
            return true;
        }
    }
    return false;
}","public void test73108() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    JSType jSType0 = JSType.getGreatestSubtype((JSType) errorFunctionType0, (JSType) noObjectType0);
    boolean boolean0 = jSTypeRegistry0.resetImplicitPrototype(jSType0, errorFunctionType0);
    assertFalse(boolean0);
}","/**
 * Set the implicit prototype if it's possible to do so.
 * @return True if we were able to set the implicit prototype successfully,
 *     false if it was not possible to do so for some reason. There are
 *     a few different reasons why this could fail: for example, numbers
 *     can't be implicit prototypes, and we don't want to change the implicit
 *     prototype if other classes have already subclassed this one.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test74109() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""new:"", ""aGD"", (-1389), 2);
    JSType jSType0 = namedType0.getReferencedType();
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    LinkedList<ObjectType> linkedList1 = new LinkedList<ObjectType>();
    linkedList1.add((ObjectType) namedType0);
    functionType0.setImplementedInterfaces(linkedList1);
    FunctionType functionType1 = (FunctionType) functionType0.forceResolve(simpleErrorReporter0, namedType0);
    assertFalse(functionType1.hasCachedValues());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test75110() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = functionType0.resolveInternal(simpleErrorReporter0, noObjectType0);
    assertFalse(jSType0.isNoResolvedType());
}",""
"@Override
public String toDebugHashCodeString() {
    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return super.toDebugHashCodeString();
    }
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();
    if (hasKnownTypeOfThis) {
        b.append(""this:"");
        b.append(getDebugHashCodeStringOf(typeOfThis));
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        b.append(getDebugHashCodeStringOf(p.getJSType()));
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            b.append(getDebugHashCodeStringOf(p.getJSType()));
            p = p.getNext();
        }
    }
    b.append("")"");
    b.append("": "");
    b.append(getDebugHashCodeStringOf(call.returnType));
    return b.toString();
}","public void test76111() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    String string0 = functionType0.toDebugHashCodeString();
    assertEquals(""function (this:{18}, {12}): {9}"", string0);
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test77112() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    JSType jSType0 = errorFunctionType0.getPropertyType(""call"");
    String string0 = jSType0.toDebugHashCodeString();
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public String toDebugHashCodeString() {
    return ""{"" + this.hashCode() + ""}"";
}","public void test77113() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""call"");
    JSType jSType0 = errorFunctionType0.getPropertyType(""call"");
    String string0 = jSType0.toDebugHashCodeString();
    assertEquals(""function ({({3045982},{11},{6})}, {12}, {12}, {12}): {3045982}"", string0);
}","/**
 * A hash code function for diagnosing complicated issues
 * around type-identity.
 */"
"@Override
public String toDebugHashCodeString() {
    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return super.toDebugHashCodeString();
    }
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();
    if (hasKnownTypeOfThis) {
        b.append(""this:"");
        b.append(getDebugHashCodeStringOf(typeOfThis));
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        b.append(getDebugHashCodeStringOf(p.getJSType()));
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            b.append(getDebugHashCodeStringOf(p.getJSType()));
            p = p.getNext();
        }
    }
    b.append("")"");
    b.append("": "");
    b.append(getDebugHashCodeStringOf(call.returnType));
    return b.toString();
}","public void test78114() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Unknown class name"", (Node) null);
    String string0 = functionType0.toDebugHashCodeString();
    assertEquals(""function (this:{1977786857}): {9}"", string0);
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test79115() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    noResolvedType0.toDebugHashCodeString();
    assertTrue(noResolvedType0.hasCachedValues());
}",""
