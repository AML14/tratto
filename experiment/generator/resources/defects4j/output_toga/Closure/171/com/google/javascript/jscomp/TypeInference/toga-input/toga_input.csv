focal_method,test_prefix,docstring
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0000() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gmj5z"", ""j_Gmj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(101, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // AND 4095 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(33, node0, node0, node0, 3396, (-2376));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000709] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000710] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000711] is not a string node
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"final void analyze() {
    analyze(MAX_STEPS);
}","public void test0033() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    typeInference0.analyze();
}","/**
 * Finds a fixed-point solution using at most {@link #MAX_STEPS}
 * iterations.
 *
 * @see #analyze(int)
 */"
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0044() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(100, 125, 128);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Map<String, AssertionFunctionSpec> assertionFunctionsMap) {
    super(cfg, new LinkedFlowScope.FlowScopeJoinOp());
    this.compiler = compiler;
    this.registry = compiler.getTypeRegistry();
    this.reverseInterpreter = reverseInterpreter;
    this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE);
    this.syntacticScope = functionScope;
    inferArguments(functionScope);
    this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);
    this.assertionFunctionsMap = assertionFunctionsMap;
    // For each local variable declared with the VAR keyword, the entry
    // type is VOID.
    Iterator<Var> varIt = functionScope.getDeclarativelyUnboundVarsWithoutTypes();
    while (varIt.hasNext()) {
        Var var = varIt.next();
        if (isUnflowable(var)) {
            continue;
        }
        this.functionScope.inferSlotType(var.getName(), getNativeType(VOID_TYPE));
    }
    this.bottomScope = LinkedFlowScope.createEntryLattice(Scope.createLatticeBottom(functionScope.getRootNode()));
}","public void test0055() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    Node node1 = new Node(30, node0, node0, node0, 37, (-830));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0088() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
    controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000709] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000710] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000711] does not have a condition.
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
    controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000709] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000710] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000711] does not have a condition.
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01010() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(4, node0, node0, node0, 48, 15);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RETURN 48 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(5, 30, 47);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 5
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01212() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(8, 56, 116);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 8
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01313() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""protoype"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""}3<^YjMW\""Nzy"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(12, 12, 2309);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EQ 12 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01414() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(14, 143, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LT 143 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01515() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""&"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""UNCOND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(15, 16, 46);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LE 16 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01616() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(16, 16, 1);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GT 16 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01717() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(18, 4046, 40);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LSH 4046 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01818() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(20, 144, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // URSH 144 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01919() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(21, 119, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02020() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(27, 148, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITNOT 148 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02121() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(28, 37, (-2481));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02222() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(29, 400000, 16);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02323() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(31, 1, 49);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DELPROP 1 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02424() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""-j_Gj5z"", ""-j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(32, node0, node0, node0, 32, 46);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // TYPEOF 32 : string does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02525() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(36, 109, 108);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 36
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02626() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(37, node0, node0, node0, 15, 147);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CALL 15 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02727() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(39, 54, 4095);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Number node not created with Node.newNumber
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02828() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(""Object#Element"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // STRING Object#Element does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02929() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""UNCOND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(41, 1, 49);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NULL 1 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03030() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(42, node0, node0, node0, 51, 15);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // THIS 51 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03131() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Glj7z"", codingConvention_AssertionFunctionSpec0);
    Node node1 = new Node(43, 4, 144);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FALSE 4 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03232() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(46, 110, 32);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SHNE 110 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03333() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""q_GJ5z"", ""q_GJ5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(47, 399, 31);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // REGEXP 399 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03434() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(48, 55, 31);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 48
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03535() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(49, 4095, (-2873));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // THROW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03636() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(50, 4, 4);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 50
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03737() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(51, node0, node0, node0, 4, 105);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // IN 4 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03838() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Y"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInference$1"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(52, (-628), 54);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // INSTANCEOF : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03939() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""4L9BD/1(b&4<pq/%nL;"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(53, node0, node0, node0, 43, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 53
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04040() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(54, 143, 31);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 54
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04141() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(55, 119, 48);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 55
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04242() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(56, 4095, 54);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 56
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04343() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(57, 134, 12);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 57
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04444() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(61, 114, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 61
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04545() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""cm.google;javascript.jscomp.TypeInference"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""cm.google;javascript.jscomp.TypeInference"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(65, node0, node0, node0, 4095, 65);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 65
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04646() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(68, node0, node0, node0, 4095, 68);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 68
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04747() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_u5"", ""j_u5"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""KeOp?+rd%q;~&rzf}"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(69, node0, node0, node0, 1483, 1068);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 69
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04848() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(70, 42, 57);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 70
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04949() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(74, node0, node0, node0, 4095, 74);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 74
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05050() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInference"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(78, node0, node0, node0, 4095, 78);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 78
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05151() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""JSC_UNLISTEN_WITH_ANONBOUnD"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUnD"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(79, 118, 40);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 79
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05252() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(81, node0, node0, node0, 4095, 12);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 81
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05353() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""?ZuWgrMe"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
    TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    JSType[] jSTypeArray0 = new JSType[4];
    Node node1 = jSTypeRegistry0.createParameters(jSTypeArray0);
    // Undeclared exception!
    try {
        typeInference1.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // PARAM_LIST : ? does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05454() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(84, 2, 135);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 84
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05555() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""q_GJ5z"", ""q_GJ5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(89, 32, 1);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_BITAND 32 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05656() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_R5L"", ""j_R5L"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_R5L"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(90, 1023, 47);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_LSH 1023 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05757() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(91, 3467, 50);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_RSH 3467 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05858() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""okR|?pE+W"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(92, node0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_URSH : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05959() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(93, (-697), 400000);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06060() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(97, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_MOD 4095 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06161() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(98, (-30), 16);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06262() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(99, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 99
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06363() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(102, 150, 36);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // INC 150 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06464() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(103, node0, node0, node0, 4095, 103);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DEC 4095 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06565() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(105, node0, node0, node0, 4095, 12);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FUNCTION <invalid> 4095 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06666() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(106, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 106
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06767() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(107, 30, 70);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 107
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06868() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference$TemplateTypeReplcer"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(109, 4095, 1017);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 109
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06969() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(110, (-2448), (-1075));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07070() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(111, 30, 47);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CASE 30 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07171() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null, jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""a+"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(112, 54, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DEFAULT_CASE 54 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07272() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(113, 4095, 39);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // WHILE 4095 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07373() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""q_GJ5z"", ""q_GJ5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""%N~PZq<8K_$/<md"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(114, 38, (-3635));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DO does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07474() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gmj5z"", ""j_Gmj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(115, 32, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FOR 32 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07575() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""{>5;*)#D"", ""com.google.javascript.jscomp.CreateSyntheticBlocks"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(117, 1071, 42);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CONTINUE 1071 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07676() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(118, 703, 56);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // VAR 703 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07777() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""prototype"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""a3<^YjMWnN,zy"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(119, 116, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // WITH 116 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07878() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(120, node0, node0, node0, 180, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07979() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Glj7z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(121, 139, 16);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 121
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08080() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(122, 3467, 50);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // VOID 3467 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08181() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(123, node0, node0, node0, 52, 154);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 123
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08282() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInfrece"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInfrece"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(124, node0, node0, node0, 2, 48);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EMPTY 2 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08383() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(125, 125, 108);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BLOCK 125 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08484() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(126, 15, 128);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LABEL 15 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08585() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(127, 4095, 1);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 127
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08686() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(128, 12, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 128
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08787() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInference"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(130, node0, node0, node0, 2, 48);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EXPR_RESULT 2 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08888() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(131, 38, 140);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 131
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08989() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = Scope.createGlobalScope(node0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(133, 29, 43);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 133
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09090() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""protoype"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""a3<^YjMWnN,zy"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(134, node0, node0, node0, 1, 107);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 134
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09191() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(135, node0, node0, node0, 4711, 5);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 135
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09292() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(136, 617, 1841);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 136
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09393() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(137, 759, 42);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 137
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09494() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(138, 139, 4095);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 138
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09595() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(139, 4095, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 139
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09696() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(140, (-2553), 1);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 140
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09797() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_STRING_BOOLEAN;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(141, 143, 2);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 141
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09898() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""F&g+`z6%CA@J"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter$2"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(142, 51, 54);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 142
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09999() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(143, 400000, (-1614));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 143
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test100100() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jQuerySub.fn"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(144, 2138, (-3163));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 144
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test101101() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""|75Zr:K_uylp}.MD2v"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""|75Zr:K_uylp}.MD2v"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(145, 48, (-1173));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 145
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test102102() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(147, 52, 1119);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GETTER_DEF 52 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test103103() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(148, 36, 51);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETTER_DEF 36 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test104104() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(149, 151, 3);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CONST 151 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test105105() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.GlobalVarReferenceMap"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(150, (-1813), 49);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 150
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test106106() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(151, 1365, 118);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 151
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
FlowScope flowThrough(Node n, FlowScope input) {
    // If we have not walked a path from <entry> to <n>, then we don't
    // want to infer anything about this scope.
    if (input == bottomScope) {
        return input;
    }
    FlowScope output = input.createChildFlowScope();
    output = traverse(n, output);
    return output;
}","public void test107107() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference$TemplateTypeReplcer"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    Node node1 = new Node(152, 29, 4378);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    assertNotSame(flowScope0, linkedFlowScope0);
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test108108() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Glj7z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(154, 0, (-1553));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // STRING_KEY does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test109109() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(155, 54, 4095);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CAST 54 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test110110() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(1931, 29, 50);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 1931
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test111111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(4, 143, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RETURN 143 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings({ ""fallthrough"", ""incomplete-switch"" })
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably too expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getTemplateTypeMap().getTemplateType(registry.getObjectIndexKey());
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test112112() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""419BD/1(b&4<pq/w%nL;"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(30, 114, 2);
    node1.addChildToFront(node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW 114 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) {
    return right.union(left.intersection(BooleanLiteralSet.get(!condition)));
}","public void test113113() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
    assertEquals(BooleanLiteralSet.FALSE, booleanLiteralSet1);
}","/**
 * Infers the boolean literal set that can be taken by a
 * short-circuiting binary operation ({@code &&} or {@code ||}).
 * @param left the set of possible {@code ToBoolean} predicate results for
 *    the expression on the left side of the operator
 * @param right the set of possible {@code ToBoolean} predicate results for
 *    the expression on the right side of the operator
 * @param condition the left side {@code ToBoolean} predicate result that
 *    causes the right side to get evaluated (i.e. not short-circuited)
 * @return a set of possible {@code ToBoolean} predicate results for the
 *    entire expression
 */"
"static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) {
    return right.union(left.intersection(BooleanLiteralSet.get(!condition)));
}","public void test114114() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
    assertSame(booleanLiteralSet1, booleanLiteralSet0);
}","/**
 * Infers the boolean literal set that can be taken by a
 * short-circuiting binary operation ({@code &&} or {@code ||}).
 * @param left the set of possible {@code ToBoolean} predicate results for
 *    the expression on the left side of the operator
 * @param right the set of possible {@code ToBoolean} predicate results for
 *    the expression on the right side of the operator
 * @param condition the left side {@code ToBoolean} predicate result that
 *    causes the right side to get evaluated (i.e. not short-circuited)
 * @return a set of possible {@code ToBoolean} predicate results for the
 *    entire expression
 */"
