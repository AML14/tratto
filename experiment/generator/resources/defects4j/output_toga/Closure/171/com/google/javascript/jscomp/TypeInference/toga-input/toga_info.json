{
  "test0000" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0000() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gmj5z\", \"j_Gmj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"t@dl=I\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"t@dl=I\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(101, node0, node0, node0, 4095, 139);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test0000"
  },
  "test0088" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0088() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"jGE\", \"jGE\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"jGE\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;\n    controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test0088"
  },
  "test107107" : {
    "methodSignature" : "FlowScope flowThrough(Node n, FlowScope input)",
    "methodName" : "flowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test107107() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"com.google.javascript.jscomp.TypeInference$TemplateTypeReplcer\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    Node node1 = new Node(152, 29, 4378);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test107107"
  },
  "test03636" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03636() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(50, 4, 4);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03636"
  },
  "test02424" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02424() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"-j_Gj5z\", \"-j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(32, node0, node0, node0, 32, 46);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02424"
  },
  "test04848" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04848() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(70, 42, 57);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04848"
  },
  "test01212" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01212() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(8, 56, 116);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01212"
  },
  "test05656" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05656() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_R5L\", \"j_R5L\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_R5L\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"JSC_UNLISTEN_WITH_ANONBOUND\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(90, 1023, 47);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05656"
  },
  "test06868" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06868() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"com.google.javascript.jscomp.TypeInference$TemplateTypeReplcer\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(109, 4095, 1017);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06868"
  },
  "test02828" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02828() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(\"Object#Element\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02828"
  },
  "test113113" : {
    "methodSignature" : "static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition)",
    "methodName" : "getBooleanOutcomes",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test113113() throws Throwable {\n    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;\n    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);\n}",
    "testName" : "test113113"
  },
  "test01616" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01616() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"jGE\", \"jGE\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"jGE\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(16, 16, 1);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01616"
  },
  "test08484" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08484() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"JSC_UNLISTEN_WITH_ANONBOUND\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(126, 15, 128);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08484"
  },
  "test07272" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07272() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(113, 4095, 39);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07272"
  },
  "test04040" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04040() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(54, 143, 31);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04040"
  },
  "test0011" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0011() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(33, node0, node0, node0, 3396, (-2376));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test0011"
  },
  "test0099" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0099() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;\n    controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test0099"
  },
  "test09292" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09292() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(136, 617, 1841);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09292"
  },
  "test06060" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06060() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"t@dl=I\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"t@dl=I\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(97, node0, node0, node0, 4095, 139);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06060"
  },
  "test03232" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03232() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Key\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(46, 110, 32);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03232"
  },
  "test08888" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08888() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(131, 38, 140);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08888"
  },
  "test102102" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test102102() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);\n    Node node1 = new Node(147, 52, 1119);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test102102"
  },
  "test02020" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02020() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(27, 148, 148);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02020"
  },
  "test04444" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04444() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(61, 114, 148);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04444"
  },
  "test07676" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07676() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(118, 703, 56);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07676"
  },
  "test05252" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05252() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"t@dl=I\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"t@dl=I\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(81, node0, node0, node0, 4095, 12);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05252"
  },
  "test09696" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09696() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Key\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(140, (-2553), 1);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09696"
  },
  "test06464" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06464() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Key\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(103, node0, node0, node0, 4095, 103);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06464"
  },
  "test110110" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test110110() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(1931, 29, 50);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test110110"
  },
  "test08080" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08080() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    Node node1 = new Node(122, 3467, 50);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08080"
  },
  "test105105" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test105105() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"com.google.javascript.jscomp.GlobalVarReferenceMap\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(150, (-1813), 49);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test105105"
  },
  "test01313" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01313() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"protoype\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"}3<^YjMW\\\"Nzy\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(12, 12, 2309);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01313"
  },
  "test06969" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06969() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Key\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(110, (-2448), (-1075));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06969"
  },
  "test03737" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03737() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(51, node0, node0, node0, 4, 105);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03737"
  },
  "test04545" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04545() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"cm.google;javascript.jscomp.TypeInference\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"cm.google;javascript.jscomp.TypeInference\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(65, node0, node0, node0, 4095, 65);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04545"
  },
  "test08989" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08989() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(133, 29, 43);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08989"
  },
  "test02525" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02525() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(36, 109, 108);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02525"
  },
  "test05757" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05757() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    Node node1 = new Node(91, 3467, 50);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05757"
  },
  "test01717" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01717() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(18, 4046, 40);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01717"
  },
  "test111111" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test111111() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(4, 143, 52);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test111111"
  },
  "test04949" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04949() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(74, node0, node0, node0, 4095, 74);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04949"
  },
  "test02929" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02929() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"UNCOND\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);\n    Node node1 = new Node(41, 1, 49);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02929"
  },
  "test06161" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06161() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(98, (-30), 16);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06161"
  },
  "test07373" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07373() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"q_GJ5z\", \"q_GJ5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"%N~PZq<8K_$/<md\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(114, 38, (-3635));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07373"
  },
  "test09393" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09393() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    Node node1 = new Node(137, 759, 42);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09393"
  },
  "test0033" : {
    "methodSignature" : "final void analyze()",
    "methodName" : "analyze",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0033() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    typeInference0.analyze();\n}",
    "testName" : "test0033"
  },
  "test08181" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08181() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"jGE\", \"jGE\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"jGE\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    Node node1 = new Node(123, node0, node0, node0, 52, 154);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08181"
  },
  "test07777" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07777() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"prototype\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"a3<^YjMWnN,zy\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(119, 116, 2);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07777"
  },
  "test06565" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06565() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(105, node0, node0, node0, 4095, 12);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06565"
  },
  "test03333" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03333() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"q_GJ5z\", \"q_GJ5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(47, 399, 31);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03333"
  },
  "test100100" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test100100() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"jQuerySub.fn\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(144, 2138, (-3163));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test100100"
  },
  "test04141" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04141() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(55, 119, 48);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04141"
  },
  "test09797" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09797() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_STRING_BOOLEAN;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(141, 143, 2);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09797"
  },
  "test08585" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08585() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(127, 4095, 1);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08585"
  },
  "test02121" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02121() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(28, 37, (-2481));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02121"
  },
  "test05353" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05353() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"?ZuWgrMe\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();\n    TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    JSType[] jSTypeArray0 = new JSType[4];\n    Node node1 = jSTypeRegistry0.createParameters(jSTypeArray0);\n    typeInference1.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test05353"
  },
  "test108108" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test108108() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Glj7z\", \"j_Glj7z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Glj7z\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Glj7z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(154, 0, (-1553));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test108108"
  },
  "test0044" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0044() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(100, 125, 128);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test0044"
  },
  "test103103" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test103103() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(148, 36, 51);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test103103"
  },
  "test05858" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05858() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"okR|?pE+W\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(92, node0, node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05858"
  },
  "test03434" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03434() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(48, 55, 31);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03434"
  },
  "test02626" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02626() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(37, node0, node0, node0, 15, 147);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02626"
  },
  "test04646" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04646() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Key\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(68, node0, node0, node0, 4095, 68);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04646"
  },
  "test07878" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07878() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Key\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(120, node0, node0, node0, 180, 52);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07878"
  },
  "test01414" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01414() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(14, 143, 52);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01414"
  },
  "test03838" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03838() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Y\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"com.google.javascript.jscomp.TypeInference$1\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(52, (-628), 54);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03838"
  },
  "test01818" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01818() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(20, 144, 148);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01818"
  },
  "test05050" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05050() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"com.google.javascript.jscomp.TypeInference\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"com.google.javascript.jscomp.TypeInference\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(78, node0, node0, node0, 4095, 78);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05050"
  },
  "test09494" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09494() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(138, 139, 4095);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09494"
  },
  "test06262" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06262() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"t@dl=I\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"t@dl=I\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(99, node0, node0, node0, 4095, 139);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06262"
  },
  "test08282" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08282() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"com.google.javascript.jscomp.TypeInfrece\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"com.google.javascript.jscomp.TypeInfrece\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    Node node1 = new Node(124, node0, node0, node0, 2, 48);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08282"
  },
  "test07070" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07070() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(111, 30, 47);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07070"
  },
  "test0055" : {
    "methodSignature" : "TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Map<String, AssertionFunctionSpec> assertionFunctionsMap)",
    "methodName" : "TypeInference",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0055() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    Node node1 = new Node(30, node0, node0, node0, 37, (-830));\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n}",
    "testName" : "test0055"
  },
  "test05454" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05454() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(84, 2, 135);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05454"
  },
  "test09898" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09898() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"F&g+`z6%CA@J\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter$2\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(142, 51, 54);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09898"
  },
  "test06666" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06666() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"t@dl=I\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"t@dl=I\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(106, node0, node0, node0, 4095, 139);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06666"
  },
  "test03030" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03030() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(42, node0, node0, node0, 51, 15);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03030"
  },
  "test08686" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08686() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(128, 12, 139);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08686"
  },
  "test02222" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02222() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    Node node1 = new Node(29, 400000, 16);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02222"
  },
  "test07474" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07474() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gmj5z\", \"j_Gmj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"t@dl=I\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"t@dl=I\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(115, 32, 52);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07474"
  },
  "test04242" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04242() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(56, 4095, 54);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04242"
  },
  "test106106" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test106106() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(151, 1365, 118);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test106106"
  },
  "test01010" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01010() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(4, node0, node0, node0, 48, 15);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01010"
  },
  "test09090" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09090() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"protoype\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"a3<^YjMWnN,zy\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(134, node0, node0, node0, 1, 107);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09090"
  },
  "test114114" : {
    "methodSignature" : "static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition)",
    "methodName" : "getBooleanOutcomes",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test114114() throws Throwable {\n    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;\n    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);\n}",
    "testName" : "test114114"
  },
  "test101101" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test101101() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"|75Zr:K_uylp}.MD2v\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"|75Zr:K_uylp}.MD2v\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(145, 48, (-1173));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test101101"
  },
  "test109109" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test109109() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(155, 54, 4095);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test109109"
  },
  "test04747" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04747() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_u5\", \"j_u5\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"KeOp?+rd%q;~&rzf}\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(69, node0, node0, node0, 1483, 1068);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04747"
  },
  "test02323" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02323() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(31, 1, 49);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02323"
  },
  "test05959" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05959() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(93, (-697), 400000);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05959"
  },
  "test07979" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07979() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Glj7z\", \"j_Glj7z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Glj7z\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Glj7z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(121, 139, 16);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07979"
  },
  "test01515" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01515() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"&\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"UNCOND\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(15, 16, 46);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01515"
  },
  "test06767" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06767() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    Node node1 = new Node(107, 30, 70);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06767"
  },
  "test03535" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03535() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(49, 4095, (-2873));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03535"
  },
  "test02727" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02727() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(39, 54, 4095);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02727"
  },
  "test01919" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01919() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"UNCOND\", \"UNCOND\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"UNCOND\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);\n    Node node1 = new Node(21, 119, 148);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01919"
  },
  "test03939" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03939() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Glj7z\", \"j_Glj7z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"4L9BD/1(b&4<pq/%nL;\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"JSC_UNLISTEN_WITH_ANONBOUND\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(53, node0, node0, node0, 43, 2);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03939"
  },
  "test09595" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09595() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Gj5z\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(139, 4095, 2);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09595"
  },
  "test08383" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08383() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"JSC_UNLISTEN_WITH_ANONBOUND\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(125, 125, 108);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08383"
  },
  "test05151" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05151() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Glj7z\", \"j_Glj7z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"JSC_UNLISTEN_WITH_ANONBOUnD\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"JSC_UNLISTEN_WITH_ANONBOUnD\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(79, 118, 40);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05151"
  },
  "test07171" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07171() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null, jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"a+\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(112, 54, 2);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07171"
  },
  "test04343" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04343() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"jGE\", \"jGE\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"jGE\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(57, 134, 12);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04343"
  },
  "test09999" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09999() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Gj5z\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(143, 400000, (-1614));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09999"
  },
  "test104104" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test104104() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(149, 151, 3);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test104104"
  },
  "test08787" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08787() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"com.google.javascript.jscomp.TypeInference\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"com.google.javascript.jscomp.TypeInference\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    Node node1 = new Node(130, node0, node0, node0, 2, 48);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08787"
  },
  "test05555" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05555() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"q_GJ5z\", \"q_GJ5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);\n    Node node1 = new Node(89, 32, 1);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05555"
  },
  "test01111" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01111() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Key\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(5, 30, 47);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01111"
  },
  "test06363" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06363() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_FUNCTION_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"Object#Element\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Element\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(102, 150, 36);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06363"
  },
  "test03131" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03131() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Glj7z\", \"j_Glj7z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Glj7z\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"j_Glj7z\", codingConvention_AssertionFunctionSpec0);\n    Node node1 = new Node(43, 4, 144);\n    Scope scope0 = Scope.createLatticeBottom(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03131"
  },
  "test07575" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07575() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"{>5;*)#D\", \"com.google.javascript.jscomp.CreateSyntheticBlocks\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();\n    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"j_Glj7z\", jSTypeNative0);\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"Object#Key\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(117, 1071, 42);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07575"
  },
  "test09191" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09191() throws Throwable {\n    Logger logger0 = Tracer.logger;\n    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);\n    Compiler compiler0 = new Compiler(loggerErrorManager0);\n    Node node0 = compiler0.parseSyntheticCode(\"j_Gj5z\", \"j_Gj5z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"t@dl=I\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"t@dl=I\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(135, node0, node0, node0, 4711, 5);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09191"
  },
  "test112112" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test112112() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"j_Glj7z\", \"j_Glj7z\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"419BD/1(b&4<pq/w%nL;\");\n    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(\"JSC_UNLISTEN_WITH_ANONBOUND\", codingConvention_AssertionFunctionSpec0);\n    Scope scope0 = Scope.createGlobalScope(node0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(30, 114, 2);\n    node1.addChildToFront(node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test112112"
  }
}