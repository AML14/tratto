project,bug_num,test_name,test_prefix,except_pred,assert_pred
project,0,test0000,"public void test0000() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gmj5z"", ""j_Gmj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(101, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // AND 4095 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test0011,"public void test0011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(33, node0, node0, node0, 3396, (-2376));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000709] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000710] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000711] is not a string node
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",0,
project,0,test0033,"public void test0033() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    typeInference0.analyze();
}",0,
project,0,test0044,"public void test0044() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(100, 125, 128);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test0055,"public void test0055() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    Node node1 = new Node(30, node0, node0, node0, 37, (-830));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
}",0,
project,0,test0088,"public void test0088() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
    controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000709] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000710] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000711] does not have a condition.
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",0,
project,0,test0099,"public void test0099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
    controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000709] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000710] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000711] does not have a condition.
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",0,
project,0,test01010,"public void test01010() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(4, node0, node0, node0, 48, 15);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RETURN 48 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01111,"public void test01111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(5, 30, 47);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 5
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test01212,"public void test01212() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(8, 56, 116);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 8
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test01313,"public void test01313() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""protoype"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""}3<^YjMW\""Nzy"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(12, 12, 2309);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EQ 12 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01414,"public void test01414() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(14, 143, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LT 143 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01515,"public void test01515() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""&"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""UNCOND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(15, 16, 46);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LE 16 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01616,"public void test01616() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(16, 16, 1);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GT 16 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01717,"public void test01717() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(18, 4046, 40);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LSH 4046 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01818,"public void test01818() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(20, 144, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // URSH 144 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01919,"public void test01919() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(21, 119, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test02020,"public void test02020() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(27, 148, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITNOT 148 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test02121,"public void test02121() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(28, 37, (-2481));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",0,
project,0,test02222,"public void test02222() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(29, 400000, 16);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",0,
project,0,test02323,"public void test02323() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(31, 1, 49);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DELPROP 1 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test02424,"public void test02424() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""-j_Gj5z"", ""-j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(32, node0, node0, node0, 32, 46);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // TYPEOF 32 : string does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test02525,"public void test02525() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(36, 109, 108);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 36
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test02626,"public void test02626() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(37, node0, node0, node0, 15, 147);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CALL 15 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test02727,"public void test02727() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(39, 54, 4095);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Number node not created with Node.newNumber
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",0,
project,0,test02828,"public void test02828() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(""Object#Element"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // STRING Object#Element does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test02929,"public void test02929() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""UNCOND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(41, 1, 49);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NULL 1 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03030,"public void test03030() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(42, node0, node0, node0, 51, 15);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // THIS 51 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03131,"public void test03131() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Glj7z"", codingConvention_AssertionFunctionSpec0);
    Node node1 = new Node(43, 4, 144);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FALSE 4 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03232,"public void test03232() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(46, 110, 32);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SHNE 110 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03333,"public void test03333() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""q_GJ5z"", ""q_GJ5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(47, 399, 31);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // REGEXP 399 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03434,"public void test03434() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(48, 55, 31);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 48
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test03535,"public void test03535() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(49, 4095, (-2873));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // THROW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03636,"public void test03636() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(50, 4, 4);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 50
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test03737,"public void test03737() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(51, node0, node0, node0, 4, 105);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // IN 4 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03838,"public void test03838() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Y"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInference$1"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(52, (-628), 54);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // INSTANCEOF : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03939,"public void test03939() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""4L9BD/1(b&4<pq/%nL;"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(53, node0, node0, node0, 43, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 53
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04040,"public void test04040() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(54, 143, 31);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 54
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04141,"public void test04141() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(55, 119, 48);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 55
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04242,"public void test04242() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(56, 4095, 54);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 56
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04343,"public void test04343() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(57, 134, 12);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 57
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04444,"public void test04444() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(61, 114, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 61
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04545,"public void test04545() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""cm.google;javascript.jscomp.TypeInference"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""cm.google;javascript.jscomp.TypeInference"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(65, node0, node0, node0, 4095, 65);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 65
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04646,"public void test04646() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(68, node0, node0, node0, 4095, 68);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 68
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04747,"public void test04747() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_u5"", ""j_u5"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""KeOp?+rd%q;~&rzf}"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(69, node0, node0, node0, 1483, 1068);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 69
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04848,"public void test04848() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(70, 42, 57);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 70
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04949,"public void test04949() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(74, node0, node0, node0, 4095, 74);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 74
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test05050,"public void test05050() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInference"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(78, node0, node0, node0, 4095, 78);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 78
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test05151,"public void test05151() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""JSC_UNLISTEN_WITH_ANONBOUnD"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUnD"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(79, 118, 40);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 79
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test05252,"public void test05252() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(81, node0, node0, node0, 4095, 12);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 81
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test05353,"public void test05353() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""?ZuWgrMe"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
    TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    JSType[] jSTypeArray0 = new JSType[4];
    Node node1 = jSTypeRegistry0.createParameters(jSTypeArray0);
    // Undeclared exception!
    try {
        typeInference1.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // PARAM_LIST : ? does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test05454,"public void test05454() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(84, 2, 135);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 84
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test05555,"public void test05555() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""q_GJ5z"", ""q_GJ5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(89, 32, 1);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_BITAND 32 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test05656,"public void test05656() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_R5L"", ""j_R5L"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_R5L"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(90, 1023, 47);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_LSH 1023 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test05757,"public void test05757() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(91, 3467, 50);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_RSH 3467 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test05858,"public void test05858() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""okR|?pE+W"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(92, node0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_URSH : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test05959,"public void test05959() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(93, (-697), 400000);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test06060,"public void test06060() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(97, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_MOD 4095 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test06161,"public void test06161() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(98, (-30), 16);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test06262,"public void test06262() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(99, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 99
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test06363,"public void test06363() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(102, 150, 36);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // INC 150 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test06464,"public void test06464() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(103, node0, node0, node0, 4095, 103);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DEC 4095 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test06565,"public void test06565() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(105, node0, node0, node0, 4095, 12);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FUNCTION <invalid> 4095 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test06666,"public void test06666() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(106, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 106
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test06767,"public void test06767() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(107, 30, 70);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 107
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test06868,"public void test06868() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference$TemplateTypeReplcer"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(109, 4095, 1017);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 109
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test06969,"public void test06969() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(110, (-2448), (-1075));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",0,
project,0,test07070,"public void test07070() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(111, 30, 47);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CASE 30 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07171,"public void test07171() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null, jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""a+"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(112, 54, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DEFAULT_CASE 54 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07272,"public void test07272() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(113, 4095, 39);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // WHILE 4095 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07373,"public void test07373() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""q_GJ5z"", ""q_GJ5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""%N~PZq<8K_$/<md"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(114, 38, (-3635));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DO does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07474,"public void test07474() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gmj5z"", ""j_Gmj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(115, 32, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FOR 32 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07575,"public void test07575() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""{>5;*)#D"", ""com.google.javascript.jscomp.CreateSyntheticBlocks"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(117, 1071, 42);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CONTINUE 1071 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07676,"public void test07676() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(118, 703, 56);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // VAR 703 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07777,"public void test07777() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""prototype"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""a3<^YjMWnN,zy"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(119, 116, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // WITH 116 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07878,"public void test07878() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(120, node0, node0, node0, 180, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",0,
project,0,test07979,"public void test07979() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Glj7z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(121, 139, 16);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 121
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test08080,"public void test08080() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(122, 3467, 50);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // VOID 3467 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test08181,"public void test08181() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(123, node0, node0, node0, 52, 154);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 123
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test08282,"public void test08282() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInfrece"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInfrece"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(124, node0, node0, node0, 2, 48);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EMPTY 2 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test08383,"public void test08383() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(125, 125, 108);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BLOCK 125 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test08484,"public void test08484() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(126, 15, 128);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LABEL 15 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test08585,"public void test08585() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(127, 4095, 1);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 127
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test08686,"public void test08686() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(128, 12, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 128
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test08787,"public void test08787() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInference"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(130, node0, node0, node0, 2, 48);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EXPR_RESULT 2 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test08888,"public void test08888() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(131, 38, 140);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 131
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test08989,"public void test08989() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = Scope.createGlobalScope(node0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(133, 29, 43);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 133
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09090,"public void test09090() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""protoype"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""a3<^YjMWnN,zy"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(134, node0, node0, node0, 1, 107);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 134
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09191,"public void test09191() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(135, node0, node0, node0, 4711, 5);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 135
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09292,"public void test09292() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(136, 617, 1841);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 136
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09393,"public void test09393() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(137, 759, 42);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 137
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09494,"public void test09494() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(138, 139, 4095);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 138
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09595,"public void test09595() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(139, 4095, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 139
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09696,"public void test09696() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(140, (-2553), 1);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 140
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09797,"public void test09797() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_STRING_BOOLEAN;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(141, 143, 2);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 141
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09898,"public void test09898() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""F&g+`z6%CA@J"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter$2"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(142, 51, 54);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 142
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09999,"public void test09999() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(143, 400000, (-1614));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 143
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test100100,"public void test100100() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jQuerySub.fn"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(144, 2138, (-3163));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 144
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test101101,"public void test101101() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""|75Zr:K_uylp}.MD2v"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""|75Zr:K_uylp}.MD2v"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(145, 48, (-1173));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 145
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test102102,"public void test102102() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(147, 52, 1119);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GETTER_DEF 52 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test103103,"public void test103103() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(148, 36, 51);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETTER_DEF 36 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test104104,"public void test104104() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(149, 151, 3);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CONST 151 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test105105,"public void test105105() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.GlobalVarReferenceMap"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(150, (-1813), 49);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 150
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test106106,"public void test106106() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(151, 1365, 118);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 151
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test107107,"public void test107107() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference$TemplateTypeReplcer"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    Node node1 = new Node(152, 29, 4378);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    assertNotSame(flowScope0, linkedFlowScope0);
}",0,
project,0,test108108,"public void test108108() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Glj7z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(154, 0, (-1553));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // STRING_KEY does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test109109,"public void test109109() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(155, 54, 4095);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CAST 54 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test110110,"public void test110110() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(1931, 29, 50);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 1931
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test111111,"public void test111111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(4, 143, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RETURN 143 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test112112,"public void test112112() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""419BD/1(b&4<pq/w%nL;"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(30, 114, 2);
    node1.addChildToFront(node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW 114 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test113113,"public void test113113() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
    assertEquals(BooleanLiteralSet.FALSE, booleanLiteralSet1);
}",0,
project,0,test114114,"public void test114114() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
    assertSame(booleanLiteralSet1, booleanLiteralSet0);
}",0,
