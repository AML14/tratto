focal_method,test_prefix,docstring
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test00() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""goog.base"");
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    PreprocessorSymbolTable preprocessorSymbolTable0 = new PreprocessorSymbolTable(node0);
    ProcessClosurePrimitives processClosurePrimitives0 = new ProcessClosurePrimitives(compiler0, preprocessorSymbolTable0, checkLevel0);
    processClosurePrimitives0.process(node0, node0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test01() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""goog.base"");
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    PreprocessorSymbolTable preprocessorSymbolTable0 = new PreprocessorSymbolTable(node0);
    ProcessClosurePrimitives processClosurePrimitives0 = new ProcessClosurePrimitives(compiler0, preprocessorSymbolTable0, checkLevel0);
    processClosurePrimitives0.process(node0, node0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"static Node parseAndNormalizeTestCode(AbstractCompiler compiler, String code) {
    Node js = compiler.parseTestCode(code);
    NodeTraversal.traverse(compiler, js, new Normalize.NormalizeStatements(compiler, false));
    NodeTraversal.traverse(compiler, js, new MakeDeclaredNamesUnique());
    return js;
}","public void test12() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.newCompilerOptions();
    // Undeclared exception!
    try {
        Normalize.parseAndNormalizeTestCode(compiler0, ""// Input %num%"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Multiple entries with same key: author=NOT_IMPLEMENTED and author=AUTHOR
        //
        verifyException(""com.google.common.collect.ImmutableMap"", e);
    }
}",""
"public int getLineno() {
    return extractLineno(sourcePosition);
}","public void test34() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR"");
    CheckLevel checkLevel0 = CheckLevel.OFF;
    ProcessClosurePrimitives processClosurePrimitives0 = new ProcessClosurePrimitives(compiler0, (PreprocessorSymbolTable) null, checkLevel0);
    processClosurePrimitives0.process(node0, node0);
    assertEquals(1, node0.getLineno());
}",""
"public boolean hasMoreThanOneChild() {
    return first != null && first != last;
}","public void test45() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(37, 37, 37);
    Node node1 = new Node(37, node0, node0, node0);
    PreprocessorSymbolTable preprocessorSymbolTable0 = new PreprocessorSymbolTable(node0);
    CheckLevel checkLevel0 = CheckLevel.ERROR;
    ProcessClosurePrimitives processClosurePrimitives0 = new ProcessClosurePrimitives(compiler0, preprocessorSymbolTable0, checkLevel0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, processClosurePrimitives0);
    processClosurePrimitives0.visit(nodeTraversal0, node1, node0);
    assertFalse(node1.hasMoreThanOneChild());
}","/**
 * Check for more than one child more efficiently than by iterating over all
 * the children as is done with Node.getChildCount().
 *
 * @return Whether the node more than one child.
 */"
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) {
        c++;
    }
    return c;
}","public void test56() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    Node node0 = new Node(105);
    ProcessClosurePrimitives processClosurePrimitives0 = new ProcessClosurePrimitives(compiler0, (PreprocessorSymbolTable) null, compilerOptions0.brokenClosureRequiresLevel);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, processClosurePrimitives0);
    Node node1 = new Node(43, node0, node0, node0, 0, 1);
    processClosurePrimitives0.visit(nodeTraversal0, node0, node0);
    assertEquals(0, node0.getChildCount());
}",""
"public boolean isGetElem() {
    return this.getType() == Token.GETELEM;
}","public void test67() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""msg.invalid.iterator"");
    CheckLevel checkLevel0 = CheckLevel.ERROR;
    PreprocessorSymbolTable preprocessorSymbolTable0 = new PreprocessorSymbolTable(node0);
    ProcessClosurePrimitives processClosurePrimitives0 = new ProcessClosurePrimitives(compiler0, preprocessorSymbolTable0, checkLevel0);
    processClosurePrimitives0.process(node0, node0);
    assertFalse(node0.isGetElem());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.CALL:
            boolean isExpr = parent.isExprResult();
            Node left = n.getFirstChild();
            if (left.isGetProp()) {
                Node name = left.getFirstChild();
                if (name.isName() && GOOG.equals(name.getString())) {
                    // For the sake of simplicity, we report code changes
                    // when we see a provides/requires, and don't worry about
                    // reporting the change when we actually do the replacement.
                    String methodName = name.getNext().getString();
                    if (""base"".equals(methodName)) {
                        processBaseClassCall(t, n);
                    } else if (!isExpr) {
                        // All other methods must be called in an EXPR.
                        break;
                    } else if (""define"".equals(methodName)) {
                        processDefineCall(t, n, parent);
                    } else if (""require"".equals(methodName)) {
                        processRequireCall(t, n, parent);
                    } else if (""provide"".equals(methodName)) {
                        processProvideCall(t, n, parent);
                    } else if (""exportSymbol"".equals(methodName)) {
                        Node arg = left.getNext();
                        if (arg.isString()) {
                            int dot = arg.getString().indexOf('.');
                            if (dot == -1) {
                                exportedVariables.add(arg.getString());
                            } else {
                                exportedVariables.add(arg.getString().substring(0, dot));
                            }
                        }
                    } else if (""addDependency"".equals(methodName)) {
                        CodingConvention convention = compiler.getCodingConvention();
                        List<String> typeDecls = convention.identifyTypeDeclarationCall(n);
                        if (typeDecls != null) {
                            for (String typeDecl : typeDecls) {
                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);
                            }
                        }
                        // We can't modify parent, so just create a node that will
                        // get compiled out.
                        parent.replaceChild(n, IR.number(0));
                        compiler.reportCodeChange();
                    } else if (""setCssNameMapping"".equals(methodName)) {
                        processSetCssNameMapping(t, n, parent);
                    }
                }
            }
            break;
        case Token.ASSIGN:
        case Token.NAME:
            // If this is an assignment to a provided name, remove the provided
            // object.
            handleCandidateProvideDefinition(t, n, parent);
            break;
        case Token.EXPR_RESULT:
            handleTypedefDefinition(t, n);
            break;
        case Token.FUNCTION:
            // If this is a declaration of a provided named function, this is an
            // error. Hoisted functions will explode if they're provided.
            if (t.inGlobalScope() && !NodeUtil.isFunctionExpression(n)) {
                String name = n.getFirstChild().getString();
                ProvidedName pn = providedNames.get(name);
                if (pn != null) {
                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));
                }
            }
            break;
        case Token.GETPROP:
            if (n.getFirstChild().isName() && !parent.isCall() && !parent.isAssign() && ""goog.base"".equals(n.getQualifiedName())) {
                reportBadBaseClassUse(t, n, ""May only be called directly."");
            }
            break;
    }
}","public void test78() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    Node node0 = new Node(86);
    ProcessClosurePrimitives processClosurePrimitives0 = new ProcessClosurePrimitives(compiler0, (PreprocessorSymbolTable) null, compilerOptions0.checkMissingReturn);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, processClosurePrimitives0);
    processClosurePrimitives0.visit(nodeTraversal0, node0, node0);
    assertEquals(54, Node.SLASH_V);
}",""
