focal_method,test_prefix,docstring
"@VisibleForTesting
static Node getBoilerplateCode(AbstractCompiler compiler, @Nullable String logFunction) {
    String boilerplateCode;
    try {
        boilerplateCode = CharStreams.toString(new InputStreamReader(RuntimeTypeCheck.class.getResourceAsStream(""js/runtime_type_check.js""), Charsets.UTF_8));
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
    boilerplateCode = boilerplateCode.replace(""%%LOG%%"", logFunction == null ? ""function(warning, expr) {}"" : logFunction);
    return Normalize.parseAndNormalizeSyntheticCode(compiler, boilerplateCode, ""jscomp_runtimeTypeCheck_"");
}","public void test000() throws Throwable {
    // Undeclared exception!
    try {
        RuntimeTypeCheck.getBoilerplateCode((AbstractCompiler) null, """");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Normalize"", e);
    }
}",""
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""+"", ""+"");
    Node node1 = new Node(15, node0);
    Normalize normalize0 = new Normalize(compiler0, true);
    normalize0.process(node0, node0);
    normalize0.process(node0, node0);
    assertEquals((-1), node0.getCharno());
}",""
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test022() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""function ySCompile_emptyFn() {  return function() {}}"", ""function ySCompile_emptyFn() {  return function() {}}"");
    Normalize.PropagateConstantAnnotationsOverVars normalize_PropagateConstantAnnotationsOverVars0 = new Normalize.PropagateConstantAnnotationsOverVars(compiler0, true);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) normalize_PropagateConstantAnnotationsOverVars0);
    assertEquals(7, Node.LOCAL_PROP);
}","/**
 * Traverses a node recursively.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test033() throws Throwable {
    Compiler compiler0 = new Compiler();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    compiler0.defaultCodingConvention = (CodingConvention) googleCodingConvention0;
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""S_AT7H_BOCK_VAR_ERROR"", ""Igj@6Ysuo(5I"");
    Normalize.PropagateConstantAnnotationsOverVars normalize_PropagateConstantAnnotationsOverVars0 = new Normalize.PropagateConstantAnnotationsOverVars(compiler0, true);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) normalize_PropagateConstantAnnotationsOverVars0);
    assertEquals(41, Node.SIDE_EFFECT_FLAGS);
}","/**
 * Traverses a node recursively.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test044() throws Throwable {
    Compiler compiler0 = new Compiler();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    compiler0.defaultCodingConvention = (CodingConvention) googleCodingConvention0;
    Normalize.PropagateConstantAnnotationsOverVars normalize_PropagateConstantAnnotationsOverVars0 = new Normalize.PropagateConstantAnnotationsOverVars(compiler0, true);
    Node node0 = compiler0.parseSyntheticCode(""S_AT7H_BOCK_VAR_ERROR"", ""S_AT7H_BOCK_VAR_ERROR"");
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) normalize_PropagateConstantAnnotationsOverVars0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test055() throws Throwable {
    Compiler compiler0 = new Compiler();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    compiler0.defaultCodingConvention = (CodingConvention) googleCodingConvention0;
    Normalize.PropagateConstantAnnotationsOverVars normalize_PropagateConstantAnnotationsOverVars0 = new Normalize.PropagateConstantAnnotationsOverVars(compiler0, false);
    Node node0 = compiler0.parseSyntheticCode(""S_AT7H_BOCK_VAR_ERROR"", ""S_AT7H_BOCK_VAR_ERROR"");
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) normalize_PropagateConstantAnnotationsOverVars0);
    assertEquals(32, Node.MEMBER_TYPE_PROP);
}","/**
 * Traverses a node recursively.
 */"
"public boolean isOnlyModifiesThisCall() {
    return areBitFlagsSet(getSideEffectFlags() & Node.NO_SIDE_EFFECTS, Node.FLAG_GLOBAL_STATE_UNMODIFIED | Node.FLAG_ARGUMENTS_UNMODIFIED | Node.FLAG_NO_THROWS);
}","public void test088() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""function JSCompiler_emptyFn() {  return function() {}}"", ""function JSCompiler_emptyFn() {  return function() {}}"");
    Normalize.VerifyConstants normalize_VerifyConstants0 = new Normalize.VerifyConstants(compiler0, true);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) normalize_VerifyConstants0);
    assertFalse(node0.isOnlyModifiesThisCall());
}","/**
 * @return Whether the only side-effect is ""modifies this""
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""L"", ""L"");
    Normalize.VerifyConstants normalize_VerifyConstants0 = new Normalize.VerifyConstants(compiler0, false);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) normalize_VerifyConstants0);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) normalize_VerifyConstants0);
    assertEquals(22, Node.TARGETBLOCK_PROP);
}","/**
 * Traverses a node recursively.
 */"
"public boolean isVarArgs() {
    return getBooleanProp(VAR_ARGS_NAME);
}","public void test1010() throws Throwable {
    Compiler compiler0 = new Compiler();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    compiler0.defaultCodingConvention = (CodingConvention) googleCodingConvention0;
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""JSC_CATCH_BLOCK_VAR_ERROR"", ""JSC_CATCH_BLOCK_VAR_ERROR"");
    Normalize.VerifyConstants normalize_VerifyConstants0 = new Normalize.VerifyConstants(compiler0, true);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) normalize_VerifyConstants0);
    assertFalse(node0.isVarArgs());
}","/**
 * Returns whether this node is a variable length argument node. This
 * method's return value is meaningful only on {@link Token#NAME} nodes
 * used to define a {@link Token#FUNCTION}'s argument list.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test1111() throws Throwable {
    Compiler compiler0 = new Compiler();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    compiler0.defaultCodingConvention = (CodingConvention) googleCodingConvention0;
    Normalize.parseAndNormalizeTestCode(compiler0, ""JSC_CATCH_BLOCK_VAR_ERYO"", ""JSC_CATCH_BLOCK_VAR_ERYO"");
    Normalize.VerifyConstants normalize_VerifyConstants0 = new Normalize.VerifyConstants(compiler0, true);
    Node node0 = compiler0.parseSyntheticCode(""JSC_CATCH_BLOCK_VAR_ERYO"");
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) normalize_VerifyConstants0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // The name JSC_CATCH_BLOCK_VAR_ERYO is not annotated as constant.
        //   Node(NAME JSC_CATCH_BLOCK_VAR_ERYO):  [synthetic] :1:0
        // [source unknown]
        //   Parent(EXPR_RESULT):  [synthetic] :1:0
        // [source unknown]
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"public int getSideEffectFlags() {
    return getIntProp(SIDE_EFFECT_FLAGS);
}","public void test1212() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""L"", ""L"");
    Normalize.VerifyConstants normalize_VerifyConstants0 = new Normalize.VerifyConstants(compiler0, true);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) normalize_VerifyConstants0);
    assertEquals(0, node0.getSideEffectFlags());
}","/**
 * Returns the side effects flags for this node.
 */"
"public boolean isUnscopedQualifiedName() {
    switch(getType()) {
        case Token.NAME:
            return true;
        case Token.GETPROP:
            return getFirstChild().isUnscopedQualifiedName();
        default:
            return false;
    }
}","public void test1313() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""com.google.javascript.jscomp.Normalize$DuplicateDeclarationHandler"", ""com.google.javascript.jscomp.Normalize$DuplicateDeclarationHandler"");
    assertFalse(node0.isUnscopedQualifiedName());
}","/**
 * Returns whether a node corresponds to a simple or a qualified name without
 * a ""this"" reference, such as <code>a.b.c</code>, but not <code>this.a</code>
 * .
 */"
"@Override
public void process(Node externs, Node root) {
    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    //   function f() {
    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    //      var e = 1; // f scope 'e'
    //   }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    removeDuplicateDeclarations(externs, root);
    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);
    if (!compiler.getLifeCycleStage().isNormalized()) {
        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
}","public void test1414() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(147);
    Normalize normalize0 = new Normalize(compiler0, true);
    // Undeclared exception!
    try {
        normalize0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"@Override
public void process(Node externs, Node root) {
    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    //   function f() {
    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    //      var e = 1; // f scope 'e'
    //   }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    removeDuplicateDeclarations(externs, root);
    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);
    if (!compiler.getLifeCycleStage().isNormalized()) {
        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
}","public void test1515() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(148, 148, 148);
    Normalize normalize0 = new Normalize(compiler0, false);
    // Undeclared exception!
    try {
        normalize0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"static Node parseAndNormalizeTestCode(AbstractCompiler compiler, String code, String prefix) {
    Node js = compiler.parseTestCode(code);
    NodeTraversal.traverse(compiler, js, new Normalize.NormalizeStatements(compiler, false));
    NodeTraversal.traverse(compiler, js, new MakeDeclaredNamesUnique());
    return js;
}","public void test1616() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED_OBFUSCATED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""com.google.javascript.jscomp.Normalize$DuplicateDeclarationHandler"", ""com.google.javascript.jscomp.Normalize$DuplicateDeclarationHandler"");
    assertEquals(36, Node.OPT_ARG_NAME);
}",""
"@Override
public void process(Node externs, Node root) {
    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    //   function f() {
    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    //      var e = 1; // f scope 'e'
    //   }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    removeDuplicateDeclarations(externs, root);
    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);
    if (!compiler.getLifeCycleStage().isNormalized()) {
        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
}","public void test1717() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""=Q"");
    Node node1 = new Node(31, node0, node0, node0, node0, 49, 0);
    Normalize normalize0 = new Normalize(compiler0, true);
    // Undeclared exception!
    try {
        normalize0.process(node1, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    //   function f() {
    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    //      var e = 1; // f scope 'e'
    //   }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    removeDuplicateDeclarations(externs, root);
    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);
    if (!compiler.getLifeCycleStage().isNormalized()) {
        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
}","public void test1818() throws Throwable {
    Compiler compiler0 = new Compiler();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    compiler0.defaultCodingConvention = (CodingConvention) googleCodingConvention0;
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""JSC_CATCH_BLOCK_VAR_ERRO"", ""JSC_CATCH_BLOCK_VAR_ERRO"");
    Normalize normalize0 = new Normalize(compiler0, true);
    // Undeclared exception!
    try {
        normalize0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    //   function f() {
    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    //      var e = 1; // f scope 'e'
    //   }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    removeDuplicateDeclarations(externs, root);
    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);
    if (!compiler.getLifeCycleStage().isNormalized()) {
        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
}","public void test1919() throws Throwable {
    Compiler compiler0 = new Compiler();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    compiler0.defaultCodingConvention = (CodingConvention) googleCodingConvention0;
    Normalize normalize0 = new Normalize(compiler0, true);
    Node node0 = compiler0.parseTestCode(""S_AT7H_OCK_VAR_ERROR"");
    // Undeclared exception!
    try {
        normalize0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // Unexpected const change.
        //   name: S_AT7H_OCK_VAR_ERROR
        //   parent:EXPR_RESULT 1 [sourcename: java.lang.String@0000000447]
        //     NAME S_AT7H_OCK_VAR_ERROR 1 [sourcename: java.lang.String@0000000447]
        //
        //   Node(NAME S_AT7H_OCK_VAR_ERROR):  [testcode] :1:0
        // [source unknown]
        //   Parent(EXPR_RESULT):  [testcode] :1:0
        // [source unknown]
        //
        verifyException(""com.google.javascript.jscomp.Normalize$NormalizeStatements"", e);
    }
}",""
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test2020() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""c*/V"", ""c*/V"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, true);
    node0.setType(113);
    Node node1 = new Node(126, node0, node0, 15, 40);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // The existing child node of the parent should not be null.
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test2121() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Fove function dwclaration ot a^ top of untion"", ""Fove function dwclaration ot a^ top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, true);
    node0.setType(114);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(2, Node.ATTRIBUTE_FLAG);
}","/**
 * Traverses a node recursively.
 */"
"public boolean hasMoreThanOneChild() {
    return first != null && first != last;
}","public void test2222() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""ANu:S2G"", ""ANu:S2G"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(115);
    Node node1 = new Node(126, node0, node0, 1, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertTrue(node1.hasMoreThanOneChild());
}","/**
 * Check for more than one child more efficiently than by iterating over all
 * the children as is done with Node.getChildCount().
 *
 * @return Whether the node more than one child.
 */"
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test2223() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""ANu:S2G"", ""ANu:S2G"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(115);
    Node node1 = new Node(126, node0, node0, 1, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(2, node1.getChildCount());
}",""
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test2324() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""ANu:S2G"", ""ANu:S2G"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, true);
    node0.setType(116);
    Node node1 = new Node(126, node0, node0, 1, 40);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // Normalize constraints violated:
        // LABEL normalization
        //
        verifyException(""com.google.javascript.jscomp.Normalize$NormalizeStatements"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"public int getLineno() {
    return extractLineno(sourcePosition);
}","public void test2425() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Move function dwclaration not at top of untion"", ""Move function dwclaration not at top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(117);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(15, node1.getLineno());
}",""
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test2426() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Move function dwclaration not at top of untion"", ""Move function dwclaration not at top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(117);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(1, node1.getChildCount());
}",""
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test2427() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Move function dwclaration not at top of untion"", ""Move function dwclaration not at top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(117);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertTrue(node1.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test2528() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""(WA?"", ""(WA?"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(119);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(1, node1.getChildCount());
}",""
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test2529() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""(WA?"", ""(WA?"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(119);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertFalse(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"public boolean hasMoreThanOneChild() {
    return first != null && first != last;
}","public void test2530() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""(WA?"", ""(WA?"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(119);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertFalse(node1.hasMoreThanOneChild());
}","/**
 * Check for more than one child more efficiently than by iterating over all
 * the children as is done with Node.getChildCount().
 *
 * @return Whether the node more than one child.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test2631() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Move function dwclaration not at top of untion"", ""Move function dwclaration not at top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, true);
    node0.setType(120);
    Node node1 = new Node(126, node0, node0, 15, 40);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // Normalize constraints violated:
        // LABEL normalization
        //
        verifyException(""com.google.javascript.jscomp.Normalize$NormalizeStatements"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test2732() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Move function dwclaration not at top of untion"", ""Move function dwclaration not at top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(121);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(1, node1.getChildCount());
}",""
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test2733() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Move function dwclaration not at top of untion"", ""Move function dwclaration not at top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(121);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(40, node1.getCharno());
}",""
"public int getLineno() {
    return extractLineno(sourcePosition);
}","public void test2734() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Move function dwclaration not at top of untion"", ""Move function dwclaration not at top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(121);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(15, node1.getLineno());
}",""
"public boolean hasChildren() {
    return first != null;
}","public void test2835() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""May onlB lend proerties to bject types. X0} has type {1}."", ""May onlB lend proerties to bject types. X0} has type {1}."");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(122);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertFalse(node0.hasChildren());
}",""
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test2836() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""May onlB lend proerties to bject types. X0} has type {1}."", ""May onlB lend proerties to bject types. X0} has type {1}."");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(122);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(1, node1.getChildCount());
}",""
"public boolean hasMoreThanOneChild() {
    return first != null && first != last;
}","public void test2837() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""May onlB lend proerties to bject types. X0} has type {1}."", ""May onlB lend proerties to bject types. X0} has type {1}."");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(122);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertFalse(node1.hasMoreThanOneChild());
}","/**
 * Check for more than one child more efficiently than by iterating over all
 * the children as is done with Node.getChildCount().
 *
 * @return Whether the node more than one child.
 */"
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test2938() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""\""{0}\"" is not a falid JS property nBme"", ""\""{0}\"" is not a falid JS property nBme"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(123);
    Node node1 = new Node(126, node0, node0, 5, 24);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(24, node1.getCharno());
}",""
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test2939() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""\""{0}\"" is not a falid JS property nBme"", ""\""{0}\"" is not a falid JS property nBme"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(123);
    Node node1 = new Node(126, node0, node0, 5, 24);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertFalse(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"public boolean hasChildren() {
    return first != null;
}","public void test2940() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""\""{0}\"" is not a falid JS property nBme"", ""\""{0}\"" is not a falid JS property nBme"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(123);
    Node node1 = new Node(126, node0, node0, 5, 24);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertFalse(node0.hasChildren());
}",""
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test3041() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Fove function dwclaration ot at top of untion"", ""Fove function dwclaration ot at top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(124);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(1, node1.getChildCount());
}",""
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test3042() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Fove function dwclaration ot at top of untion"", ""Fove function dwclaration ot at top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(124);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertFalse(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"public int getLineno() {
    return extractLineno(sourcePosition);
}","public void test3043() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Fove function dwclaration ot at top of untion"", ""Fove function dwclaration ot at top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(124);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(15, node1.getLineno());
}",""
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test3044() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Fove function dwclaration ot at top of untion"", ""Fove function dwclaration ot at top of untion"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(124);
    Node node1 = new Node(126, node0, node0, 15, 40);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(40, node1.getCharno());
}",""
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test3145() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""f/)K"", ""f/)K"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(126);
    Node node1 = new Node(126, node0, node0, 6, 41);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Traverses a node recursively.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test3246() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""%yX!!Ld^i"", ""%yX!!Ld^i"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, true);
    node0.setType(118);
    Node node1 = new Node(125, node0, node0, 140, 2);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) normalize_NormalizeStatements0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // Empty VAR node.
        //
        verifyException(""com.google.javascript.jscomp.Normalize$NormalizeStatements"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test3347() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""%yX!!Ld^i"", ""%yX!!Ld^i"");
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, true);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Vector<JSType> vector0 = new Vector<JSType>();
    Node node1 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) vector0);
    node0.addChildToFront(node1);
    node0.setType(118);
    Node node2 = new Node(125, node0, node0, 140, 2);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node2, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertEquals(29, Node.VAR_ARGS_NAME);
}","/**
 * Traverses a node recursively.
 */"
"public boolean hasMoreThanOneChild() {
    return first != null && first != last;
}","public void test3448() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Str%ig"", ""Str%ig"");
    Node node1 = compiler0.parseTestCode(""Str%ig"");
    node0.addChildToBack(node1);
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(118);
    Node node2 = new Node(126, node0, node0, 5, 24);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node2, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertFalse(node0.hasMoreThanOneChild());
}","/**
 * Check for more than one child more efficiently than by iterating over all
 * the children as is done with Node.getChildCount().
 *
 * @return Whether the node more than one child.
 */"
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test3449() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""Str%ig"", ""Str%ig"");
    Node node1 = compiler0.parseTestCode(""Str%ig"");
    node0.addChildToBack(node1);
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, false);
    node0.setType(118);
    Node node2 = new Node(126, node0, node0, 5, 24);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node2, (NodeTraversal.Callback) normalize_NormalizeStatements0);
    assertTrue(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"@Override
public void process(Node externs, Node root) {
    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    //   function f() {
    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    //      var e = 1; // f scope 'e'
    //   }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    removeDuplicateDeclarations(externs, root);
    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);
    if (!compiler.getLifeCycleStage().isNormalized()) {
        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
}","public void test3550() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    Node node1 = new Node(105, node0, node0, 2, 1);
    node0.addChildrenToFront(node1);
    Normalize normalize0 = new Normalize(compiler0, true);
    // Undeclared exception!
    try {
        normalize0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //   Node(FUNCTION ):  [testcode] :2:1
        // [source unknown]
        //   Parent(SCRIPT):  [testcode] :1:0
        // [source unknown]
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
