focal_method,test_prefix,docstring
"public boolean isNativeObjectType() {
    return false;
}","public void test000() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ObjectType objectType0 = errorFunctionType0.getInstanceType();
    boolean boolean0 = objectType0.matchesObjectContext();
    assertTrue(objectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"public boolean hasReferenceName() {
    return false;
}","public void test001() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ObjectType objectType0 = errorFunctionType0.getInstanceType();
    boolean boolean0 = objectType0.matchesObjectContext();
    assertFalse(objectType0.hasReferenceName());
}","/**
 * Returns true if the object is named.
 * @return true if the object is named, false if it is anonymous
 */"
"public boolean matchesObjectContext() {
    return false;
}","public void test002() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ObjectType objectType0 = errorFunctionType0.getInstanceType();
    boolean boolean0 = objectType0.matchesObjectContext();
    assertTrue(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in an
 * {@code Object} context, such as the expression in a with statement.
 *
 * Most types we will encounter, except notably {@code null}, have at least
 * the potential for converting to {@code Object}.  Host defined objects can
 * get peculiar.
 */"
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test013() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.canBeCalled();
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test014() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.canBeCalled();
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test025() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.NullType"", (Node) null);
    ImmutableList<ObjectType> immutableList0 = ImmutableList.of((ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0);
    functionType0.setExtendedInterfaces(immutableList0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    instanceObjectType0.getSlot(""Unknown class name"");
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test026() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.NullType"", (Node) null);
    ImmutableList<ObjectType> immutableList0 = ImmutableList.of((ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0);
    functionType0.setExtendedInterfaces(immutableList0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    instanceObjectType0.getSlot(""Unknown class name"");
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) {
    if (hasOwnDeclaredProperty(name)) {
        return false;
    }
    Property newProp = new Property(name, type, inferred, propertyNode);
    Property oldProp = properties.get(name);
    if (oldProp != null) {
        // This is to keep previously inferred JsDoc info, e.g., in a
        // replaceScript scenario.
        newProp.setJSDocInfo(oldProp.getJSDocInfo());
    }
    properties.put(name, newProp);
    return true;
}","public void test037() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, """", unknownType0);
    boolean boolean0 = prototypeObjectType0.defineProperty(""P~)&Bnz"", (JSType) null, false, (Node) null);
    assertTrue(boolean0);
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test038() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, """", unknownType0);
    boolean boolean0 = prototypeObjectType0.defineProperty(""P~)&Bnz"", (JSType) null, false, (Node) null);
    int int0 = prototypeObjectType0.getPropertiesCount();
    assertFalse(prototypeObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test039() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, """", unknownType0);
    boolean boolean0 = prototypeObjectType0.defineProperty(""P~)&Bnz"", (JSType) null, false, (Node) null);
    int int0 = prototypeObjectType0.getPropertiesCount();
    assertTrue(prototypeObjectType0.hasReferenceName());
}",""
"@Override
public int getPropertiesCount() {
    ObjectType implicitPrototype = getImplicitPrototype();
    if (implicitPrototype == null) {
        return this.properties.size();
    }
    int localCount = 0;
    for (String property : properties.keySet()) {
        if (!implicitPrototype.hasProperty(property)) {
            localCount++;
        }
    }
    return implicitPrototype.getPropertiesCount() + localCount;
}","public void test0310() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, """", unknownType0);
    boolean boolean0 = prototypeObjectType0.defineProperty(""P~)&Bnz"", (JSType) null, false, (Node) null);
    int int0 = prototypeObjectType0.getPropertiesCount();
    assertEquals(Integer.MAX_VALUE, int0);
}","/**
 * Gets the number of properties of this object.
 */"
"@Override
public int getPropertiesCount() {
    ObjectType implicitPrototype = getImplicitPrototype();
    if (implicitPrototype == null) {
        return this.properties.size();
    }
    int localCount = 0;
    for (String property : properties.keySet()) {
        if (!implicitPrototype.hasProperty(property)) {
            localCount++;
        }
    }
    return implicitPrototype.getPropertiesCount() + localCount;
}","public void test0411() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""{"");
    Node node0 = Node.newNumber(3823.8162115272617, 0, 0);
    errorFunctionType0.defineSynthesizedProperty(""{"", (JSType) null, node0);
    int int0 = errorFunctionType0.getPropertiesCount();
    assertEquals(1, int0);
}","/**
 * Gets the number of properties of this object.
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test0412() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""{"");
    Node node0 = Node.newNumber(3823.8162115272617, 0, 0);
    errorFunctionType0.defineSynthesizedProperty(""{"", (JSType) null, node0);
    int int0 = errorFunctionType0.getPropertiesCount();
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"public boolean hasReferenceName() {
    return false;
}","public void test0513() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ObjectType objectType0 = errorFunctionType0.getTopMostDefiningType(""Unknown class name"");
    assertFalse(objectType0.hasReferenceName());
}","/**
 * Returns true if the object is named.
 * @return true if the object is named, false if it is anonymous
 */"
"public boolean isNativeObjectType() {
    return false;
}","public void test0514() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ObjectType objectType0 = errorFunctionType0.getTopMostDefiningType(""Unknown class name"");
    assertTrue(objectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test0615() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""NOT_NULL"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""NOT_NULL"", jSDocInfo0);
    errorFunctionType0.matchRecordTypeConstraint(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test0716() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "": "");
    FunctionType functionType0 = errorFunctionType0.cloneWithoutArrowType();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""Named type with empty name component"", jSDocInfo0);
    functionType0.matchRecordTypeConstraint(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean defineSynthesizedProperty(String propertyName, JSType type, Node propertyNode) {
    return defineProperty(propertyName, type, false, propertyNode);
}","public void test0817() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""{"");
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, errorFunctionType0, errorFunctionType0);
    Node node0 = Node.newNumber(3823.8162115272617, 0, 0);
    boolean boolean0 = errorFunctionType0.defineSynthesizedProperty(""{"", (JSType) null, node0);
    assertTrue(boolean0);
}","/**
 * Defines a property whose type is on a synthesized object. These objects
 * don't actually exist in the user's program. They're just used for
 * bookkeeping in the type system.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test0818() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""{"");
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, errorFunctionType0, errorFunctionType0);
    Node node0 = Node.newNumber(3823.8162115272617, 0, 0);
    boolean boolean0 = errorFunctionType0.defineSynthesizedProperty(""{"", (JSType) null, node0);
    errorFunctionType0.matchRecordTypeConstraint(indexedType0);
    assertFalse(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasReferenceName() {
    return referencedObjType == null ? null : referencedObjType.hasReferenceName();
}","public void test0819() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""{"");
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, errorFunctionType0, errorFunctionType0);
    Node node0 = Node.newNumber(3823.8162115272617, 0, 0);
    boolean boolean0 = errorFunctionType0.defineSynthesizedProperty(""{"", (JSType) null, node0);
    errorFunctionType0.matchRecordTypeConstraint(indexedType0);
    assertTrue(indexedType0.hasReferenceName());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test0820() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""{"");
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, errorFunctionType0, errorFunctionType0);
    Node node0 = Node.newNumber(3823.8162115272617, 0, 0);
    boolean boolean0 = errorFunctionType0.defineSynthesizedProperty(""{"", (JSType) null, node0);
    errorFunctionType0.matchRecordTypeConstraint(indexedType0);
    assertTrue(indexedType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test0921() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.getPropertyNames();
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test0922() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.getPropertyNames();
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
void collectPropertyNames(Set<String> props) {
    for (String prop : properties.keySet()) {
        props.add(prop);
    }
    ObjectType implicitPrototype = getImplicitPrototype();
    if (implicitPrototype != null) {
        implicitPrototype.collectPropertyNames(props);
    }
}","public void test1023() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    ImmutableList<JSType> immutableList0 = ImmutableList.of((JSType) stringType0);
    Node node0 = jSTypeRegistry0.createParameters((List<JSType>) immutableList0);
    EnumType enumType0 = new EnumType(jSTypeRegistry0, """", node0, stringType0);
    enumType0.defineProperty(""iX<K"", stringType0, false, node0);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    Set<String> set0 = jSDocInfo0.getSuppressions();
    // Undeclared exception!
    try {
        enumType0.collectPropertyNames(set0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.AbstractCollection"", e);
    }
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test1124() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) recordType0, (Node) null);
    boolean boolean0 = functionType0.defineProperty("", "", recordType0, false, (Node) null);
    boolean boolean1 = functionType0.isPropertyTypeInferred("", "");
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean isPropertyTypeInferred(String property) {
    StaticSlot<JSType> slot = getSlot(property);
    if (slot == null) {
        return false;
    }
    return slot.isTypeInferred();
}","public void test1125() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) recordType0, (Node) null);
    boolean boolean0 = functionType0.defineProperty("", "", recordType0, false, (Node) null);
    boolean boolean1 = functionType0.isPropertyTypeInferred("", "");
    assertFalse(boolean1 == boolean0);
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test1126() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) recordType0, (Node) null);
    boolean boolean0 = functionType0.defineProperty("", "", recordType0, false, (Node) null);
    boolean boolean1 = functionType0.isPropertyTypeInferred("", "");
    assertFalse(recordType0.hasReferenceName());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test1228() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""com.google.common.collect.Iterators$3"");
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean isPropertyTypeInferred(String property) {
    StaticSlot<JSType> slot = getSlot(property);
    if (slot == null) {
        return false;
    }
    return slot.isTypeInferred();
}","public void test1229() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""com.google.common.collect.Iterators$3"");
    assertFalse(boolean0);
}",""
"@Override
public boolean isPropertyInExterns(String propertyName) {
    Property p = properties.get(propertyName);
    if (p != null) {
        return p.isFromExterns();
    }
    ObjectType implicitPrototype = getImplicitPrototype();
    if (implicitPrototype != null) {
        return implicitPrototype.isPropertyInExterns(propertyName);
    }
    return false;
}","public void test1330() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""<45KY2"");
    boolean boolean0 = errorFunctionType0.isPropertyInExterns(""<45KY2"");
    assertFalse(boolean0);
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test1331() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""<45KY2"");
    boolean boolean0 = errorFunctionType0.isPropertyInExterns(""<45KY2"");
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1432() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""NOT_NULL"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""NOT_NULL"", jSDocInfo0);
    errorFunctionType0.isPropertyInExterns(""NOT_NULL"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test1533() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, false);
    boolean boolean0 = recordType0.removeProperty(""Not declared as a constructor"");
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean removeProperty(String name) {
    return properties.remove(name) != null;
}","public void test1534() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, false);
    boolean boolean0 = recordType0.removeProperty(""Not declared as a constructor"");
    assertFalse(boolean0);
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test1535() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, false);
    boolean boolean0 = recordType0.removeProperty(""Not declared as a constructor"");
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1636() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""Not declared as a type name"", jSDocInfo0);
    boolean boolean0 = errorFunctionType0.removeProperty(""Not declared as a type name"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean removeProperty(String name) {
    return properties.remove(name) != null;
}","public void test1637() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""Not declared as a type name"", jSDocInfo0);
    boolean boolean0 = errorFunctionType0.removeProperty(""Not declared as a type name"");
    assertTrue(boolean0);
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test1738() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.getPropertyNode(""BOOLEAN_TYPE"");
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test1739() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.getPropertyNode(""BOOLEAN_TYPE"");
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1840() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""NOT_NULL"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""NOT_NULL"", jSDocInfo0);
    errorFunctionType0.getPropertyNode(""NOT_NULL"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test1941() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "": "");
    errorFunctionType0.getOwnPropertyJSDocInfo("": "");
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test2042() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""Named type with empty name component"", jSDocInfo0);
    errorFunctionType0.getOwnPropertyJSDocInfo(""Named type with empty name component"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test2143() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""N4Qjq4W"");
    errorFunctionType0.setPropertyJSDocInfo(""Not declared as a constructor"", (JSDocInfo) null);
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test2144() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""N4Qjq4W"");
    errorFunctionType0.setPropertyJSDocInfo(""Not declared as a constructor"", (JSDocInfo) null);
    assertFalse(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test2245() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""$(aB,.q2I"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""$(aB,.q2I"", jSDocInfo0);
    errorFunctionType0.setPropertyJSDocInfo(""$(aB,.q2I"", jSDocInfo0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test2346() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.setPropertyJSDocInfo(""^Dke V~@5)kWy#u"", jSDocInfo0);
    assertTrue(recordType0.hasCachedValues());
}",""
"@Override
public boolean matchesStringContext() {
    return isTheObjectType() || isStringObjectType() || isDateType() || isRegexpType() || isArrayType() || isNumberObjectType() || isBooleanObjectType() || hasOverridenNativeProperty(""toString"");
}","public void test2447() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""C|PDOa^Q-bG#"");
    FunctionType functionType0 = errorFunctionType0.getSuperClassConstructor();
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = instanceObjectType0.matchesStringContext();
    assertTrue(boolean0);
}",""
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test2448() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""C|PDOa^Q-bG#"");
    FunctionType functionType0 = errorFunctionType0.getSuperClassConstructor();
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = instanceObjectType0.matchesStringContext();
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test2549() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) numberType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.matchesStringContext();
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean matchesStringContext() {
    return isTheObjectType() || isStringObjectType() || isDateType() || isRegexpType() || isArrayType() || isNumberObjectType() || isBooleanObjectType() || hasOverridenNativeProperty(""toString"");
}","public void test2550() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) numberType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.matchesStringContext();
    assertTrue(boolean0);
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test2651() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, true);
    Node node0 = Node.newNumber((double) 1);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(recordType0, node0);
    hashMap0.put(""toString"", recordTypeBuilder_RecordProperty0);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = recordType1.matchesStringContext();
    assertFalse(recordType1.hasReferenceName());
}",""
"@Override
public boolean matchesStringContext() {
    return isTheObjectType() || isStringObjectType() || isDateType() || isRegexpType() || isArrayType() || isNumberObjectType() || isBooleanObjectType() || hasOverridenNativeProperty(""toString"");
}","public void test2652() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0, true);
    Node node0 = Node.newNumber((double) 1);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(recordType0, node0);
    hashMap0.put(""toString"", recordTypeBuilder_RecordProperty0);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = recordType1.matchesStringContext();
    assertTrue(boolean0);
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test2753() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    boolean boolean0 = functionType0.matchesStringContext();
    assertTrue(functionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean matchesStringContext() {
    return isTheObjectType() || isStringObjectType() || isDateType() || isRegexpType() || isArrayType() || isNumberObjectType() || isBooleanObjectType() || hasOverridenNativeProperty(""toString"");
}","public void test2754() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    boolean boolean0 = functionType0.matchesStringContext();
    assertFalse(boolean0);
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test2855() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""c*e{'C$Jcdy\""U:m:y"");
    FunctionType functionType0 = errorFunctionType0.cloneWithoutArrowType();
    boolean boolean0 = functionType0.matchesNumberContext();
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public boolean matchesNumberContext() {
    return isNumberObjectType() || isDateType() || isBooleanObjectType() || isStringObjectType() || hasOverridenNativeProperty(""valueOf"");
}","public void test2856() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""c*e{'C$Jcdy\""U:m:y"");
    FunctionType functionType0 = errorFunctionType0.cloneWithoutArrowType();
    boolean boolean0 = functionType0.matchesNumberContext();
    assertFalse(boolean0);
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test2857() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""c*e{'C$Jcdy\""U:m:y"");
    FunctionType functionType0 = errorFunctionType0.cloneWithoutArrowType();
    boolean boolean0 = functionType0.matchesNumberContext();
    assertFalse(functionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test2958() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType0 = recordType0.unboxesTo();
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public JSType unboxesTo() {
    if (isStringObjectType()) {
        return getNativeType(JSTypeNative.STRING_TYPE);
    } else if (isBooleanObjectType()) {
        return getNativeType(JSTypeNative.BOOLEAN_TYPE);
    } else if (isNumberObjectType()) {
        return getNativeType(JSTypeNative.NUMBER_TYPE);
    } else {
        return super.unboxesTo();
    }
}","public void test2959() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType0 = recordType0.unboxesTo();
    assertNull(jSType0);
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test2960() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType jSType0 = recordType0.unboxesTo();
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public JSType unboxesTo() {
    if (isStringObjectType()) {
        return getNativeType(JSTypeNative.STRING_TYPE);
    } else if (isBooleanObjectType()) {
        return getNativeType(JSTypeNative.BOOLEAN_TYPE);
    } else if (isNumberObjectType()) {
        return getNativeType(JSTypeNative.NUMBER_TYPE);
    } else {
        return super.unboxesTo();
    }
}","public void test3061() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    JSType jSType0 = instanceObjectType0.unboxesTo();
    assertNotNull(jSType0);
}",""
"@Override
public boolean isNominalType() {
    return hasReferenceName();
}","public void test3062() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    JSType jSType0 = instanceObjectType0.unboxesTo();
    assertTrue(instanceObjectType0.isNominalType());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test3163() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, """", unknownType0);
    String string0 = prototypeObjectType0.toStringHelper(true);
    assertFalse(prototypeObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Don't pretty print recursively.
        prettyPrint = false;
        // Use a tree set so that the properties are sorted.
        Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toStringHelper(forAnnotations));
            ++i;
            if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
        sb.append(""}"");
        prettyPrint = true;
        return sb.toString();
    } else {
        return forAnnotations ? ""?"" : ""{...}"";
    }
}","public void test3164() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, """", unknownType0);
    String string0 = prototypeObjectType0.toStringHelper(true);
    assertEquals("""", string0);
}",""
"@Override
String toStringHelper(boolean forAnnotations) {
    if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
        return ""Function"";
    }
    setPrettyPrint(false);
    StringBuilder b = new StringBuilder(32);
    b.append(""function ("");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType);
    if (hasKnownTypeOfThis) {
        if (isConstructor()) {
            b.append(""new:"");
        } else {
            b.append(""this:"");
        }
        b.append(typeOfThis.toStringHelper(forAnnotations));
    }
    if (paramNum > 0) {
        if (hasKnownTypeOfThis) {
            b.append("", "");
        }
        Node p = call.parameters.getFirstChild();
        appendArgString(b, p, forAnnotations);
        p = p.getNext();
        while (p != null) {
            b.append("", "");
            appendArgString(b, p, forAnnotations);
            p = p.getNext();
        }
    }
    b.append(""): "");
    b.append(call.returnType.toStringHelper(forAnnotations));
    setPrettyPrint(true);
    return b.toString();
}","public void test3265() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    String string0 = errorFunctionType0.toStringHelper(false);
    assertEquals(""function (new:{...}, *=, *=, *=): {...}"", string0);
}","/**
 * Informally, a function is represented by
 * {@code function (params): returnType} where the {@code params} is a comma
 * separated list of types, the first one being a special
 * {@code this:T} if the function expects a known type for {@code this}.
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test3266() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    String string0 = errorFunctionType0.toStringHelper(false);
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Don't pretty print recursively.
        prettyPrint = false;
        // Use a tree set so that the properties are sorted.
        Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toStringHelper(forAnnotations));
            ++i;
            if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
        sb.append(""}"");
        prettyPrint = true;
        return sb.toString();
    } else {
        return forAnnotations ? ""?"" : ""{...}"";
    }
}","public void test3367() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    Node node0 = Node.newString(0, ""Not declared as a constructor"");
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(errorFunctionType0, node0);
    hashMap0.put(""Not declared as a constructor"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    String string0 = recordType0.toStringHelper(true);
    assertEquals(""{Not declared as a constructor: function (new:?, *=, *=, *=): ?}"", string0);
}",""
"@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Don't pretty print recursively.
        prettyPrint = false;
        // Use a tree set so that the properties are sorted.
        Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toStringHelper(forAnnotations));
            ++i;
            if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
        sb.append(""}"");
        prettyPrint = true;
        return sb.toString();
    } else {
        return forAnnotations ? ""?"" : ""{...}"";
    }
}","public void test3469() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    Node node0 = new Node(1, 1, 105);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(recordType0, node0);
    BiFunction<RecordTypeBuilder.RecordProperty, Object, RecordTypeBuilder.RecordProperty> biFunction0 = (BiFunction<RecordTypeBuilder.RecordProperty, Object, RecordTypeBuilder.RecordProperty>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty1 = hashMap0.merge(""tR*i:"", recordTypeBuilder_RecordProperty0, biFunction0);
    hashMap0.put(""Unknown class name"", recordTypeBuilder_RecordProperty0);
    hashMap0.put(""Not declared as a type name"", recordTypeBuilder_RecordProperty0);
    hashMap0.put(""Not declared as a constructor"", recordTypeBuilder_RecordProperty1);
    RecordType recordType1 = jSTypeRegistry0.createRecordType(hashMap0);
    String string0 = recordType1.toStringHelper(false);
    assertEquals(""{Not declared as a constructor: {}, Not declared as a type name: {}, Unknown class name: {}, tR*i:: {}, ...}"", string0);
}",""
"public boolean resetImplicitPrototype(JSType type, ObjectType newImplicitProto) {
    if (type instanceof PrototypeObjectType) {
        PrototypeObjectType poType = (PrototypeObjectType) type;
        poType.clearCachedValues();
        poType.setImplicitPrototype(newImplicitProto);
        return true;
    }
    return false;
}","public void test3571() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    // Undeclared exception!
    try {
        jSTypeRegistry0.resetImplicitPrototype(functionType0, functionType0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Set the implicit prototype if it's possible to do so.
 * @return True if we were able to set the implicit prototype successfully,
 *     false if it was not possible to do so for some reason. There are
 *     a few different reasons why this could fail: for example, numbers
 *     can't be implicit prototypes, and we don't want to change the implicit
 *     prototype if other classes have already subclassed this one.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test3672() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType[] jSTypeArray0 = new JSType[8];
    jSTypeArray0[7] = (JSType) recordType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) recordType0, jSTypeArray0);
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test3673() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    JSType[] jSTypeArray0 = new JSType[8];
    jSTypeArray0[7] = (JSType) recordType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) recordType0, jSTypeArray0);
    recordType0.setOwnerFunction(functionType0);
    recordType0.getReferenceName();
    assertTrue(recordType0.hasReferenceName());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test3774() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "", ..."");
    FunctionType functionType0 = errorFunctionType0.getSuperClassConstructor();
    errorFunctionType0.matchRecordTypeConstraint(functionType0);
    assertTrue(functionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test3775() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "", ..."");
    FunctionType functionType0 = errorFunctionType0.getSuperClassConstructor();
    errorFunctionType0.matchRecordTypeConstraint(functionType0);
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test3876() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""H7Xroxy"", (Node) null);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, functionType0, functionType0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    ImmutableList<ObjectType> immutableList0 = ImmutableList.of((ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) instanceObjectType0, (ObjectType) indexedType0, (ObjectType) instanceObjectType0);
    functionType0.setExtendedInterfaces(immutableList0);
    instanceObjectType0.getTypesUnderShallowEquality(indexedType0);
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test3877() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""H7Xroxy"", (Node) null);
    IndexedType indexedType0 = new IndexedType(jSTypeRegistry0, functionType0, functionType0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    ImmutableList<ObjectType> immutableList0 = ImmutableList.of((ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) instanceObjectType0, (ObjectType) indexedType0, (ObjectType) instanceObjectType0);
    functionType0.setExtendedInterfaces(immutableList0);
    instanceObjectType0.getTypesUnderShallowEquality(indexedType0);
    assertFalse(instanceObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test3978() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    Node node0 = new Node(1, 1, 105);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(recordType0, node0);
    BiFunction<RecordTypeBuilder.RecordProperty, Object, RecordTypeBuilder.RecordProperty> biFunction0 = (BiFunction<RecordTypeBuilder.RecordProperty, Object, RecordTypeBuilder.RecordProperty>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
    hashMap0.merge(""tR*i:"", recordTypeBuilder_RecordProperty0, biFunction0);
    hashMap0.put(""Unknown class name"", recordTypeBuilder_RecordProperty0);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0);
    RecordType recordType2 = jSTypeRegistry0.createRecordType(hashMap0);
    assertFalse(recordType2.hasReferenceName());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test3979() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    Node node0 = new Node(1, 1, 105);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(recordType0, node0);
    BiFunction<RecordTypeBuilder.RecordProperty, Object, RecordTypeBuilder.RecordProperty> biFunction0 = (BiFunction<RecordTypeBuilder.RecordProperty, Object, RecordTypeBuilder.RecordProperty>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
    hashMap0.merge(""tR*i:"", recordTypeBuilder_RecordProperty0, biFunction0);
    hashMap0.put(""Unknown class name"", recordTypeBuilder_RecordProperty0);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0);
    RecordType recordType2 = jSTypeRegistry0.createRecordType(hashMap0);
    assertFalse(recordType2.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test4080() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.NullType"", (Node) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = functionType0.isSubtype(instanceObjectType0);
    assertFalse(instanceObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    if (that.isFunctionType()) {
        FunctionType other = that.toMaybeFunctionType();
        if (other.isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        boolean treatThisTypesAsCovariant = // If either one of these is a ctor, skip 'this' checking.
        this.isConstructor() || other.isConstructor() || // An interface 'this'-type is non-restrictive.
        // In practical terms, if C implements I, and I has a method m,
        // then any m doesn't necessarily have to C#m's 'this'
        // type doesn't need to match I.
        (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || // If one of the 'this' types is covariant of the other,
        // then we'll treat them as covariant (see comment above).
        other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);
        return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test4081() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.NullType"", (Node) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = functionType0.isSubtype(instanceObjectType0);
    assertFalse(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test4082() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.NullType"", (Node) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = functionType0.isSubtype(instanceObjectType0);
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"public final boolean isNumber() {
    return this.isSubtype(getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));
}","public void test4183() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    boolean boolean0 = errorFunctionType0.isNumber();
    assertFalse(boolean0);
}","/**
 * Tests whether the type is a number (value or Object).
 * @return {@code this &lt;: (Number, number)}
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test4184() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    boolean boolean0 = errorFunctionType0.isNumber();
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test4285() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.NullType"", (Node) null);
    ImmutableList<ObjectType> immutableList0 = ImmutableList.of((ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0);
    functionType0.setExtendedInterfaces(immutableList0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    TreeSet<JSType> treeSet0 = new TreeSet<JSType>();
    UnionType unionType0 = new UnionType(jSTypeRegistry0, treeSet0);
    JSType jSType0 = unionType0.meet(instanceObjectType0);
    boolean boolean0 = instanceObjectType0.isSubtype(jSType0);
    assertTrue(instanceObjectType0.hasCachedValues());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    // Union types
    if (that.isUnionType()) {
        // The static {@code JSType.isSubtype} check already decomposed
        // union types, so we don't need to check those again.
        return false;
    }
    // record types
    if (that.isRecordType()) {
        return RecordType.isSubtype(this, that.toMaybeRecordType());
    }
    // Interfaces
    // Find all the interfaces implemented by this class and compare each one
    // to the interface instance.
    ObjectType thatObj = that.toObjectType();
    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();
    if (thatCtor != null && thatCtor.isInterface()) {
        Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();
        for (ObjectType thisInterface : thisInterfaces) {
            if (thisInterface.isSubtype(that)) {
                return true;
            }
        }
    }
    if (getConstructor() != null && getConstructor().isInterface()) {
        for (ObjectType thisInterface : getCtorExtendedInterfaces()) {
            if (thisInterface.isSubtype(that)) {
                return true;
            }
        }
    }
    // other prototype based objects
    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
        // If unsure, say 'yes', to avoid spurious warnings.
        // TODO(user): resolve the prototype chain completely in all cases,
        // to avoid guessing.
        return true;
    }
    return this.isImplicitPrototype(thatObj);
}","public void test4286() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""com.google.javascript.rhino.jstype.NullType"", (Node) null);
    ImmutableList<ObjectType> immutableList0 = ImmutableList.of((ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0, (ObjectType) functionType0);
    functionType0.setExtendedInterfaces(immutableList0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    TreeSet<JSType> treeSet0 = new TreeSet<JSType>();
    UnionType unionType0 = new UnionType(jSTypeRegistry0, treeSet0);
    JSType jSType0 = unionType0.meet(instanceObjectType0);
    boolean boolean0 = instanceObjectType0.isSubtype(jSType0);
    assertFalse(boolean0);
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    // Union types
    if (that.isUnionType()) {
        // The static {@code JSType.isSubtype} check already decomposed
        // union types, so we don't need to check those again.
        return false;
    }
    // record types
    if (that.isRecordType()) {
        return RecordType.isSubtype(this, that.toMaybeRecordType());
    }
    // Interfaces
    // Find all the interfaces implemented by this class and compare each one
    // to the interface instance.
    ObjectType thatObj = that.toObjectType();
    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();
    if (thatCtor != null && thatCtor.isInterface()) {
        Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();
        for (ObjectType thisInterface : thisInterfaces) {
            if (thisInterface.isSubtype(that)) {
                return true;
            }
        }
    }
    if (getConstructor() != null && getConstructor().isInterface()) {
        for (ObjectType thisInterface : getCtorExtendedInterfaces()) {
            if (thisInterface.isSubtype(that)) {
                return true;
            }
        }
    }
    // other prototype based objects
    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
        // If unsure, say 'yes', to avoid spurious warnings.
        // TODO(user): resolve the prototype chain completely in all cases,
        // to avoid guessing.
        return true;
    }
    return this.isImplicitPrototype(thatObj);
}","public void test4387() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = instanceObjectType0.isSubtype(noResolvedType0);
    assertTrue(boolean0);
}",""
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test4388() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = instanceObjectType0.isSubtype(noResolvedType0);
    assertFalse(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test4389() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = instanceObjectType0.isSubtype(noResolvedType0);
    assertFalse(instanceObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test4490() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""    "");
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, """", templateType0, true);
    PrototypeObjectType prototypeObjectType1 = new PrototypeObjectType(jSTypeRegistry0, (String) null, prototypeObjectType0);
    jSTypeRegistry0.createOptionalType(prototypeObjectType1);
    assertTrue(prototypeObjectType1.hasCachedValues());
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test4491() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""    "");
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, """", templateType0, true);
    PrototypeObjectType prototypeObjectType1 = new PrototypeObjectType(jSTypeRegistry0, (String) null, prototypeObjectType0);
    jSTypeRegistry0.createOptionalType(prototypeObjectType1);
    assertFalse(prototypeObjectType1.hasReferenceName());
}",""
"@Override
void setOwnerFunction(FunctionType type) {
    Preconditions.checkState(ownerFunction == null || type == null);
    ownerFunction = type;
}","public void test4592() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""N4Qjq4W"");
    errorFunctionType0.setOwnerFunction(errorFunctionType0);
    // Undeclared exception!
    try {
        errorFunctionType0.setOwnerFunction(errorFunctionType0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test4693() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, """", unknownType0);
    prototypeObjectType0.getCtorImplementedInterfaces();
    assertFalse(prototypeObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test4694() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, """", unknownType0);
    prototypeObjectType0.getCtorImplementedInterfaces();
    assertTrue(prototypeObjectType0.hasReferenceName());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test4795() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""N4Qjq4W"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""N4Qjq4W"", jSDocInfo0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test4796() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""N4Qjq4W"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""N4Qjq4W"", jSDocInfo0);
    JSType.safeResolve(errorFunctionType0, simpleErrorReporter0, errorFunctionType0);
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test4897() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.matchConstraint(recordType0);
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test4898() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.matchConstraint(recordType0);
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test4999() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a constructor"", (Node) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    instanceObjectType0.matchConstraint(functionType0);
    assertFalse(instanceObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test49100() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = jSTypeRegistry0.createInterfaceType(""Not declared as a constructor"", (Node) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    instanceObjectType0.matchConstraint(functionType0);
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test50101() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    Node node0 = new Node(1, (-2231), 1);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType(node0, recordType0);
    recordType0.matchConstraint(arrowType0);
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test50102() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    Node node0 = new Node(1, (-2231), 1);
    ArrowType arrowType0 = jSTypeRegistry0.createArrowType(node0, recordType0);
    recordType0.matchConstraint(arrowType0);
    assertFalse(recordType0.hasReferenceName());
}",""
