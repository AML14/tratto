focal_method,test_prefix,docstring
"FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode) {
    this.sourceNode = sourceNode;
    return this;
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""gA+h-s/yF&[<t/N_@"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""gA+h-s/yF&[<t/N_@"", compiler0, node0, ""gA+h-s/yF&[<t/N_@"", (Scope) null);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.setSourceNode(node0);
    assertSame(functionTypeBuilder0, functionTypeBuilder1);
}","/**
 * Sets the FUNCTION node of this function.
 */"
"FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {
    if (oldType == null) {
        return this;
    }
    returnType = oldType.getReturnType();
    returnTypeInferred = oldType.isReturnTypeInferred();
    if (paramsParent == null) {
        // Not a function literal.
        parametersNode = oldType.getParametersNode();
        if (parametersNode == null) {
            parametersNode = new FunctionParamBuilder(typeRegistry).build();
        }
    } else {
        // We're overriding with a function literal. Apply type information
        // to each parameter of the literal.
        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);
        Iterator<Node> oldParams = oldType.getParameters().iterator();
        boolean warnedAboutArgList = false;
        boolean oldParamsListHitOptArgs = false;
        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {
            if (oldParams.hasNext()) {
                Node oldParam = oldParams.next();
                Node newParam = paramBuilder.newParameterFromNode(oldParam);
                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();
                // The subclass method might right its var_args as individual
                // arguments.
                if (currentParam.getNext() != null && newParam.isVarArgs()) {
                    newParam.setVarArgs(false);
                    newParam.setOptionalArg(true);
                }
            } else {
                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));
            }
        }
        parametersNode = paramBuilder.build();
    }
    return this;
}","public void test011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""rsT*.f:u}P7j"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""rsT*.f:u}P7j"", compiler0, node0, ""rsT*.f:u}P7j"", (Scope) null);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferFromOverriddenFunction((FunctionType) null, node0);
    assertSame(functionTypeBuilder0, functionTypeBuilder1);
}","/**
 * Infer the parameter and return types of a function from
 * the parameter and return types of the function it is overriding.
 *
 * @param oldType The function being overridden. Does nothing if this is null.
 * @param paramsParent The LP node of the function that we're assigning to.
 *     If null, that just means we're not initializing this to a function
 *     literal.
 */"
"public boolean isReturnTypeInferred() {
    return call.returnTypeInferred;
}","public void test022() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""0"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""0"", compiler0, node0, ""0"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferParameterTypes(jSDocInfo0);
    FunctionType functionType0 = functionTypeBuilder0.buildAndRegister();
    functionTypeBuilder1.inferFromOverriddenFunction(functionType0, (Node) null);
    assertFalse(functionType0.isReturnTypeInferred());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test023() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""0"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""0"", compiler0, node0, ""0"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferParameterTypes(jSDocInfo0);
    FunctionType functionType0 = functionTypeBuilder0.buildAndRegister();
    functionTypeBuilder1.inferFromOverriddenFunction(functionType0, (Node) null);
    assertFalse(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test034() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""JSC_THIS_TYPE_NON_OBJECT"", ""JSC_THIS_TYPE_NON_OBJECT"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""JSC_THIS_TYPE_NON_OBJECT"", compiler0, node0, ""JSC_THIS_TYPE_NON_OBJECT"", (Scope) null);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferFromOverriddenFunction(functionType0, node0);
    FunctionType functionType1 = functionTypeBuilder1.buildAndRegister();
    assertFalse(functionType1.hasCachedValues());
}",""
"public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
        Node lastParam = params.getLastChild();
        if (lastParam == null || !lastParam.isVarArgs()) {
            return params.getChildCount();
        }
    }
    return Integer.MAX_VALUE;
}","public void test035() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""JSC_THIS_TYPE_NON_OBJECT"", ""JSC_THIS_TYPE_NON_OBJECT"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""JSC_THIS_TYPE_NON_OBJECT"", compiler0, node0, ""JSC_THIS_TYPE_NON_OBJECT"", (Scope) null);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferFromOverriddenFunction(functionType0, node0);
    FunctionType functionType1 = functionTypeBuilder1.buildAndRegister();
    assertEquals(1, functionType1.getMaxArguments());
}","/**
 * Gets the maximum number of arguments that this function requires,
 * or Integer.MAX_VALUE if this is a variable argument function.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test046() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("""", """");
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[4];
    JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    jSTypeArray0[0] = (JSType) objectType0;
    jSTypeArray0[1] = (JSType) objectType0;
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", jSTypeArray0[0]);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    FunctionType functionType0 = enumElementType0.getConstructor();
    jSTypeArray0[2] = (JSType) functionType0;
    jSTypeArray0[3] = (JSType) enumElementType0;
    Node node1 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""Named type with empty name component"", compiler0, node0, ""Not declared as a constructor"", (Scope) null);
    functionTypeBuilder0.inferFromOverriddenFunction(functionType0, node1);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {
    if (oldType == null) {
        return this;
    }
    returnType = oldType.getReturnType();
    returnTypeInferred = oldType.isReturnTypeInferred();
    if (paramsParent == null) {
        // Not a function literal.
        parametersNode = oldType.getParametersNode();
        if (parametersNode == null) {
            parametersNode = new FunctionParamBuilder(typeRegistry).build();
        }
    } else {
        // We're overriding with a function literal. Apply type information
        // to each parameter of the literal.
        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);
        Iterator<Node> oldParams = oldType.getParameters().iterator();
        boolean warnedAboutArgList = false;
        boolean oldParamsListHitOptArgs = false;
        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {
            if (oldParams.hasNext()) {
                Node oldParam = oldParams.next();
                Node newParam = paramBuilder.newParameterFromNode(oldParam);
                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();
                // The subclass method might right its var_args as individual
                // arguments.
                if (currentParam.getNext() != null && newParam.isVarArgs()) {
                    newParam.setVarArgs(false);
                    newParam.setOptionalArg(true);
                }
            } else {
                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));
            }
        }
        parametersNode = paramBuilder.build();
    }
    return this;
}","public void test057() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""prefix must start with one of: "");
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    Node node1 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) linkedList0);
    Node node2 = new Node(0, node0, node1);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    Scope scope0 = new Scope(node1, objectType0);
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder("""", compiler0, node0, ""Not declared as a type name"", scope0);
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) objectType0, (Node) null);
    // Undeclared exception!
    try {
        functionTypeBuilder0.inferFromOverriddenFunction(functionType0, node2);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // LP is not a string node
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Infer the parameter and return types of a function from
 * the parameter and return types of the function it is overriding.
 *
 * @param oldType The function being overridden. Does nothing if this is null.
 * @param paramsParent The LP node of the function that we're assigning to.
 *     If null, that just means we're not initializing this to a function
 *     literal.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test068() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""JSC_INVLID_MARKER_UAGE"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""JSC_INVLID_MARKER_UAGE"", compiler0, node0, ""JSC_INVLID_MARKER_UAGE"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferParameterTypes(jSDocInfo0);
    FunctionType functionType0 = functionTypeBuilder1.buildAndRegister();
    assertFalse(functionType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test069() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""JSC_INVLID_MARKER_UAGE"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""JSC_INVLID_MARKER_UAGE"", compiler0, node0, ""JSC_INVLID_MARKER_UAGE"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferParameterTypes(jSDocInfo0);
    FunctionType functionType0 = functionTypeBuilder1.buildAndRegister();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[1];
    jSTypeArray0[0] = (JSType) functionType0;
    Node node1 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
    functionTypeBuilder1.inferFromOverriddenFunction(functionType0, node1);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {
    if (info != null && info.hasReturnType()) {
        returnType = info.getReturnType().evaluate(scope, typeRegistry);
        returnTypeInferred = false;
    }
    if (templateTypeName != null && returnType != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) {
        reportError(TEMPLATE_TYPE_EXPECTED, fnName);
    }
    return this;
}","public void test0710() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""0"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""0"", compiler0, node0, ""0"", (Scope) null);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferReturnType((JSDocInfo) null);
    assertSame(functionTypeBuilder1, functionTypeBuilder0);
}","/**
 * Infer the return type from JSDocInfo.
 */"
"FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {
    if (info != null && info.hasReturnType()) {
        returnType = info.getReturnType().evaluate(scope, typeRegistry);
        returnTypeInferred = false;
    }
    if (templateTypeName != null && returnType != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) {
        reportError(TEMPLATE_TYPE_EXPECTED, fnName);
    }
    return this;
}","public void test0811() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""0"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""0"", compiler0, node0, ""0"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferReturnType(jSDocInfo0);
    assertSame(functionTypeBuilder0, functionTypeBuilder1);
}","/**
 * Infer the return type from JSDocInfo.
 */"
"FunctionTypeBuilder inferReturnStatementsAsLastResort(@Nullable Node functionBlock) {
    if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {
        return this;
    }
    Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);
    if (returnType == null) {
        boolean hasNonEmptyReturns = false;
        List<Node> worklist = Lists.newArrayList(functionBlock);
        while (!worklist.isEmpty()) {
            Node current = worklist.remove(worklist.size() - 1);
            int cType = current.getType();
            if (cType == Token.RETURN && current.getFirstChild() != null || cType == Token.THROW) {
                hasNonEmptyReturns = true;
                break;
            } else if (NodeUtil.isStatementBlock(current) || NodeUtil.isControlStructure(current)) {
                for (Node child = current.getFirstChild(); child != null; child = child.getNext()) {
                    worklist.add(child);
                }
            }
        }
        if (!hasNonEmptyReturns) {
            returnType = typeRegistry.getNativeType(VOID_TYPE);
            returnTypeInferred = true;
        }
    }
    return this;
}","public void test0912() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""gooLg.typedwef"", ""gooLg.typedwef"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""gooLg.typedwef"", compiler0, node0, ""gooLg.typedwef"", (Scope) null);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferReturnStatementsAsLastResort((Node) null);
    assertSame(functionTypeBuilder1, functionTypeBuilder0);
}","/**
 * If we haven't found a return value yet, try to look at the ""return""
 * statements in the function.
 */"
"FunctionTypeBuilder inferReturnStatementsAsLastResort(@Nullable Node functionBlock) {
    if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {
        return this;
    }
    Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);
    if (returnType == null) {
        boolean hasNonEmptyReturns = false;
        List<Node> worklist = Lists.newArrayList(functionBlock);
        while (!worklist.isEmpty()) {
            Node current = worklist.remove(worklist.size() - 1);
            int cType = current.getType();
            if (cType == Token.RETURN && current.getFirstChild() != null || cType == Token.THROW) {
                hasNonEmptyReturns = true;
                break;
            } else if (NodeUtil.isStatementBlock(current) || NodeUtil.isControlStructure(current)) {
                for (Node child = current.getFirstChild(); child != null; child = child.getNext()) {
                    worklist.add(child);
                }
            }
        }
        if (!hasNonEmptyReturns) {
            returnType = typeRegistry.getNativeType(VOID_TYPE);
            returnTypeInferred = true;
        }
    }
    return this;
}","public void test1013() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode((String) null, (String) null);
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    Node node0 = compiler0.parseTestCode("""");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder((String) null, compiler0, node0, (String) null, (Scope) null);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferReturnStatementsAsLastResort(node0);
    assertSame(functionTypeBuilder0, functionTypeBuilder1);
}","/**
 * If we haven't found a return value yet, try to look at the ""return""
 * statements in the function.
 */"
"FunctionTypeBuilder inferReturnStatementsAsLastResort(@Nullable Node functionBlock) {
    if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {
        return this;
    }
    Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);
    if (returnType == null) {
        boolean hasNonEmptyReturns = false;
        List<Node> worklist = Lists.newArrayList(functionBlock);
        while (!worklist.isEmpty()) {
            Node current = worklist.remove(worklist.size() - 1);
            int cType = current.getType();
            if (cType == Token.RETURN && current.getFirstChild() != null || cType == Token.THROW) {
                hasNonEmptyReturns = true;
                break;
            } else if (NodeUtil.isStatementBlock(current) || NodeUtil.isControlStructure(current)) {
                for (Node child = current.getFirstChild(); child != null; child = child.getNext()) {
                    worklist.add(child);
                }
            }
        }
        if (!hasNonEmptyReturns) {
            returnType = typeRegistry.getNativeType(VOID_TYPE);
            returnTypeInferred = true;
        }
    }
    return this;
}","public void test1114() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode((String) null, (String) null);
    Charset charset0 = Charset.defaultCharset();
    JSSourceFile jSSourceFile1 = JSSourceFile.fromFile("""", charset0);
    compiler0.compile(jSSourceFile1, jSSourceFile0, compilerOptions0);
    Node node0 = compiler0.parseTestCode(""// Input %num%"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder("""", compiler0, node0, (String) null, (Scope) null);
    // Undeclared exception!
    try {
        functionTypeBuilder0.inferReturnStatementsAsLastResort(node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * If we haven't found a return value yet, try to look at the ""return""
 * statements in the function.
 */"
"FunctionTypeBuilder inferReturnStatementsAsLastResort(@Nullable Node functionBlock) {
    if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {
        return this;
    }
    Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);
    if (returnType == null) {
        boolean hasNonEmptyReturns = false;
        List<Node> worklist = Lists.newArrayList(functionBlock);
        while (!worklist.isEmpty()) {
            Node current = worklist.remove(worklist.size() - 1);
            int cType = current.getType();
            if (cType == Token.RETURN && current.getFirstChild() != null || cType == Token.THROW) {
                hasNonEmptyReturns = true;
                break;
            } else if (NodeUtil.isStatementBlock(current) || NodeUtil.isControlStructure(current)) {
                for (Node child = current.getFirstChild(); child != null; child = child.getNext()) {
                    worklist.add(child);
                }
            }
        }
        if (!hasNonEmptyReturns) {
            returnType = typeRegistry.getNativeType(VOID_TYPE);
            returnTypeInferred = true;
        }
    }
    return this;
}","public void test1215() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode((String) null, (String) null);
    Node node0 = compiler0.parseSyntheticCode("""", ""!f^*Hk)N@gccgYO?]"");
    JSSourceFile jSSourceFile1 = JSSourceFile.fromCode(""!f^*Hk)N@gccgYO?]"", (String) null);
    compiler0.compile(jSSourceFile1, jSSourceFile0, compilerOptions0);
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder("""", compiler0, node0, (String) null, (Scope) null);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferReturnStatementsAsLastResort(node0);
    FunctionTypeBuilder functionTypeBuilder2 = functionTypeBuilder1.inferReturnStatementsAsLastResort(node0);
    assertSame(functionTypeBuilder1, functionTypeBuilder2);
}","/**
 * If we haven't found a return value yet, try to look at the ""return""
 * statements in the function.
 */"
"FunctionTypeBuilder inferReturnStatementsAsLastResort(@Nullable Node functionBlock) {
    if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {
        return this;
    }
    Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);
    if (returnType == null) {
        boolean hasNonEmptyReturns = false;
        List<Node> worklist = Lists.newArrayList(functionBlock);
        while (!worklist.isEmpty()) {
            Node current = worklist.remove(worklist.size() - 1);
            int cType = current.getType();
            if (cType == Token.RETURN && current.getFirstChild() != null || cType == Token.THROW) {
                hasNonEmptyReturns = true;
                break;
            } else if (NodeUtil.isStatementBlock(current) || NodeUtil.isControlStructure(current)) {
                for (Node child = current.getFirstChild(); child != null; child = child.getNext()) {
                    worklist.add(child);
                }
            }
        }
        if (!hasNonEmptyReturns) {
            returnType = typeRegistry.getNativeType(VOID_TYPE);
            returnTypeInferred = true;
        }
    }
    return this;
}","public void test1316() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode((String) null, (String) null);
    Node node0 = compiler0.parseSyntheticCode(""&}(_mPH[8]wQ9>YZVE*"", ""0f?*Hk)N@gccgYO?]"");
    Charset charset0 = Charset.defaultCharset();
    JSSourceFile jSSourceFile1 = JSSourceFile.fromFile("""", charset0);
    compiler0.compile(jSSourceFile1, jSSourceFile0, compilerOptions0);
    node0.addChildToBack(node0);
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder("""", compiler0, node0, (String) null, (Scope) null);
    // Undeclared exception!
    functionTypeBuilder0.inferReturnStatementsAsLastResort(node0);
}","/**
 * If we haven't found a return value yet, try to look at the ""return""
 * statements in the function.
 */"
"FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {
    if (info != null) {
        isConstructor = info.isConstructor();
        isInterface = info.isInterface();
        // base type
        if (info.hasBaseType()) {
            if (isConstructor || isInterface) {
                JSType maybeBaseType = info.getBaseType().evaluate(scope, typeRegistry);
                if (maybeBaseType != null && maybeBaseType.setValidator(new ExtendedTypeValidator())) {
                    baseType = (ObjectType) maybeBaseType;
                }
            } else {
                reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);
            }
        }
        // implemented interfaces
        if (isConstructor || isInterface) {
            implementedInterfaces = Lists.newArrayList();
            for (JSTypeExpression t : info.getImplementedInterfaces()) {
                JSType maybeInterType = t.evaluate(scope, typeRegistry);
                if (maybeInterType != null && maybeInterType.setValidator(new ImplementedTypeValidator())) {
                    implementedInterfaces.add((ObjectType) maybeInterType);
                }
            }
            if (baseType != null) {
                JSType maybeFunctionType = baseType.getConstructor();
                if (maybeFunctionType instanceof FunctionType) {
                    FunctionType functionType = baseType.getConstructor();
                    Iterables.addAll(implementedInterfaces, functionType.getImplementedInterfaces());
                }
            }
        } else if (info.getImplementedInterfaceCount() > 0) {
            reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName);
        }
    }
    return this;
}","public void test1417() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""0"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""0"", compiler0, node0, ""0"", (Scope) null);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferInheritance((JSDocInfo) null);
    assertSame(functionTypeBuilder1, functionTypeBuilder0);
}","/**
 * Infer the role of the function (whether it's a constructor or interface)
 * and what it inherits from in JSDocInfo.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1518() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""0"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""0"", compiler0, node0, ""0"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    functionTypeBuilder0.inferInheritance(jSDocInfo0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) {
    ObjectType objType = ObjectType.cast(type);
    if (objType != null && (info == null || !info.hasType())) {
        thisType = objType;
    }
    return this;
}","public void test1619() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""\""h"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""\""h"", compiler0, node0, ""\""h"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferThisType(jSDocInfo0, (JSType) null);
    assertSame(functionTypeBuilder0, functionTypeBuilder1);
}","/**
 * Infers the type of {@code this}.
 * @param type The type of this.
 */"
"FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) {
    ObjectType objType = ObjectType.cast(type);
    if (objType != null && (info == null || !info.hasType())) {
        thisType = objType;
    }
    return this;
}","public void test1720() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""prefix must start with one of: "");
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    Scope scope0 = new Scope(node0, objectType0);
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder("""", compiler0, node0, ""Not declared as a type name"", scope0);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferThisType(jSDocInfo0, objectType0);
    assertSame(functionTypeBuilder1, functionTypeBuilder0);
}","/**
 * Infers the type of {@code this}.
 * @param type The type of this.
 */"
"public boolean isReturnTypeInferred() {
    return call.returnTypeInferred;
}","public void test1821() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""rsT*.f:u}P7j"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""rsT*.f:u}P7j"", compiler0, node0, ""rsT*.f:u}P7j"", (Scope) null);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferParameterTypes(node0, (JSDocInfo) null);
    FunctionType functionType0 = functionTypeBuilder0.buildAndRegister();
    functionTypeBuilder1.inferThisType((JSDocInfo) null, functionType0);
    assertFalse(functionType0.isReturnTypeInferred());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test1822() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""rsT*.f:u}P7j"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""rsT*.f:u}P7j"", compiler0, node0, ""rsT*.f:u}P7j"", (Scope) null);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferParameterTypes(node0, (JSDocInfo) null);
    FunctionType functionType0 = functionTypeBuilder0.buildAndRegister();
    functionTypeBuilder1.inferThisType((JSDocInfo) null, functionType0);
    assertFalse(functionType0.hasCachedValues());
}",""
"FunctionTypeBuilder inferThisType(JSDocInfo info, @Nullable Node owner) {
    ObjectType maybeThisType = null;
    if (info != null && info.hasThisType()) {
        maybeThisType = ObjectType.cast(info.getThisType().evaluate(scope, typeRegistry));
    }
    if (maybeThisType != null) {
        thisType = maybeThisType;
        thisType.setValidator(new ThisTypeValidator());
    } else if (owner != null && (info == null || !info.hasType())) {
        // If the function is of the form:
        // x.prototype.y = function() {}
        // then we can assume ""x"" is the @this type. On the other hand,
        // if it's of the form:
        // /** @type {Function} */ x.prototype.y;
        // then we should not give it a @this type.
        String ownerTypeName = owner.getQualifiedName();
        ObjectType ownerType = ObjectType.cast(typeRegistry.getForgivingType(scope, ownerTypeName, sourceName, owner.getLineno(), owner.getCharno()));
        if (ownerType != null) {
            thisType = ownerType;
        }
    }
    return this;
}","public void test1923() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""XD+veW*l#=w[qQ"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""XD+veW*l#=w[qQ"", compiler0, node0, ""XD+veW*l#=w[qQ"", (Scope) null);
    // Undeclared exception!
    try {
        functionTypeBuilder0.inferThisType((JSDocInfo) null, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.JSTypeRegistry"", e);
    }
}","/**
 * Infers the type of {@code this}.
 * @param info The JSDocInfo for this function.
 * @param owner The node for the object whose prototype ""owns"" this function.
 *     For example, {@code A} in the expression {@code A.prototype.foo}. May
 *     be null to indicate that this is not a prototype property.
 */"
"FunctionTypeBuilder inferThisType(JSDocInfo info, @Nullable Node owner) {
    ObjectType maybeThisType = null;
    if (info != null && info.hasThisType()) {
        maybeThisType = ObjectType.cast(info.getThisType().evaluate(scope, typeRegistry));
    }
    if (maybeThisType != null) {
        thisType = maybeThisType;
        thisType.setValidator(new ThisTypeValidator());
    } else if (owner != null && (info == null || !info.hasType())) {
        // If the function is of the form:
        // x.prototype.y = function() {}
        // then we can assume ""x"" is the @this type. On the other hand,
        // if it's of the form:
        // /** @type {Function} */ x.prototype.y;
        // then we should not give it a @this type.
        String ownerTypeName = owner.getQualifiedName();
        ObjectType ownerType = ObjectType.cast(typeRegistry.getForgivingType(scope, ownerTypeName, sourceName, owner.getLineno(), owner.getCharno()));
        if (ownerType != null) {
            thisType = ownerType;
        }
    }
    return this;
}","public void test2024() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""g=g.typedef"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""g=g.typedef"", compiler0, node0, ""g=g.typedef"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferThisType(jSDocInfo0, (Node) null);
    assertSame(functionTypeBuilder0, functionTypeBuilder1);
}","/**
 * Infers the type of {@code this}.
 * @param info The JSDocInfo for this function.
 * @param owner The node for the object whose prototype ""owns"" this function.
 *     For example, {@code A} in the expression {@code A.prototype.foo}. May
 *     be null to indicate that this is not a prototype property.
 */"
"FunctionTypeBuilder inferThisType(JSDocInfo info, @Nullable Node owner) {
    ObjectType maybeThisType = null;
    if (info != null && info.hasThisType()) {
        maybeThisType = ObjectType.cast(info.getThisType().evaluate(scope, typeRegistry));
    }
    if (maybeThisType != null) {
        thisType = maybeThisType;
        thisType.setValidator(new ThisTypeValidator());
    } else if (owner != null && (info == null || !info.hasType())) {
        // If the function is of the form:
        // x.prototype.y = function() {}
        // then we can assume ""x"" is the @this type. On the other hand,
        // if it's of the form:
        // /** @type {Function} */ x.prototype.y;
        // then we should not give it a @this type.
        String ownerTypeName = owner.getQualifiedName();
        ObjectType ownerType = ObjectType.cast(typeRegistry.getForgivingType(scope, ownerTypeName, sourceName, owner.getLineno(), owner.getCharno()));
        if (ownerType != null) {
            thisType = ownerType;
        }
    }
    return this;
}","public void test2125() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""yeq"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""yeq"", compiler0, node0, ""yeq"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    Node node1 = new Node(42, 13, 15);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferThisType(jSDocInfo0, node1);
    assertSame(functionTypeBuilder1, functionTypeBuilder0);
}","/**
 * Infers the type of {@code this}.
 * @param info The JSDocInfo for this function.
 * @param owner The node for the object whose prototype ""owns"" this function.
 *     For example, {@code A} in the expression {@code A.prototype.foo}. May
 *     be null to indicate that this is not a prototype property.
 */"
"FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {
    if (argsParent == null) {
        if (info == null) {
            return this;
        } else {
            return inferParameterTypes(info);
        }
    }
    // arguments
    Node oldParameterType = null;
    if (parametersNode != null) {
        oldParameterType = parametersNode.getFirstChild();
    }
    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);
    boolean warnedAboutArgList = false;
    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());
    boolean foundTemplateType = false;
    for (Node arg : argsParent.children()) {
        String argumentName = arg.getString();
        allJsDocParams.remove(argumentName);
        // type from JSDocInfo
        JSType parameterType = null;
        boolean isOptionalParam = isOptionalParameter(arg, info);
        boolean isVarArgs = isVarArgsParameter(arg, info);
        if (info != null && info.hasParameterType(argumentName)) {
            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);
        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {
            parameterType = oldParameterType.getJSType();
            isOptionalParam = oldParameterType.isOptionalArg();
            isVarArgs = oldParameterType.isVarArgs();
        } else {
            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);
        }
        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {
            if (foundTemplateType) {
                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);
            }
            foundTemplateType = true;
        }
        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);
        if (oldParameterType != null) {
            oldParameterType = oldParameterType.getNext();
        }
    }
    if (templateTypeName != null && !foundTemplateType) {
        reportError(TEMPLATE_TYPE_EXPECTED, fnName);
    }
    for (String inexistentName : allJsDocParams) {
        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);
    }
    parametersNode = builder.build();
    return this;
}","public void test2226() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""0"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""0"", compiler0, node0, ""0"", (Scope) null);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferParameterTypes((Node) null, (JSDocInfo) null);
    assertSame(functionTypeBuilder0, functionTypeBuilder1);
}","/**
 * Infer the parameter types from the list of argument names and
 * the doc info.
 */"
"FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {
    if (argsParent == null) {
        if (info == null) {
            return this;
        } else {
            return inferParameterTypes(info);
        }
    }
    // arguments
    Node oldParameterType = null;
    if (parametersNode != null) {
        oldParameterType = parametersNode.getFirstChild();
    }
    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);
    boolean warnedAboutArgList = false;
    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());
    boolean foundTemplateType = false;
    for (Node arg : argsParent.children()) {
        String argumentName = arg.getString();
        allJsDocParams.remove(argumentName);
        // type from JSDocInfo
        JSType parameterType = null;
        boolean isOptionalParam = isOptionalParameter(arg, info);
        boolean isVarArgs = isVarArgsParameter(arg, info);
        if (info != null && info.hasParameterType(argumentName)) {
            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);
        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {
            parameterType = oldParameterType.getJSType();
            isOptionalParam = oldParameterType.isOptionalArg();
            isVarArgs = oldParameterType.isVarArgs();
        } else {
            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);
        }
        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {
            if (foundTemplateType) {
                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);
            }
            foundTemplateType = true;
        }
        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);
        if (oldParameterType != null) {
            oldParameterType = oldParameterType.getNext();
        }
    }
    if (templateTypeName != null && !foundTemplateType) {
        reportError(TEMPLATE_TYPE_EXPECTED, fnName);
    }
    for (String inexistentName : allJsDocParams) {
        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);
    }
    parametersNode = builder.build();
    return this;
}","public void test2327() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""0"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""0"", compiler0, node0, ""0"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferParameterTypes((Node) null, jSDocInfo0);
    assertSame(functionTypeBuilder1, functionTypeBuilder0);
}","/**
 * Infer the parameter types from the list of argument names and
 * the doc info.
 */"
"public boolean isReturnTypeInferred() {
    return call.returnTypeInferred;
}","public void test2428() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""2"", ""2"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""2"", compiler0, node0, ""2"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferParameterTypes(jSDocInfo0);
    FunctionType functionType0 = functionTypeBuilder1.buildAndRegister();
    assertFalse(functionType0.isReturnTypeInferred());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test2429() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""2"", ""2"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""2"", compiler0, node0, ""2"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferParameterTypes(jSDocInfo0);
    FunctionType functionType0 = functionTypeBuilder1.buildAndRegister();
    assertFalse(functionType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2430() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""2"", ""2"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""2"", compiler0, node0, ""2"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferParameterTypes(jSDocInfo0);
    FunctionType functionType0 = functionTypeBuilder1.buildAndRegister();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSType[] jSTypeArray0 = new JSType[1];
    jSTypeArray0[0] = (JSType) functionType0;
    Node node1 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
    functionTypeBuilder1.inferParameterTypes(node1, (JSDocInfo) null);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2531() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""JSC_THIS_TYPE_NON_OBJECT"", ""JSC_THIS_TYPE_NON_OBJECT"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""JSC_THIS_TYPE_NON_OBJECT"", compiler0, node0, ""JSC_THIS_TYPE_NON_OBJECT"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
    JSType[] jSTypeArray0 = new JSType[3];
    jSTypeArray0[0] = (JSType) functionType0;
    jSTypeArray0[1] = (JSType) functionType0;
    jSTypeArray0[2] = (JSType) functionType0;
    Node node1 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
    functionTypeBuilder0.inferParameterTypes(node1, jSDocInfo0);
    functionTypeBuilder0.inferParameterTypes(node1, jSDocInfo0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2632() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""JSC_THIS_TYPE_NON_OBJECT"", ""JSC_THIS_TYPE_NON_OBJECT"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""JSC_THIS_TYPE_NON_OBJECT"", compiler0, node0, ""JSC_THIS_TYPE_NON_OBJECT"", (Scope) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
    functionTypeBuilder0.inferFromOverriddenFunction(functionType0, node0);
    JSType[] jSTypeArray0 = new JSType[3];
    jSTypeArray0[0] = (JSType) functionType0;
    jSTypeArray0[1] = (JSType) functionType0;
    jSTypeArray0[2] = (JSType) functionType0;
    Node node1 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
    functionTypeBuilder0.inferParameterTypes(node1, jSDocInfo0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) {
    if (info != null) {
        templateTypeName = info.getTemplateTypeName();
        typeRegistry.setTemplateTypeName(templateTypeName);
    }
    return this;
}","public void test2733() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""0"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""0"", compiler0, node0, ""0"", (Scope) null);
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferTemplateTypeName((JSDocInfo) null);
    assertSame(functionTypeBuilder1, functionTypeBuilder0);
}","/**
 * Infer the template type from the doc info.
 */"
"FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) {
    if (info != null) {
        templateTypeName = info.getTemplateTypeName();
        typeRegistry.setTemplateTypeName(templateTypeName);
    }
    return this;
}","public void test2834() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""prefix must start with one of: "");
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    Scope scope0 = new Scope(node0, objectType0);
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder("""", compiler0, node0, ""Not declared as a type name"", scope0);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    FunctionTypeBuilder functionTypeBuilder1 = functionTypeBuilder0.inferTemplateTypeName(jSDocInfo0);
    assertSame(functionTypeBuilder0, functionTypeBuilder1);
}","/**
 * Infer the template type from the doc info.
 */"
"FunctionType buildAndRegister() {
    if (returnType == null) {
        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);
    }
    if (parametersNode == null) {
        throw new IllegalStateException(""All Function types must have params and a return type"");
    }
    FunctionType fnType;
    if (isConstructor) {
        fnType = getOrCreateConstructor();
    } else if (isInterface) {
        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);
        if (scope.isGlobal() && !fnName.isEmpty()) {
            typeRegistry.declareType(fnName, fnType.getInstanceType());
        }
        maybeSetBaseType(fnType);
    } else {
        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();
        maybeSetBaseType(fnType);
    }
    if (implementedInterfaces != null) {
        fnType.setImplementedInterfaces(implementedInterfaces);
    }
    typeRegistry.clearTemplateTypeName();
    return fnType;
}","public void test2935() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Cy9eq]"");
    FunctionTypeBuilder functionTypeBuilder0 = new FunctionTypeBuilder(""Cy9eq]"", compiler0, node0, ""Cy9eq]"", (Scope) null);
    // Undeclared exception!
    try {
        functionTypeBuilder0.buildAndRegister();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // All Function types must have params and a return type
        //
        verifyException(""com.google.javascript.jscomp.FunctionTypeBuilder"", e);
    }
}","/**
 * Builds the function type, and puts it in the registry.
 */"
"static boolean isFunctionTypeDeclaration(JSDocInfo info) {
    return info.getParameterCount() > 0 || info.hasReturnType() || info.hasThisType() || info.isConstructor() || info.isInterface();
}","public void test3036() throws Throwable {
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    boolean boolean0 = FunctionTypeBuilder.isFunctionTypeDeclaration(jSDocInfo0);
    assertFalse(boolean0);
}","/**
 * Determines whether the given jsdoc info declares a function type.
 */"
