focal_method,test_prefix,docstring
"public void process(Node externs, Node root) {
    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());
    NodeTraversal.traverse(compiler, externs, new ProcessExternedProperties());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    // Gather the properties to rename, sorted by count.
    SortedSet<Property> propsByFrequency = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Iterator<Map.Entry<String, Property>> it = properties.entrySet().iterator(); it.hasNext(); ) {
        Property a = it.next().getValue();
        if (a.canRename() && !reservedNames.contains(a.oldName)) {
            propsByFrequency.add(a);
        } else {
            it.remove();
            // If we're not renaming this, make sure we don't name something
            // else to this name.
            reservedNames.add(a.oldName);
        }
    }
    // Try and reuse as many names from the previous compilation as possible.
    if (prevUsedRenameMap != null) {
        reusePrototypeNames(propsByFrequency);
    }
    // Generate new names.
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    StringBuilder debug = new StringBuilder();
    for (Property a : propsByFrequency) {
        if (a.newName == null) {
            a.newName = nameGen.generateNextName();
            reservedNames.add(a.newName);
        }
        debug.append(a.oldName).append("" => "").append(a.newName).append('\n');
    }
    compiler.addToDebugLog(""JS property assignments:\n"" + debug);
    // Update the string nodes.
    boolean changed = false;
    for (Node n : stringNodes) {
        String oldName = n.getString();
        Property a = properties.get(oldName);
        if (a != null && a.newName != null) {
            n.setString(a.newName);
            changed = changed || !a.newName.equals(oldName);
        }
    }
    if (changed) {
        compiler.reportCodeChange();
    }
    compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED_OBFUSCATED);
}","public void test00() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED_OBFUSCATED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    RenamePrototypes renamePrototypes0 = new RenamePrototypes(compiler0, false, (char[]) null, (VariableMap) null);
    Node node0 = Node.newString(""KN"");
    LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.init((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
    Node node1 = new Node(64, node0, node0, node0);
    renamePrototypes0.process(node0, node1);
    assertEquals(26, Node.DIRECTCALL_PROP);
}","/**
 * Does property/method renaming.
 *
 * @param externs The root of the externs parse tree
 * @param root The root of the main code parse tree
 */"
"public void process(Node externs, Node root) {
    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());
    NodeTraversal.traverse(compiler, externs, new ProcessExternedProperties());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    // Gather the properties to rename, sorted by count.
    SortedSet<Property> propsByFrequency = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Iterator<Map.Entry<String, Property>> it = properties.entrySet().iterator(); it.hasNext(); ) {
        Property a = it.next().getValue();
        if (a.canRename() && !reservedNames.contains(a.oldName)) {
            propsByFrequency.add(a);
        } else {
            it.remove();
            // If we're not renaming this, make sure we don't name something
            // else to this name.
            reservedNames.add(a.oldName);
        }
    }
    // Try and reuse as many names from the previous compilation as possible.
    if (prevUsedRenameMap != null) {
        reusePrototypeNames(propsByFrequency);
    }
    // Generate new names.
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    StringBuilder debug = new StringBuilder();
    for (Property a : propsByFrequency) {
        if (a.newName == null) {
            a.newName = nameGen.generateNextName();
            reservedNames.add(a.newName);
        }
        debug.append(a.oldName).append("" => "").append(a.newName).append('\n');
    }
    compiler.addToDebugLog(""JS property assignments:\n"" + debug);
    // Update the string nodes.
    boolean changed = false;
    for (Node n : stringNodes) {
        String oldName = n.getString();
        Property a = properties.get(oldName);
        if (a != null && a.newName != null) {
            n.setString(a.newName);
            changed = changed || !a.newName.equals(oldName);
        }
    }
    if (changed) {
        compiler.reportCodeChange();
    }
    compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED_OBFUSCATED);
}","public void test11() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    RenamePrototypes renamePrototypes0 = new RenamePrototypes(compiler0, true, (char[]) null, (VariableMap) null);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""cm.google.javascrip.jscomp.RenmePrototypes$ProcessPropertes"", ""cm.google.javascrip.jscomp.RenmePrototypes$ProcessPropertes"");
    renamePrototypes0.process(node0, node0);
    assertEquals(31, Node.INCRDECR_PROP);
}","/**
 * Does property/method renaming.
 *
 * @param externs The root of the externs parse tree
 * @param root The root of the main code parse tree
 */"
"public void process(Node externs, Node root) {
    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());
    NodeTraversal.traverse(compiler, externs, new ProcessExternedProperties());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    // Gather the properties to rename, sorted by count.
    SortedSet<Property> propsByFrequency = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Iterator<Map.Entry<String, Property>> it = properties.entrySet().iterator(); it.hasNext(); ) {
        Property a = it.next().getValue();
        if (a.canRename() && !reservedNames.contains(a.oldName)) {
            propsByFrequency.add(a);
        } else {
            it.remove();
            // If we're not renaming this, make sure we don't name something
            // else to this name.
            reservedNames.add(a.oldName);
        }
    }
    // Try and reuse as many names from the previous compilation as possible.
    if (prevUsedRenameMap != null) {
        reusePrototypeNames(propsByFrequency);
    }
    // Generate new names.
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    StringBuilder debug = new StringBuilder();
    for (Property a : propsByFrequency) {
        if (a.newName == null) {
            a.newName = nameGen.generateNextName();
            reservedNames.add(a.newName);
        }
        debug.append(a.oldName).append("" => "").append(a.newName).append('\n');
    }
    compiler.addToDebugLog(""JS property assignments:\n"" + debug);
    // Update the string nodes.
    boolean changed = false;
    for (Node n : stringNodes) {
        String oldName = n.getString();
        Property a = properties.get(oldName);
        if (a != null && a.newName != null) {
            n.setString(a.newName);
            changed = changed || !a.newName.equals(oldName);
        }
    }
    if (changed) {
        compiler.reportCodeChange();
    }
    compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED_OBFUSCATED);
}","public void test22() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""cm.google.javascrnp.jscomp.RenmeProWotypes$ProcessPropertes"", ""cm.google.javascrnp.jscomp.RenmeProWotypes$ProcessPropertes"");
    Node node1 = Node.newString("".B-nmF}S]~"", 262, (-1548));
    char[] charArray0 = new char[5];
    RenamePrototypes renamePrototypes0 = new RenamePrototypes(compiler0, false, charArray0, (VariableMap) null);
    Node node2 = new Node(35, node0, node1, node1);
    renamePrototypes0.process(node0, node2);
    assertEquals(18, Node.SPECIAL_PROP_PROP);
}","/**
 * Does property/method renaming.
 *
 * @param externs The root of the externs parse tree
 * @param root The root of the main code parse tree
 */"
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test33() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED_OBFUSCATED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    RenamePrototypes renamePrototypes0 = new RenamePrototypes(compiler0, false, (char[]) null, (VariableMap) null);
    Node node0 = Node.newString(64, ""com.google.javascript.jscomp.PureFunctionIdentifier$FunctionInformation"", 2534, 2534);
    LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.init((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
    Node node1 = compiler0.parseSyntheticCode(""vMzVZ"");
    Node node2 = new Node(35, node0, node0, node1);
    renamePrototypes0.process(node2, node2);
    assertEquals((-1), node2.getCharno());
}",""
"public void process(Node externs, Node root) {
    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());
    NodeTraversal.traverse(compiler, externs, new ProcessExternedProperties());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    // Gather the properties to rename, sorted by count.
    SortedSet<Property> propsByFrequency = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Iterator<Map.Entry<String, Property>> it = properties.entrySet().iterator(); it.hasNext(); ) {
        Property a = it.next().getValue();
        if (a.canRename() && !reservedNames.contains(a.oldName)) {
            propsByFrequency.add(a);
        } else {
            it.remove();
            // If we're not renaming this, make sure we don't name something
            // else to this name.
            reservedNames.add(a.oldName);
        }
    }
    // Try and reuse as many names from the previous compilation as possible.
    if (prevUsedRenameMap != null) {
        reusePrototypeNames(propsByFrequency);
    }
    // Generate new names.
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    StringBuilder debug = new StringBuilder();
    for (Property a : propsByFrequency) {
        if (a.newName == null) {
            a.newName = nameGen.generateNextName();
            reservedNames.add(a.newName);
        }
        debug.append(a.oldName).append("" => "").append(a.newName).append('\n');
    }
    compiler.addToDebugLog(""JS property assignments:\n"" + debug);
    // Update the string nodes.
    boolean changed = false;
    for (Node n : stringNodes) {
        String oldName = n.getString();
        Property a = properties.get(oldName);
        if (a != null && a.newName != null) {
            n.setString(a.newName);
            changed = changed || !a.newName.equals(oldName);
        }
    }
    if (changed) {
        compiler.reportCodeChange();
    }
    compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED_OBFUSCATED);
}","public void test44() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    RenamePrototypes renamePrototypes0 = new RenamePrototypes(compiler0, true, (char[]) null, (VariableMap) null);
    Node node0 = new Node(64, 64, 64);
    Node node1 = Node.newNumber((double) 0, 17, 16);
    node0.addChildToBack(node1);
    renamePrototypes0.process(node0, node0);
    assertEquals(23, Node.VARIABLE_PROP);
}","/**
 * Does property/method renaming.
 *
 * @param externs The root of the externs parse tree
 * @param root The root of the main code parse tree
 */"
"public void process(Node externs, Node root) {
    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());
    NodeTraversal.traverse(compiler, externs, new ProcessExternedProperties());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    // Gather the properties to rename, sorted by count.
    SortedSet<Property> propsByFrequency = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Iterator<Map.Entry<String, Property>> it = properties.entrySet().iterator(); it.hasNext(); ) {
        Property a = it.next().getValue();
        if (a.canRename() && !reservedNames.contains(a.oldName)) {
            propsByFrequency.add(a);
        } else {
            it.remove();
            // If we're not renaming this, make sure we don't name something
            // else to this name.
            reservedNames.add(a.oldName);
        }
    }
    // Try and reuse as many names from the previous compilation as possible.
    if (prevUsedRenameMap != null) {
        reusePrototypeNames(propsByFrequency);
    }
    // Generate new names.
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    StringBuilder debug = new StringBuilder();
    for (Property a : propsByFrequency) {
        if (a.newName == null) {
            a.newName = nameGen.generateNextName();
            reservedNames.add(a.newName);
        }
        debug.append(a.oldName).append("" => "").append(a.newName).append('\n');
    }
    compiler.addToDebugLog(""JS property assignments:\n"" + debug);
    // Update the string nodes.
    boolean changed = false;
    for (Node n : stringNodes) {
        String oldName = n.getString();
        Property a = properties.get(oldName);
        if (a != null && a.newName != null) {
            n.setString(a.newName);
            changed = changed || !a.newName.equals(oldName);
        }
    }
    if (changed) {
        compiler.reportCodeChange();
    }
    compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED_OBFUSCATED);
}","public void test55() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    TreeMap<String, String> treeMap0 = new TreeMap<String, String>();
    VariableMap variableMap0 = new VariableMap(treeMap0);
    RenamePrototypes renamePrototypes0 = new RenamePrototypes(compiler0, false, (char[]) null, variableMap0);
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""cm.google.javascrip.jscomp.RenmePrototypes$ProcessPropertes"", ""cm.google.javascrip.jscomp.RenmePrototypes$ProcessPropertes"");
    Node node1 = compiler0.parseTestCode(""cm.google.javascrip.jscomp.RenmePrototypes$ProcessPropertes"");
    node1.addChildToBack(node0);
    renamePrototypes0.process(node1, node1);
    assertEquals(22, Node.TARGETBLOCK_PROP);
}","/**
 * Does property/method renaming.
 *
 * @param externs The root of the externs parse tree
 * @param root The root of the main code parse tree
 */"
"VariableMap getPropertyMap() {
    Map<String, String> map = new HashMap<String, String>();
    for (Property p : properties.values()) {
        if (p.newName != null) {
            map.put(p.oldName, p.newName);
        }
    }
    return new VariableMap(map);
}","public void test66() throws Throwable {
    Compiler compiler0 = new Compiler();
    RenamePrototypes renamePrototypes0 = new RenamePrototypes(compiler0, true, (char[]) null, (VariableMap) null);
    VariableMap variableMap0 = renamePrototypes0.getPropertyMap();
    assertNotNull(variableMap0);
}","/**
 * Gets the property renaming map.
 *
 * @return A mapping from original names to new names
 */"
