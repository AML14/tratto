focal_method,test_prefix,docstring
"public boolean isDrawLines() {
    return this.plotLines;
}","public void test000() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    Color color0 = Color.MAGENTA;
    minMaxCategoryRenderer0.setGroupPaint(color0);
    Color color1 = (Color) minMaxCategoryRenderer0.getGroupPaint();
    assertFalse(minMaxCategoryRenderer0.isDrawLines());
}","/**
 * Gets whether or not lines are drawn between category points.
 *
 * @return boolean true if line will be drawn between sequenced categories,
 *         otherwise false.
 *
 * @see #setDrawLines(boolean)
 */"
"public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset dataset, int row, int column, int pass) {
    // first check the number we are plotting...
    Number value = dataset.getValue(row, column);
    if (value != null) {
        // current data point...
        double x1 = domainAxis.getCategoryMiddle(column, getColumnCount(), dataArea, plot.getDomainAxisEdge());
        double y1 = rangeAxis.valueToJava2D(value.doubleValue(), dataArea, plot.getRangeAxisEdge());
        g2.setPaint(getItemPaint(row, column));
        g2.setStroke(getItemStroke(row, column));
        Shape shape = null;
        shape = new Rectangle2D.Double(x1 - 4, y1 - 4, 8.0, 8.0);
        PlotOrientation orient = plot.getOrientation();
        if (orient == PlotOrientation.VERTICAL) {
            this.objectIcon.paintIcon(null, g2, (int) x1, (int) y1);
        } else {
            this.objectIcon.paintIcon(null, g2, (int) y1, (int) x1);
        }
        if (this.lastCategory == column) {
            if (this.min > value.doubleValue()) {
                this.min = value.doubleValue();
            }
            if (this.max < value.doubleValue()) {
                this.max = value.doubleValue();
            }
            // last series, so we are ready to draw the min and max
            if (dataset.getRowCount() - 1 == row) {
                g2.setPaint(this.groupPaint);
                g2.setStroke(this.groupStroke);
                double minY = rangeAxis.valueToJava2D(this.min, dataArea, plot.getRangeAxisEdge());
                double maxY = rangeAxis.valueToJava2D(this.max, dataArea, plot.getRangeAxisEdge());
                if (orient == PlotOrientation.VERTICAL) {
                    g2.draw(new Line2D.Double(x1, minY, x1, maxY));
                    this.minIcon.paintIcon(null, g2, (int) x1, (int) minY);
                    this.maxIcon.paintIcon(null, g2, (int) x1, (int) maxY);
                } else {
                    g2.draw(new Line2D.Double(minY, x1, maxY, x1));
                    this.minIcon.paintIcon(null, g2, (int) minY, (int) x1);
                    this.maxIcon.paintIcon(null, g2, (int) maxY, (int) x1);
                }
            }
        } else {
            // reset the min and max
            this.lastCategory = column;
            this.min = value.doubleValue();
            this.max = value.doubleValue();
        }
        // connect to the previous point
        if (this.plotLines) {
            if (column != 0) {
                Number previousValue = dataset.getValue(row, column - 1);
                if (previousValue != null) {
                    // previous data point...
                    double previous = previousValue.doubleValue();
                    double x0 = domainAxis.getCategoryMiddle(column - 1, getColumnCount(), dataArea, plot.getDomainAxisEdge());
                    double y0 = rangeAxis.valueToJava2D(previous, dataArea, plot.getRangeAxisEdge());
                    g2.setPaint(getItemPaint(row, column));
                    g2.setStroke(getItemStroke(row, column));
                    Line2D line;
                    if (orient == PlotOrientation.VERTICAL) {
                        line = new Line2D.Double(x0, y0, x1, y1);
                    } else {
                        line = new Line2D.Double(y0, x0, y1, x1);
                    }
                    g2.draw(line);
                }
            }
        }
        // add an item entity, if this information is being collected
        EntityCollection entities = state.getEntityCollection();
        if (entities != null && shape != null) {
            addItemEntity(entities, dataset, row, column, shape);
        }
    }
}","public void test012() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    CategoryAxis3D categoryAxis3D0 = new CategoryAxis3D(""iS~"");
    CombinedDomainCategoryPlot combinedDomainCategoryPlot0 = new CombinedDomainCategoryPlot(categoryAxis3D0);
    JFreeChart jFreeChart0 = new JFreeChart(combinedDomainCategoryPlot0);
    ChartRenderingInfo chartRenderingInfo0 = new ChartRenderingInfo((EntityCollection) null);
    BufferedImage bufferedImage0 = jFreeChart0.createBufferedImage(93, 10, 2201.36027707, 1.0, chartRenderingInfo0);
    Graphics2D graphics2D0 = bufferedImage0.createGraphics();
    PlotRenderingInfo plotRenderingInfo0 = new PlotRenderingInfo(chartRenderingInfo0);
    CategoryItemRendererState categoryItemRendererState0 = minMaxCategoryRenderer0.createState(plotRenderingInfo0);
    ChartPanel chartPanel0 = new ChartPanel(jFreeChart0, true);
    Rectangle rectangle0 = chartPanel0.getVisibleRect();
    PeriodAxis periodAxis0 = new PeriodAxis(""ZOOM_DOMAIN_BOTH"");
    // Undeclared exception!
    try {
        minMaxCategoryRenderer0.drawItem(graphics2D0, categoryItemRendererState0, rectangle0, combinedDomainCategoryPlot0, categoryAxis3D0, periodAxis0, (CategoryDataset) null, 243, (-5042), 53);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jfree.chart.renderer.category.MinMaxCategoryRenderer"", e);
    }
}","/**
 * Draw a single data item.
 *
 * @param g2  the graphics device.
 * @param state  the renderer state.
 * @param dataArea  the area in which the data is drawn.
 * @param plot  the plot.
 * @param domainAxis  the domain axis.
 * @param rangeAxis  the range axis.
 * @param dataset  the dataset.
 * @param row  the row index (zero-based).
 * @param column  the column index (zero-based).
 * @param pass  the pass index.
 */"
"public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset dataset, int row, int column, int pass) {
    // first check the number we are plotting...
    Number value = dataset.getValue(row, column);
    if (value != null) {
        // current data point...
        double x1 = domainAxis.getCategoryMiddle(column, getColumnCount(), dataArea, plot.getDomainAxisEdge());
        double y1 = rangeAxis.valueToJava2D(value.doubleValue(), dataArea, plot.getRangeAxisEdge());
        g2.setPaint(getItemPaint(row, column));
        g2.setStroke(getItemStroke(row, column));
        Shape shape = null;
        shape = new Rectangle2D.Double(x1 - 4, y1 - 4, 8.0, 8.0);
        PlotOrientation orient = plot.getOrientation();
        if (orient == PlotOrientation.VERTICAL) {
            this.objectIcon.paintIcon(null, g2, (int) x1, (int) y1);
        } else {
            this.objectIcon.paintIcon(null, g2, (int) y1, (int) x1);
        }
        if (this.lastCategory == column) {
            if (this.min > value.doubleValue()) {
                this.min = value.doubleValue();
            }
            if (this.max < value.doubleValue()) {
                this.max = value.doubleValue();
            }
            // last series, so we are ready to draw the min and max
            if (dataset.getRowCount() - 1 == row) {
                g2.setPaint(this.groupPaint);
                g2.setStroke(this.groupStroke);
                double minY = rangeAxis.valueToJava2D(this.min, dataArea, plot.getRangeAxisEdge());
                double maxY = rangeAxis.valueToJava2D(this.max, dataArea, plot.getRangeAxisEdge());
                if (orient == PlotOrientation.VERTICAL) {
                    g2.draw(new Line2D.Double(x1, minY, x1, maxY));
                    this.minIcon.paintIcon(null, g2, (int) x1, (int) minY);
                    this.maxIcon.paintIcon(null, g2, (int) x1, (int) maxY);
                } else {
                    g2.draw(new Line2D.Double(minY, x1, maxY, x1));
                    this.minIcon.paintIcon(null, g2, (int) minY, (int) x1);
                    this.maxIcon.paintIcon(null, g2, (int) maxY, (int) x1);
                }
            }
        } else {
            // reset the min and max
            this.lastCategory = column;
            this.min = value.doubleValue();
            this.max = value.doubleValue();
        }
        // connect to the previous point
        if (this.plotLines) {
            if (column != 0) {
                Number previousValue = dataset.getValue(row, column - 1);
                if (previousValue != null) {
                    // previous data point...
                    double previous = previousValue.doubleValue();
                    double x0 = domainAxis.getCategoryMiddle(column - 1, getColumnCount(), dataArea, plot.getDomainAxisEdge());
                    double y0 = rangeAxis.valueToJava2D(previous, dataArea, plot.getRangeAxisEdge());
                    g2.setPaint(getItemPaint(row, column));
                    g2.setStroke(getItemStroke(row, column));
                    Line2D line;
                    if (orient == PlotOrientation.VERTICAL) {
                        line = new Line2D.Double(x0, y0, x1, y1);
                    } else {
                        line = new Line2D.Double(y0, x0, y1, x1);
                    }
                    g2.draw(line);
                }
            }
        }
        // add an item entity, if this information is being collected
        EntityCollection entities = state.getEntityCollection();
        if (entities != null && shape != null) {
            addItemEntity(entities, dataset, row, column, shape);
        }
    }
}","public void test023() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    BoxAndWhiskerRenderer boxAndWhiskerRenderer0 = new BoxAndWhiskerRenderer();
    MockDate mockDate0 = (MockDate) DateAxis.DEFAULT_ANCHOR_DATE;
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(mockDate0);
    PeriodAxis periodAxis0 = new PeriodAxis("""", fixedMillisecond0, fixedMillisecond0);
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot(periodAxis0);
    ChartRenderingInfo chartRenderingInfo0 = new ChartRenderingInfo();
    PlotRenderingInfo plotRenderingInfo0 = new PlotRenderingInfo(chartRenderingInfo0);
    CategoryItemRendererState categoryItemRendererState0 = boxAndWhiskerRenderer0.initialise((Graphics2D) null, (Rectangle2D) null, combinedRangeCategoryPlot0, 10, plotRenderingInfo0);
    CategoryAxis categoryAxis0 = new CategoryAxis();
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    // Undeclared exception!
    try {
        minMaxCategoryRenderer0.drawItem((Graphics2D) null, categoryItemRendererState0, (Rectangle2D) null, combinedRangeCategoryPlot0, categoryAxis0, periodAxis0, defaultKeyedValues2DDataset0, 1, 1, 1);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 1, Size: 0
        //
        verifyException(""java.util.ArrayList"", e);
    }
}","/**
 * Draw a single data item.
 *
 * @param g2  the graphics device.
 * @param state  the renderer state.
 * @param dataArea  the area in which the data is drawn.
 * @param plot  the plot.
 * @param domainAxis  the domain axis.
 * @param rangeAxis  the range axis.
 * @param dataset  the dataset.
 * @param row  the row index (zero-based).
 * @param column  the column index (zero-based).
 * @param pass  the pass index.
 */"
"public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset dataset, int row, int column, int pass) {
    // first check the number we are plotting...
    Number value = dataset.getValue(row, column);
    if (value != null) {
        // current data point...
        double x1 = domainAxis.getCategoryMiddle(column, getColumnCount(), dataArea, plot.getDomainAxisEdge());
        double y1 = rangeAxis.valueToJava2D(value.doubleValue(), dataArea, plot.getRangeAxisEdge());
        g2.setPaint(getItemPaint(row, column));
        g2.setStroke(getItemStroke(row, column));
        Shape shape = null;
        shape = new Rectangle2D.Double(x1 - 4, y1 - 4, 8.0, 8.0);
        PlotOrientation orient = plot.getOrientation();
        if (orient == PlotOrientation.VERTICAL) {
            this.objectIcon.paintIcon(null, g2, (int) x1, (int) y1);
        } else {
            this.objectIcon.paintIcon(null, g2, (int) y1, (int) x1);
        }
        if (this.lastCategory == column) {
            if (this.min > value.doubleValue()) {
                this.min = value.doubleValue();
            }
            if (this.max < value.doubleValue()) {
                this.max = value.doubleValue();
            }
            // last series, so we are ready to draw the min and max
            if (dataset.getRowCount() - 1 == row) {
                g2.setPaint(this.groupPaint);
                g2.setStroke(this.groupStroke);
                double minY = rangeAxis.valueToJava2D(this.min, dataArea, plot.getRangeAxisEdge());
                double maxY = rangeAxis.valueToJava2D(this.max, dataArea, plot.getRangeAxisEdge());
                if (orient == PlotOrientation.VERTICAL) {
                    g2.draw(new Line2D.Double(x1, minY, x1, maxY));
                    this.minIcon.paintIcon(null, g2, (int) x1, (int) minY);
                    this.maxIcon.paintIcon(null, g2, (int) x1, (int) maxY);
                } else {
                    g2.draw(new Line2D.Double(minY, x1, maxY, x1));
                    this.minIcon.paintIcon(null, g2, (int) minY, (int) x1);
                    this.maxIcon.paintIcon(null, g2, (int) maxY, (int) x1);
                }
            }
        } else {
            // reset the min and max
            this.lastCategory = column;
            this.min = value.doubleValue();
            this.max = value.doubleValue();
        }
        // connect to the previous point
        if (this.plotLines) {
            if (column != 0) {
                Number previousValue = dataset.getValue(row, column - 1);
                if (previousValue != null) {
                    // previous data point...
                    double previous = previousValue.doubleValue();
                    double x0 = domainAxis.getCategoryMiddle(column - 1, getColumnCount(), dataArea, plot.getDomainAxisEdge());
                    double y0 = rangeAxis.valueToJava2D(previous, dataArea, plot.getRangeAxisEdge());
                    g2.setPaint(getItemPaint(row, column));
                    g2.setStroke(getItemStroke(row, column));
                    Line2D line;
                    if (orient == PlotOrientation.VERTICAL) {
                        line = new Line2D.Double(x0, y0, x1, y1);
                    } else {
                        line = new Line2D.Double(y0, x0, y1, x1);
                    }
                    g2.draw(line);
                }
            }
        }
        // add an item entity, if this information is being collected
        EntityCollection entities = state.getEntityCollection();
        if (entities != null && shape != null) {
            addItemEntity(entities, dataset, row, column, shape);
        }
    }
}","public void test034() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    CategoryAxis3D categoryAxis3D0 = new CategoryAxis3D(""iS~"");
    CombinedDomainCategoryPlot combinedDomainCategoryPlot0 = new CombinedDomainCategoryPlot(categoryAxis3D0);
    JFreeChart jFreeChart0 = new JFreeChart(combinedDomainCategoryPlot0);
    ChartRenderingInfo chartRenderingInfo0 = new ChartRenderingInfo((EntityCollection) null);
    BufferedImage bufferedImage0 = jFreeChart0.createBufferedImage(10, 10, (double) 1.0F, (double) 10, chartRenderingInfo0);
    Graphics2D graphics2D0 = bufferedImage0.createGraphics();
    PlotRenderingInfo plotRenderingInfo0 = new PlotRenderingInfo(chartRenderingInfo0);
    CategoryItemRendererState categoryItemRendererState0 = minMaxCategoryRenderer0.createState(plotRenderingInfo0);
    ChartPanel chartPanel0 = new ChartPanel(jFreeChart0, true);
    Rectangle rectangle0 = chartPanel0.getVisibleRect();
    Minute minute0 = new Minute();
    Second second0 = new Second(600, minute0);
    PeriodAxis periodAxis0 = new PeriodAxis(""l>V-^\""}P"", second0, minute0);
    DefaultIntervalCategoryDataset defaultIntervalCategoryDataset0 = new DefaultIntervalCategoryDataset((Number[][]) null, (Number[][]) null);
    // Undeclared exception!
    try {
        minMaxCategoryRenderer0.drawItem(graphics2D0, categoryItemRendererState0, rectangle0, combinedDomainCategoryPlot0, categoryAxis3D0, periodAxis0, defaultIntervalCategoryDataset0, 59, 680, 500);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DefaultIntervalCategoryDataset.getValue(): series index out of range.
        //
        verifyException(""org.jfree.data.category.DefaultIntervalCategoryDataset"", e);
    }
}","/**
 * Draw a single data item.
 *
 * @param g2  the graphics device.
 * @param state  the renderer state.
 * @param dataArea  the area in which the data is drawn.
 * @param plot  the plot.
 * @param domainAxis  the domain axis.
 * @param rangeAxis  the range axis.
 * @param dataset  the dataset.
 * @param row  the row index (zero-based).
 * @param column  the column index (zero-based).
 * @param pass  the pass index.
 */"
"public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset dataset, int row, int column, int pass) {
    // first check the number we are plotting...
    Number value = dataset.getValue(row, column);
    if (value != null) {
        // current data point...
        double x1 = domainAxis.getCategoryMiddle(column, getColumnCount(), dataArea, plot.getDomainAxisEdge());
        double y1 = rangeAxis.valueToJava2D(value.doubleValue(), dataArea, plot.getRangeAxisEdge());
        g2.setPaint(getItemPaint(row, column));
        g2.setStroke(getItemStroke(row, column));
        Shape shape = null;
        shape = new Rectangle2D.Double(x1 - 4, y1 - 4, 8.0, 8.0);
        PlotOrientation orient = plot.getOrientation();
        if (orient == PlotOrientation.VERTICAL) {
            this.objectIcon.paintIcon(null, g2, (int) x1, (int) y1);
        } else {
            this.objectIcon.paintIcon(null, g2, (int) y1, (int) x1);
        }
        if (this.lastCategory == column) {
            if (this.min > value.doubleValue()) {
                this.min = value.doubleValue();
            }
            if (this.max < value.doubleValue()) {
                this.max = value.doubleValue();
            }
            // last series, so we are ready to draw the min and max
            if (dataset.getRowCount() - 1 == row) {
                g2.setPaint(this.groupPaint);
                g2.setStroke(this.groupStroke);
                double minY = rangeAxis.valueToJava2D(this.min, dataArea, plot.getRangeAxisEdge());
                double maxY = rangeAxis.valueToJava2D(this.max, dataArea, plot.getRangeAxisEdge());
                if (orient == PlotOrientation.VERTICAL) {
                    g2.draw(new Line2D.Double(x1, minY, x1, maxY));
                    this.minIcon.paintIcon(null, g2, (int) x1, (int) minY);
                    this.maxIcon.paintIcon(null, g2, (int) x1, (int) maxY);
                } else {
                    g2.draw(new Line2D.Double(minY, x1, maxY, x1));
                    this.minIcon.paintIcon(null, g2, (int) minY, (int) x1);
                    this.maxIcon.paintIcon(null, g2, (int) maxY, (int) x1);
                }
            }
        } else {
            // reset the min and max
            this.lastCategory = column;
            this.min = value.doubleValue();
            this.max = value.doubleValue();
        }
        // connect to the previous point
        if (this.plotLines) {
            if (column != 0) {
                Number previousValue = dataset.getValue(row, column - 1);
                if (previousValue != null) {
                    // previous data point...
                    double previous = previousValue.doubleValue();
                    double x0 = domainAxis.getCategoryMiddle(column - 1, getColumnCount(), dataArea, plot.getDomainAxisEdge());
                    double y0 = rangeAxis.valueToJava2D(previous, dataArea, plot.getRangeAxisEdge());
                    g2.setPaint(getItemPaint(row, column));
                    g2.setStroke(getItemStroke(row, column));
                    Line2D line;
                    if (orient == PlotOrientation.VERTICAL) {
                        line = new Line2D.Double(x0, y0, x1, y1);
                    } else {
                        line = new Line2D.Double(y0, x0, y1, x1);
                    }
                    g2.draw(line);
                }
            }
        }
        // add an item entity, if this information is being collected
        EntityCollection entities = state.getEntityCollection();
        if (entities != null && shape != null) {
            addItemEntity(entities, dataset, row, column, shape);
        }
    }
}","public void test045() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) minMaxCategoryRenderer0.lookupSeriesShape(0);
    CategoryAxis3D categoryAxis3D0 = new CategoryAxis3D();
    CategoryPlot categoryPlot0 = new CategoryPlot();
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    // Undeclared exception!
    try {
        minMaxCategoryRenderer0.drawItem((Graphics2D) null, (CategoryItemRendererState) null, rectangle2D_Double0, categoryPlot0, categoryAxis3D0, (ValueAxis) null, defaultKeyedValues2DDataset0, (-2470), 93, 658);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Draw a single data item.
 *
 * @param g2  the graphics device.
 * @param state  the renderer state.
 * @param dataArea  the area in which the data is drawn.
 * @param plot  the plot.
 * @param domainAxis  the domain axis.
 * @param rangeAxis  the range axis.
 * @param dataset  the dataset.
 * @param row  the row index (zero-based).
 * @param column  the column index (zero-based).
 * @param pass  the pass index.
 */"
"public void setMinIcon(Icon icon) {
    if (icon == null) {
        throw new IllegalArgumentException(""Null 'icon' argument."");
    }
    this.minIcon = icon;
    notifyListeners(new RendererChangeEvent(this));
}","public void test056() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    // Undeclared exception!
    try {
        minMaxCategoryRenderer0.setMinIcon((Icon) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'icon' argument.
        //
        verifyException(""org.jfree.chart.renderer.category.MinMaxCategoryRenderer"", e);
    }
}","/**
 * Sets the icon displayed for the minimum value data item within each
 * category and sends a {@link RendererChangeEvent} to all registered
 * listeners.
 *
 * @param icon  the icon (<code>null</code> not permitted).
 *
 * @see #getMinIcon()
 */"
"public boolean isDrawLines() {
    return this.plotLines;
}","public void test067() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    MockFile mockFile0 = new MockFile("""");
    MockJFileChooser mockJFileChooser0 = new MockJFileChooser(mockFile0);
    Icon icon0 = mockJFileChooser0.getIcon(mockFile0);
    minMaxCategoryRenderer0.setMinIcon(icon0);
    assertFalse(minMaxCategoryRenderer0.isDrawLines());
}","/**
 * Gets whether or not lines are drawn between category points.
 *
 * @return boolean true if line will be drawn between sequenced categories,
 *         otherwise false.
 *
 * @see #setDrawLines(boolean)
 */"
"public void setMaxIcon(Icon icon) {
    if (icon == null) {
        throw new IllegalArgumentException(""Null 'icon' argument."");
    }
    this.maxIcon = icon;
    notifyListeners(new RendererChangeEvent(this));
}","public void test078() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    // Undeclared exception!
    try {
        minMaxCategoryRenderer0.setMaxIcon((Icon) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'icon' argument.
        //
        verifyException(""org.jfree.chart.renderer.category.MinMaxCategoryRenderer"", e);
    }
}","/**
 * Sets the icon displayed for the maximum value data item within each
 * category and sends a {@link RendererChangeEvent} to all registered
 * listeners.
 *
 * @param icon  the icon (<code>null</code> not permitted).
 *
 * @see #getMaxIcon()
 */"
"public boolean isDrawLines() {
    return this.plotLines;
}","public void test089() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    MockFile mockFile0 = new MockFile("""");
    MockJFileChooser mockJFileChooser0 = new MockJFileChooser(mockFile0);
    Icon icon0 = mockJFileChooser0.getIcon(mockFile0);
    minMaxCategoryRenderer0.setMaxIcon(icon0);
    assertFalse(minMaxCategoryRenderer0.isDrawLines());
}","/**
 * Gets whether or not lines are drawn between category points.
 *
 * @return boolean true if line will be drawn between sequenced categories,
 *         otherwise false.
 *
 * @see #setDrawLines(boolean)
 */"
"public void setObjectIcon(Icon icon) {
    if (icon == null) {
        throw new IllegalArgumentException(""Null 'icon' argument."");
    }
    this.objectIcon = icon;
    notifyListeners(new RendererChangeEvent(this));
}","public void test0910() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    // Undeclared exception!
    try {
        minMaxCategoryRenderer0.setObjectIcon((Icon) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'icon' argument.
        //
        verifyException(""org.jfree.chart.renderer.category.MinMaxCategoryRenderer"", e);
    }
}","/**
 * Sets the icon drawn for each data item.
 *
 * @param icon  the icon.
 *
 * @see #getObjectIcon()
 */"
"public void setGroupStroke(Stroke stroke) {
    if (stroke == null) {
        throw new IllegalArgumentException(""Null 'stroke' argument."");
    }
    this.groupStroke = stroke;
    notifyListeners(new RendererChangeEvent(this));
}","public void test1011() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    // Undeclared exception!
    try {
        minMaxCategoryRenderer0.setGroupStroke((Stroke) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'stroke' argument.
        //
        verifyException(""org.jfree.chart.renderer.category.MinMaxCategoryRenderer"", e);
    }
}","/**
 * Sets the stroke of the line between the minimum value and the maximum
 * value and sends a {@link RendererChangeEvent} to all registered
 * listeners.
 *
 * @param stroke the new stroke (<code>null</code> not permitted).
 */"
"public boolean isDrawLines() {
    return this.plotLines;
}","public void test1112() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    BasicStroke basicStroke0 = (BasicStroke) CategoryPlot.DEFAULT_GRIDLINE_STROKE;
    minMaxCategoryRenderer0.setGroupStroke(basicStroke0);
    assertFalse(minMaxCategoryRenderer0.isDrawLines());
}","/**
 * Gets whether or not lines are drawn between category points.
 *
 * @return boolean true if line will be drawn between sequenced categories,
 *         otherwise false.
 *
 * @see #setDrawLines(boolean)
 */"
"public void setGroupPaint(Paint paint) {
    if (paint == null) {
        throw new IllegalArgumentException(""Null 'paint' argument."");
    }
    this.groupPaint = paint;
    notifyListeners(new RendererChangeEvent(this));
}","public void test1213() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    // Undeclared exception!
    try {
        minMaxCategoryRenderer0.setGroupPaint((Paint) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'paint' argument.
        //
        verifyException(""org.jfree.chart.renderer.category.MinMaxCategoryRenderer"", e);
    }
}","/**
 * Sets the paint used to draw the line between the minimum and maximum
 * value items in each category and sends a {@link RendererChangeEvent} to
 * all registered listeners.
 *
 * @param paint  the paint (<code>null</code> not permitted).
 *
 * @see #getGroupPaint()
 */"
"public boolean isDrawLines() {
    return this.plotLines;
}","public void test1314() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    assertFalse(minMaxCategoryRenderer0.isDrawLines());
}","/**
 * Gets whether or not lines are drawn between category points.
 *
 * @return boolean true if line will be drawn between sequenced categories,
 *         otherwise false.
 *
 * @see #setDrawLines(boolean)
 */"
"public boolean isDrawLines() {
    return this.plotLines;
}","public void test1315() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    minMaxCategoryRenderer0.setDrawLines(true);
    boolean boolean0 = minMaxCategoryRenderer0.isDrawLines();
    assertTrue(boolean0);
}","/**
 * Gets whether or not lines are drawn between category points.
 *
 * @return boolean true if line will be drawn between sequenced categories,
 *         otherwise false.
 *
 * @see #setDrawLines(boolean)
 */"
"public boolean getBaseCreateEntities() {
    return this.baseCreateEntities;
}","public void test1416() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    minMaxCategoryRenderer0.setDrawLines(false);
    assertTrue(minMaxCategoryRenderer0.getBaseCreateEntities());
}","/**
 * Returns the base visibility for all series.
 *
 * @return The base visibility.
 */"
"public boolean isDrawLines() {
    return this.plotLines;
}","public void test1618() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    minMaxCategoryRenderer0.getMaxIcon();
    assertFalse(minMaxCategoryRenderer0.isDrawLines());
}","/**
 * Gets whether or not lines are drawn between category points.
 *
 * @return boolean true if line will be drawn between sequenced categories,
 *         otherwise false.
 *
 * @see #setDrawLines(boolean)
 */"
"public boolean isDrawLines() {
    return this.plotLines;
}","public void test1719() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    boolean boolean0 = minMaxCategoryRenderer0.isDrawLines();
    assertFalse(boolean0);
}","/**
 * Gets whether or not lines are drawn between category points.
 *
 * @return boolean true if line will be drawn between sequenced categories,
 *         otherwise false.
 *
 * @see #setDrawLines(boolean)
 */"
"public boolean isDrawLines() {
    return this.plotLines;
}","public void test1820() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    Icon icon0 = minMaxCategoryRenderer0.getObjectIcon();
    minMaxCategoryRenderer0.setObjectIcon(icon0);
    assertFalse(minMaxCategoryRenderer0.isDrawLines());
}","/**
 * Gets whether or not lines are drawn between category points.
 *
 * @return boolean true if line will be drawn between sequenced categories,
 *         otherwise false.
 *
 * @see #setDrawLines(boolean)
 */"
"public boolean isDrawLines() {
    return this.plotLines;
}","public void test1921() throws Throwable {
    MinMaxCategoryRenderer minMaxCategoryRenderer0 = new MinMaxCategoryRenderer();
    minMaxCategoryRenderer0.getMinIcon();
    assertFalse(minMaxCategoryRenderer0.isDrawLines());
}","/**
 * Gets whether or not lines are drawn between category points.
 *
 * @return boolean true if line will be drawn between sequenced categories,
 *         otherwise false.
 *
 * @see #setDrawLines(boolean)
 */"
