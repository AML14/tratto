focal_method,test_prefix,docstring
"public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double width = rect2.getWidth();
    double y = rect2.getY();
    double height = rect2.getHeight();
    return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());
}","public void test000() throws Throwable {
    Polygon polygon0 = new Polygon();
    polygon0.addPoint(185, 185);
    Rectangle2D rectangle2D0 = polygon0.getBounds2D();
    boolean boolean0 = ShapeUtilities.intersects(rectangle2D0, rectangle2D0);
    assertTrue(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double width = rect2.getWidth();
    double y = rect2.getY();
    double height = rect2.getHeight();
    return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());
}","public void test011() throws Throwable {
    DefaultCaret defaultCaret0 = new DefaultCaret();
    defaultCaret0.x = (-247);
    boolean boolean0 = ShapeUtilities.intersects(defaultCaret0, defaultCaret0);
    assertTrue(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double width = rect2.getWidth();
    double y = rect2.getY();
    double height = rect2.getHeight();
    return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());
}","public void test022() throws Throwable {
    Line2D.Double line2D_Double0 = new Line2D.Double(2048.46317711122, (-1493.883F), (-681.16286390269), 2494.0);
    Rectangle rectangle0 = line2D_Double0.getBounds();
    Rectangle rectangle1 = new Rectangle();
    boolean boolean0 = ShapeUtilities.intersects(rectangle0, rectangle1);
    assertTrue(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double y = rect2.getY();
    double w = rect2.getWidth();
    double h = rect2.getHeight();
    return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));
}","public void test033() throws Throwable {
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    SystemColor systemColor0 = SystemColor.activeCaption;
    StyledEditorKit.ForegroundAction styledEditorKit_ForegroundAction0 = new StyledEditorKit.ForegroundAction(""/{/w'yG(K"", systemColor0);
    JMenu jMenu0 = new JMenu(styledEditorKit_ForegroundAction0);
    JScrollPane jScrollPane0 = new JScrollPane(jMenu0);
    Rectangle rectangle0 = jScrollPane0.getViewportBorderBounds();
    boolean boolean0 = ShapeUtilities.contains(rectangle2D_Double0, rectangle0);
    assertTrue(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double y = rect2.getY();
    double w = rect2.getWidth();
    double h = rect2.getHeight();
    return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));
}","public void test044() throws Throwable {
    RectangleAnchor rectangleAnchor0 = RectangleAnchor.BOTTOM_RIGHT;
    Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0, 0, 0, 2366.91F);
    Point2D point2D0 = RectangleAnchor.coordinates(rectangle2D_Float0, rectangleAnchor0);
    Size2D size2D0 = new Size2D();
    rectangle2D_Float0.setFrameFromCenter(point2D0, point2D0);
    Rectangle2D rectangle2D0 = RectangleAnchor.createRectangle(size2D0, 0.0, 1858.0, rectangleAnchor0);
    boolean boolean0 = ShapeUtilities.contains(rectangle2D0, rectangle2D_Float0);
    assertFalse(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double y = rect2.getY();
    double w = rect2.getWidth();
    double h = rect2.getHeight();
    return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));
}","public void test055() throws Throwable {
    Rectangle rectangle0 = new Rectangle(665, (-1898));
    boolean boolean0 = ShapeUtilities.contains(rectangle0, rectangle0);
    assertTrue(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static Point2D getPointInRectangle(double x, double y, Rectangle2D area) {
    x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));
    y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));
    return new Point2D.Double(x, y);
}","public void test066() throws Throwable {
    SystemColor systemColor0 = SystemColor.windowText;
    BevelBorder bevelBorder0 = new BevelBorder(2147483646, systemColor0, systemColor0, systemColor0, systemColor0);
    RenderingHints[] renderingHintsArray0 = new RenderingHints[0];
    JList<RenderingHints> jList0 = new JList<RenderingHints>(renderingHintsArray0);
    Rectangle rectangle0 = bevelBorder0.getInteriorRectangle((Component) jList0, (-984), 1, 1717, (-1));
    Point2D.Double point2D_Double0 = (Point2D.Double) ShapeUtilities.getPointInRectangle(0.0F, 244, rectangle0);
    assertEquals(3.0, point2D_Double0.y, 0.01);
}","/**
 * Returns a point based on (x, y) but constrained to be within the bounds
 * of a given rectangle.
 *
 * @param x  the x-coordinate.
 * @param y  the y-coordinate.
 * @param area  the constraining rectangle (<code>null</code> not
 *              permitted).
 *
 * @return A point within the rectangle.
 *
 * @throws NullPointerException if <code>area</code> is <code>null</code>.
 */"
"public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
    PathIterator iterator1 = p1.getPathIterator(null);
    PathIterator iterator2 = p1.getPathIterator(null);
    double[] d1 = new double[6];
    double[] d2 = new double[6];
    boolean done = iterator1.isDone() && iterator2.isDone();
    while (!done) {
        if (iterator1.isDone() != iterator2.isDone()) {
            return false;
        }
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
        done = iterator1.isDone() && iterator2.isDone();
    }
    return true;
}","public void test1011() throws Throwable {
    GeneralPath generalPath0 = (GeneralPath) ShapeUtilities.createDiagonalCross((-890.63F), (-890.63F));
    GeneralPath generalPath1 = new GeneralPath(0);
    boolean boolean0 = ShapeUtilities.equal(generalPath0, generalPath1);
    assertFalse(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  path 1 (<code>null</code> permitted).
 * @param p2  path 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Polygon p1, Polygon p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.npoints != p2.npoints) {
        return false;
    }
    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {
        return false;
    }
    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {
        return false;
    }
    return true;
}","public void test1112() throws Throwable {
    Polygon polygon0 = new Polygon();
    Polygon polygon1 = new Polygon(polygon0.ypoints, polygon0.ypoints, 0);
    polygon1.addPoint(93, (-2114510075));
    boolean boolean0 = ShapeUtilities.equal(polygon0, polygon1);
    assertFalse(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  polygon 1 (<code>null</code> permitted).
 * @param p2  polygon 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Arc2D a1, Arc2D a2) {
    if (a1 == null) {
        return (a2 == null);
    }
    if (a2 == null) {
        return false;
    }
    if (!a1.getFrame().equals(a2.getFrame())) {
        return false;
    }
    if (a1.getAngleStart() != a2.getAngleStart()) {
        return false;
    }
    if (a1.getAngleExtent() != a2.getAngleExtent()) {
        return false;
    }
    if (a1.getArcType() != a2.getArcType()) {
        return false;
    }
    return true;
}","public void test1213() throws Throwable {
    Arc2D.Double arc2D_Double0 = new Arc2D.Double();
    Arc2D.Float arc2D_Float0 = new Arc2D.Float();
    boolean boolean0 = ShapeUtilities.equal((Arc2D) arc2D_Double0, (Arc2D) arc2D_Float0);
    assertTrue(boolean0);
}","/**
 * Compares two arcs and returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param a1  the first arc (<code>null</code> permitted).
 * @param a2  the second arc (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Shape s1, Shape s2) {
    if (s1 instanceof Line2D && s2 instanceof Line2D) {
        return equal((Line2D) s1, (Line2D) s2);
    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {
        return equal((Ellipse2D) s1, (Ellipse2D) s2);
    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {
        return equal((Arc2D) s1, (Arc2D) s2);
    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {
        return equal((Polygon) s1, (Polygon) s2);
    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {
        return equal((GeneralPath) s1, (GeneralPath) s2);
    } else {
        // this will handle Rectangle2D...
        return ObjectUtilities.equal(s1, s2);
    }
}","public void test1314() throws Throwable {
    GeneralPath generalPath0 = new GeneralPath();
    AffineTransform affineTransform0 = new AffineTransform(1528.768001, 132.190692698574, 0.0, 132.190692698574, 132.190692698574, 0.0);
    Shape shape0 = generalPath0.createTransformedShape(affineTransform0);
    boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, shape0);
    assertTrue(boolean0);
}","/**
 * Tests two shapes for equality.  If both shapes are <code>null</code>,
 * this method will return <code>true</code>.
 * <p>
 * In the current implementation, the following shapes are supported:
 * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>
 * (implicit).
 *
 * @param s1  the first shape (<code>null</code> permitted).
 * @param s2  the second shape (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Shape s1, Shape s2) {
    if (s1 instanceof Line2D && s2 instanceof Line2D) {
        return equal((Line2D) s1, (Line2D) s2);
    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {
        return equal((Ellipse2D) s1, (Ellipse2D) s2);
    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {
        return equal((Arc2D) s1, (Arc2D) s2);
    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {
        return equal((Polygon) s1, (Polygon) s2);
    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {
        return equal((GeneralPath) s1, (GeneralPath) s2);
    } else {
        // this will handle Rectangle2D...
        return ObjectUtilities.equal(s1, s2);
    }
}","public void test1415() throws Throwable {
    Polygon polygon0 = new Polygon();
    Polygon polygon1 = new Polygon(polygon0.ypoints, polygon0.ypoints, 0);
    boolean boolean0 = ShapeUtilities.equal((Shape) polygon1, (Shape) polygon0);
    assertFalse(boolean0);
}","/**
 * Tests two shapes for equality.  If both shapes are <code>null</code>,
 * this method will return <code>true</code>.
 * <p>
 * In the current implementation, the following shapes are supported:
 * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>
 * (implicit).
 *
 * @param s1  the first shape (<code>null</code> permitted).
 * @param s2  the second shape (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double width = rect2.getWidth();
    double y = rect2.getY();
    double height = rect2.getHeight();
    return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());
}","public void test1516() throws Throwable {
    Rectangle rectangle0 = new Rectangle(644, (-1898));
    // Undeclared exception!
    try {
        ShapeUtilities.intersects(rectangle0, (Rectangle2D) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jfree.chart.util.ShapeUtilities"", e);
    }
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static Point2D getPointInRectangle(double x, double y, Rectangle2D area) {
    x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));
    y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));
    return new Point2D.Double(x, y);
}","public void test1617() throws Throwable {
    // Undeclared exception!
    try {
        ShapeUtilities.getPointInRectangle(0.0, 517.878022, (Rectangle2D) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jfree.chart.util.ShapeUtilities"", e);
    }
}","/**
 * Returns a point based on (x, y) but constrained to be within the bounds
 * of a given rectangle.
 *
 * @param x  the x-coordinate.
 * @param y  the y-coordinate.
 * @param area  the constraining rectangle (<code>null</code> not
 *              permitted).
 *
 * @return A point within the rectangle.
 *
 * @throws NullPointerException if <code>area</code> is <code>null</code>.
 */"
"public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y) {
    AffineTransform saved = g2.getTransform();
    AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);
    g2.transform(rotate);
    g2.draw(shape);
    g2.setTransform(saved);
}","public void test1718() throws Throwable {
    BufferedImage bufferedImage0 = new BufferedImage(3, 3, 3);
    Graphics2D graphics2D0 = bufferedImage0.createGraphics();
    // Undeclared exception!
    try {
        ShapeUtilities.drawRotatedShape(graphics2D0, (Shape) null, 1.7976931348623157E308, 2588.56F, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.awt.geom.Path2D$Float"", e);
    }
}","/**
 * Draws a shape with the specified rotation about <code>(x, y)</code>.
 *
 * @param g2  the graphics device (<code>null</code> not permitted).
 * @param shape  the shape (<code>null</code> not permitted).
 * @param angle  the angle (in radians).
 * @param x  the x coordinate for the rotation point.
 * @param y  the y coordinate for the rotation point.
 */"
"public static Shape createLineRegion(Line2D line, float width) {
    GeneralPath result = new GeneralPath();
    float x1 = (float) line.getX1();
    float x2 = (float) line.getX2();
    float y1 = (float) line.getY1();
    float y2 = (float) line.getY2();
    if ((x2 - x1) != 0.0) {
        double theta = Math.atan((y2 - y1) / (x2 - x1));
        float dx = (float) Math.sin(theta) * width;
        float dy = (float) Math.cos(theta) * width;
        result.moveTo(x1 - dx, y1 + dy);
        result.lineTo(x1 + dx, y1 - dy);
        result.lineTo(x2 + dx, y2 - dy);
        result.lineTo(x2 - dx, y2 + dy);
        result.closePath();
    } else {
        // special case, vertical line
        result.moveTo(x1 - width / 2.0f, y1);
        result.lineTo(x1 + width / 2.0f, y1);
        result.lineTo(x2 + width / 2.0f, y2);
        result.lineTo(x2 - width / 2.0f, y2);
        result.closePath();
    }
    return result;
}","public void test1819() throws Throwable {
    // Undeclared exception!
    try {
        ShapeUtilities.createLineRegion((Line2D) null, 0.0F);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jfree.chart.util.ShapeUtilities"", e);
    }
}","/**
 * Creates a region surrounding a line segment by 'widening' the line
 * segment.  A typical use for this method is the creation of a
 * 'clickable' region for a line that is displayed on-screen.
 *
 * @param line  the line (<code>null</code> not permitted).
 * @param width  the width of the region.
 *
 * @return A region that surrounds the line.
 */"
"public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double y = rect2.getY();
    double w = rect2.getWidth();
    double h = rect2.getHeight();
    return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));
}","public void test1920() throws Throwable {
    // Undeclared exception!
    try {
        ShapeUtilities.contains((Rectangle2D) null, (Rectangle2D) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jfree.chart.util.ShapeUtilities"", e);
    }
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
    PathIterator iterator1 = p1.getPathIterator(null);
    PathIterator iterator2 = p1.getPathIterator(null);
    double[] d1 = new double[6];
    double[] d2 = new double[6];
    boolean done = iterator1.isDone() && iterator2.isDone();
    while (!done) {
        if (iterator1.isDone() != iterator2.isDone()) {
            return false;
        }
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
        done = iterator1.isDone() && iterator2.isDone();
    }
    return true;
}","public void test2021() throws Throwable {
    GeneralPath generalPath0 = (GeneralPath) ShapeUtilities.createDownTriangle(1.0F);
    boolean boolean0 = ShapeUtilities.equal(generalPath0, generalPath0);
    assertTrue(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  path 1 (<code>null</code> permitted).
 * @param p2  path 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Polygon p1, Polygon p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.npoints != p2.npoints) {
        return false;
    }
    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {
        return false;
    }
    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {
        return false;
    }
    return true;
}","public void test2122() throws Throwable {
    Polygon polygon0 = new Polygon();
    boolean boolean0 = ShapeUtilities.equal(polygon0, polygon0);
    assertTrue(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  polygon 1 (<code>null</code> permitted).
 * @param p2  polygon 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Ellipse2D e1, Ellipse2D e2) {
    if (e1 == null) {
        return (e2 == null);
    }
    if (e2 == null) {
        return false;
    }
    if (!e1.getFrame().equals(e2.getFrame())) {
        return false;
    }
    return true;
}","public void test2223() throws Throwable {
    Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-1.0F), 48.993F, (-1.0F), 0.0F);
    boolean boolean0 = ShapeUtilities.equal((Ellipse2D) ellipse2D_Float0, (Ellipse2D) ellipse2D_Float0);
    assertTrue(boolean0);
}","/**
 * Compares two ellipses and returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param e1  the first ellipse (<code>null</code> permitted).
 * @param e2  the second ellipse (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Line2D l1, Line2D l2) {
    if (l1 == null) {
        return (l2 == null);
    }
    if (l2 == null) {
        return false;
    }
    if (!l1.getP1().equals(l2.getP1())) {
        return false;
    }
    if (!l1.getP2().equals(l2.getP2())) {
        return false;
    }
    return true;
}","public void test2324() throws Throwable {
    Line2D.Double line2D_Double0 = new Line2D.Double(1519.77001953125, 512.432386, (-6), Double.NaN);
    boolean boolean0 = ShapeUtilities.equal((Line2D) line2D_Double0, (Line2D) line2D_Double0);
    assertFalse(boolean0);
}","/**
 * Compares two lines are returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param l1  the first line (<code>null</code> permitted).
 * @param l2  the second line (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Line2D l1, Line2D l2) {
    if (l1 == null) {
        return (l2 == null);
    }
    if (l2 == null) {
        return false;
    }
    if (!l1.getP1().equals(l2.getP1())) {
        return false;
    }
    if (!l1.getP2().equals(l2.getP2())) {
        return false;
    }
    return true;
}","public void test2425() throws Throwable {
    Line2D.Float line2D_Float0 = new Line2D.Float(63.8F, 4504.17F, 0.0F, 4504.17F);
    boolean boolean0 = ShapeUtilities.equal((Line2D) line2D_Float0, (Line2D) line2D_Float0);
    assertTrue(boolean0);
}","/**
 * Compares two lines are returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param l1  the first line (<code>null</code> permitted).
 * @param l2  the second line (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double width = rect2.getWidth();
    double y = rect2.getY();
    double height = rect2.getHeight();
    return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());
}","public void test2526() throws Throwable {
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTableHeader jTableHeader0 = new JTableHeader(defaultTableColumnModel0);
    Rectangle rectangle0 = jTableHeader0.getHeaderRect(1061);
    Rectangle rectangle1 = new Rectangle(0, (-2135938036));
    boolean boolean0 = ShapeUtilities.intersects(rectangle1, rectangle0);
    assertFalse(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double width = rect2.getWidth();
    double y = rect2.getY();
    double height = rect2.getHeight();
    return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());
}","public void test2627() throws Throwable {
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTableHeader jTableHeader0 = new JTableHeader(defaultTableColumnModel0);
    Rectangle rectangle0 = jTableHeader0.getHeaderRect(1061);
    Rectangle rectangle1 = new Rectangle((-2450), (-2135938036));
    boolean boolean0 = ShapeUtilities.intersects(rectangle1, rectangle0);
    assertFalse(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double width = rect2.getWidth();
    double y = rect2.getY();
    double height = rect2.getHeight();
    return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());
}","public void test2728() throws Throwable {
    Rectangle rectangle0 = new Rectangle(665, (-1898));
    boolean boolean0 = ShapeUtilities.intersects(rectangle0, rectangle0);
    assertFalse(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double width = rect2.getWidth();
    double y = rect2.getY();
    double height = rect2.getHeight();
    return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());
}","public void test2829() throws Throwable {
    Rectangle rectangle0 = new Rectangle((-1888), (-1898));
    boolean boolean0 = ShapeUtilities.intersects(rectangle0, rectangle0);
    assertFalse(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double y = rect2.getY();
    double w = rect2.getWidth();
    double h = rect2.getHeight();
    return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));
}","public void test2930() throws Throwable {
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTableHeader jTableHeader0 = new JTableHeader(defaultTableColumnModel0);
    Rectangle rectangle0 = jTableHeader0.getHeaderRect(1061);
    Rectangle rectangle1 = new Rectangle((-2450), (-2135938036));
    boolean boolean0 = ShapeUtilities.contains(rectangle1, rectangle0);
    assertFalse(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double y = rect2.getY();
    double w = rect2.getWidth();
    double h = rect2.getHeight();
    return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));
}","public void test3031() throws Throwable {
    SystemColor systemColor0 = SystemColor.windowText;
    BevelBorder bevelBorder0 = new BevelBorder(2147483646, systemColor0, systemColor0, systemColor0, systemColor0);
    RenderingHints[] renderingHintsArray0 = new RenderingHints[1];
    JList<RenderingHints> jList0 = new JList<RenderingHints>(renderingHintsArray0);
    Rectangle rectangle0 = bevelBorder0.getInteriorRectangle((Component) jList0, (-984), 1, 1703, (-1));
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable((TableModel) null, defaultTableColumnModel0);
    JTableHeader jTableHeader0 = jTable0.getTableHeader();
    Rectangle rectangle1 = jTableHeader0.getHeaderRect((-315));
    boolean boolean0 = ShapeUtilities.contains(rectangle0, rectangle1);
    assertFalse(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {
    double x0 = rect1.getX();
    double y0 = rect1.getY();
    double x = rect2.getX();
    double y = rect2.getY();
    double w = rect2.getWidth();
    double h = rect2.getHeight();
    return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));
}","public void test3132() throws Throwable {
    Rectangle rectangle0 = new Rectangle((-897), (-897), (-897), 3718);
    rectangle0.x = 3718;
    JTable jTable0 = new JTable(0, 0);
    Rectangle rectangle1 = jTable0.getCellRect(272, 3718, false);
    boolean boolean0 = ShapeUtilities.contains(rectangle0, rectangle1);
    assertFalse(boolean0);
}","/**
 * Checks, whether the given rectangle1 fully contains rectangle 2
 * (even if rectangle 2 has a height or width of zero!).
 *
 * @param rect1  the first rectangle.
 * @param rect2  the second rectangle.
 *
 * @return A boolean.
 */"
"public static Shape rotateShape(Shape base, double angle, float x, float y) {
    if (base == null) {
        return null;
    }
    AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);
    Shape result = rotate.createTransformedShape(base);
    return result;
}","public void test3233() throws Throwable {
    Shape shape0 = ShapeUtilities.rotateShape((Shape) null, 0.0, (-617.0F), (-617.0F));
    assertNull(shape0);
}","/**
 * Rotates a shape about the specified coordinates.
 *
 * @param base  the shape (<code>null</code> permitted, returns
 *              <code>null</code>).
 * @param angle  the angle (in radians).
 * @param x  the x coordinate for the rotation point (in Java2D space).
 * @param y  the y coordinate for the rotation point (in Java2D space).
 *
 * @return the rotated shape.
 */"
"public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY) {
    if (shape == null) {
        throw new IllegalArgumentException(""Null 'shape' argument."");
    }
    if (anchor == null) {
        throw new IllegalArgumentException(""Null 'anchor' argument."");
    }
    Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(), anchor);
    AffineTransform transform = AffineTransform.getTranslateInstance(locationX - anchorPoint.getX(), locationY - anchorPoint.getY());
    return transform.createTransformedShape(shape);
}","public void test3435() throws Throwable {
    Rectangle rectangle0 = new Rectangle((-897), (-897), (-897), 3718);
    // Undeclared exception!
    try {
        ShapeUtilities.createTranslatedShape((Shape) rectangle0, (RectangleAnchor) null, (double) 1159, (double) 1.0F);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'anchor' argument.
        //
        verifyException(""org.jfree.chart.util.ShapeUtilities"", e);
    }
}","/**
 * Translates a shape to a new location such that the anchor point
 * (relative to the rectangular bounds of the shape) aligns with the
 * specified (x, y) coordinate in Java2D space.
 *
 * @param shape  the shape (<code>null</code> not permitted).
 * @param anchor  the anchor (<code>null</code> not permitted).
 * @param locationX  the x-coordinate (in Java2D space).
 * @param locationY  the y-coordinate (in Java2D space).
 *
 * @return A new and translated shape.
 */"
"public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY) {
    if (shape == null) {
        throw new IllegalArgumentException(""Null 'shape' argument."");
    }
    if (anchor == null) {
        throw new IllegalArgumentException(""Null 'anchor' argument."");
    }
    Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(), anchor);
    AffineTransform transform = AffineTransform.getTranslateInstance(locationX - anchorPoint.getX(), locationY - anchorPoint.getY());
    return transform.createTransformedShape(shape);
}","public void test3536() throws Throwable {
    RectangleAnchor rectangleAnchor0 = RectangleAnchor.BOTTOM_RIGHT;
    // Undeclared exception!
    try {
        ShapeUtilities.createTranslatedShape((Shape) null, rectangleAnchor0, (-1362.0), 14.9);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'shape' argument.
        //
        verifyException(""org.jfree.chart.util.ShapeUtilities"", e);
    }
}","/**
 * Translates a shape to a new location such that the anchor point
 * (relative to the rectangular bounds of the shape) aligns with the
 * specified (x, y) coordinate in Java2D space.
 *
 * @param shape  the shape (<code>null</code> not permitted).
 * @param anchor  the anchor (<code>null</code> not permitted).
 * @param locationX  the x-coordinate (in Java2D space).
 * @param locationY  the y-coordinate (in Java2D space).
 *
 * @return A new and translated shape.
 */"
"public static Shape createTranslatedShape(Shape shape, double transX, double transY) {
    if (shape == null) {
        throw new IllegalArgumentException(""Null 'shape' argument."");
    }
    AffineTransform transform = AffineTransform.getTranslateInstance(transX, transY);
    return transform.createTransformedShape(shape);
}","public void test3637() throws Throwable {
    // Undeclared exception!
    try {
        ShapeUtilities.createTranslatedShape((Shape) null, (double) 0.0F, (-725.769));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'shape' argument.
        //
        verifyException(""org.jfree.chart.util.ShapeUtilities"", e);
    }
}","/**
 * Creates and returns a translated shape.
 *
 * @param shape  the shape (<code>null</code> not permitted).
 * @param transX  the x translation (in Java2D space).
 * @param transY  the y translation (in Java2D space).
 *
 * @return The translated shape.
 */"
"public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
    PathIterator iterator1 = p1.getPathIterator(null);
    PathIterator iterator2 = p1.getPathIterator(null);
    double[] d1 = new double[6];
    double[] d2 = new double[6];
    boolean done = iterator1.isDone() && iterator2.isDone();
    while (!done) {
        if (iterator1.isDone() != iterator2.isDone()) {
            return false;
        }
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
        done = iterator1.isDone() && iterator2.isDone();
    }
    return true;
}","public void test3839() throws Throwable {
    GeneralPath generalPath0 = new GeneralPath(0);
    boolean boolean0 = ShapeUtilities.equal(generalPath0, generalPath0);
    assertTrue(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  path 1 (<code>null</code> permitted).
 * @param p2  path 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
    PathIterator iterator1 = p1.getPathIterator(null);
    PathIterator iterator2 = p1.getPathIterator(null);
    double[] d1 = new double[6];
    double[] d2 = new double[6];
    boolean done = iterator1.isDone() && iterator2.isDone();
    while (!done) {
        if (iterator1.isDone() != iterator2.isDone()) {
            return false;
        }
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
        done = iterator1.isDone() && iterator2.isDone();
    }
    return true;
}","public void test3940() throws Throwable {
    GeneralPath generalPath0 = (GeneralPath) ShapeUtilities.createDiamond(0);
    GeneralPath generalPath1 = new GeneralPath(0);
    boolean boolean0 = ShapeUtilities.equal(generalPath1, generalPath0);
    assertFalse(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  path 1 (<code>null</code> permitted).
 * @param p2  path 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
    PathIterator iterator1 = p1.getPathIterator(null);
    PathIterator iterator2 = p1.getPathIterator(null);
    double[] d1 = new double[6];
    double[] d2 = new double[6];
    boolean done = iterator1.isDone() && iterator2.isDone();
    while (!done) {
        if (iterator1.isDone() != iterator2.isDone()) {
            return false;
        }
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
        done = iterator1.isDone() && iterator2.isDone();
    }
    return true;
}","public void test4041() throws Throwable {
    GeneralPath generalPath0 = new GeneralPath();
    boolean boolean0 = ShapeUtilities.equal(generalPath0, (GeneralPath) null);
    assertFalse(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  path 1 (<code>null</code> permitted).
 * @param p2  path 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
    PathIterator iterator1 = p1.getPathIterator(null);
    PathIterator iterator2 = p1.getPathIterator(null);
    double[] d1 = new double[6];
    double[] d2 = new double[6];
    boolean done = iterator1.isDone() && iterator2.isDone();
    while (!done) {
        if (iterator1.isDone() != iterator2.isDone()) {
            return false;
        }
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
        done = iterator1.isDone() && iterator2.isDone();
    }
    return true;
}","public void test4142() throws Throwable {
    GeneralPath generalPath0 = (GeneralPath) ShapeUtilities.createDiagonalCross(0.0F, 0.0F);
    boolean boolean0 = ShapeUtilities.equal((GeneralPath) null, generalPath0);
    assertFalse(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  path 1 (<code>null</code> permitted).
 * @param p2  path 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
    PathIterator iterator1 = p1.getPathIterator(null);
    PathIterator iterator2 = p1.getPathIterator(null);
    double[] d1 = new double[6];
    double[] d2 = new double[6];
    boolean done = iterator1.isDone() && iterator2.isDone();
    while (!done) {
        if (iterator1.isDone() != iterator2.isDone()) {
            return false;
        }
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
        done = iterator1.isDone() && iterator2.isDone();
    }
    return true;
}","public void test4243() throws Throwable {
    boolean boolean0 = ShapeUtilities.equal((GeneralPath) null, (GeneralPath) null);
    assertTrue(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  path 1 (<code>null</code> permitted).
 * @param p2  path 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Polygon p1, Polygon p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.npoints != p2.npoints) {
        return false;
    }
    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {
        return false;
    }
    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {
        return false;
    }
    return true;
}","public void test4344() throws Throwable {
    Polygon polygon0 = new Polygon();
    Polygon polygon1 = new Polygon(polygon0.ypoints, polygon0.ypoints, 0);
    polygon1.xpoints = polygon0.ypoints;
    boolean boolean0 = ShapeUtilities.equal(polygon0, polygon1);
    assertFalse(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  polygon 1 (<code>null</code> permitted).
 * @param p2  polygon 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Polygon p1, Polygon p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.npoints != p2.npoints) {
        return false;
    }
    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {
        return false;
    }
    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {
        return false;
    }
    return true;
}","public void test4445() throws Throwable {
    Polygon polygon0 = new Polygon();
    Polygon polygon1 = new Polygon(polygon0.ypoints, polygon0.ypoints, 0);
    boolean boolean0 = ShapeUtilities.equal(polygon0, polygon1);
    assertFalse(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  polygon 1 (<code>null</code> permitted).
 * @param p2  polygon 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Polygon p1, Polygon p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.npoints != p2.npoints) {
        return false;
    }
    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {
        return false;
    }
    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {
        return false;
    }
    return true;
}","public void test4546() throws Throwable {
    Polygon polygon0 = new Polygon();
    polygon0.addPoint(244, 1861);
    Polygon polygon1 = new Polygon();
    boolean boolean0 = ShapeUtilities.equal(polygon0, polygon1);
    assertFalse(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  polygon 1 (<code>null</code> permitted).
 * @param p2  polygon 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Polygon p1, Polygon p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.npoints != p2.npoints) {
        return false;
    }
    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {
        return false;
    }
    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {
        return false;
    }
    return true;
}","public void test4647() throws Throwable {
    Polygon polygon0 = new Polygon();
    boolean boolean0 = ShapeUtilities.equal(polygon0, (Polygon) null);
    assertFalse(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  polygon 1 (<code>null</code> permitted).
 * @param p2  polygon 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Polygon p1, Polygon p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.npoints != p2.npoints) {
        return false;
    }
    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {
        return false;
    }
    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {
        return false;
    }
    return true;
}","public void test4748() throws Throwable {
    Polygon polygon0 = new Polygon();
    boolean boolean0 = ShapeUtilities.equal((Polygon) null, polygon0);
    assertFalse(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  polygon 1 (<code>null</code> permitted).
 * @param p2  polygon 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Polygon p1, Polygon p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.npoints != p2.npoints) {
        return false;
    }
    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {
        return false;
    }
    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {
        return false;
    }
    return true;
}","public void test4849() throws Throwable {
    boolean boolean0 = ShapeUtilities.equal((Polygon) null, (Polygon) null);
    assertTrue(boolean0);
}","/**
 * Tests two polygons for equality.  If both are <code>null</code> this
 * method returns <code>true</code>.
 *
 * @param p1  polygon 1 (<code>null</code> permitted).
 * @param p2  polygon 2 (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Arc2D a1, Arc2D a2) {
    if (a1 == null) {
        return (a2 == null);
    }
    if (a2 == null) {
        return false;
    }
    if (!a1.getFrame().equals(a2.getFrame())) {
        return false;
    }
    if (a1.getAngleStart() != a2.getAngleStart()) {
        return false;
    }
    if (a1.getAngleExtent() != a2.getAngleExtent()) {
        return false;
    }
    if (a1.getArcType() != a2.getArcType()) {
        return false;
    }
    return true;
}","public void test4950() throws Throwable {
    Arc2D.Double arc2D_Double0 = new Arc2D.Double(0, (-9.855929016800612), (-9.855929016800612), (-9.855929016800612), (-9.855929016800612), 0, 0);
    Point2D.Double point2D_Double0 = new Point2D.Double();
    arc2D_Double0.setArcByTangent(point2D_Double0, point2D_Double0, point2D_Double0, (-9.855929016800612));
    boolean boolean0 = ShapeUtilities.equal((Arc2D) arc2D_Double0, (Arc2D) arc2D_Double0);
    assertFalse(boolean0);
}","/**
 * Compares two arcs and returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param a1  the first arc (<code>null</code> permitted).
 * @param a2  the second arc (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Arc2D a1, Arc2D a2) {
    if (a1 == null) {
        return (a2 == null);
    }
    if (a2 == null) {
        return false;
    }
    if (!a1.getFrame().equals(a2.getFrame())) {
        return false;
    }
    if (a1.getAngleStart() != a2.getAngleStart()) {
        return false;
    }
    if (a1.getAngleExtent() != a2.getAngleExtent()) {
        return false;
    }
    if (a1.getArcType() != a2.getArcType()) {
        return false;
    }
    return true;
}","public void test5051() throws Throwable {
    Arc2D.Double arc2D_Double0 = new Arc2D.Double(1);
    boolean boolean0 = ShapeUtilities.equal((Arc2D) arc2D_Double0, (Arc2D) null);
    assertFalse(boolean0);
}","/**
 * Compares two arcs and returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param a1  the first arc (<code>null</code> permitted).
 * @param a2  the second arc (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Arc2D a1, Arc2D a2) {
    if (a1 == null) {
        return (a2 == null);
    }
    if (a2 == null) {
        return false;
    }
    if (!a1.getFrame().equals(a2.getFrame())) {
        return false;
    }
    if (a1.getAngleStart() != a2.getAngleStart()) {
        return false;
    }
    if (a1.getAngleExtent() != a2.getAngleExtent()) {
        return false;
    }
    if (a1.getArcType() != a2.getArcType()) {
        return false;
    }
    return true;
}","public void test5152() throws Throwable {
    boolean boolean0 = ShapeUtilities.equal((Arc2D) null, (Arc2D) null);
    assertTrue(boolean0);
}","/**
 * Compares two arcs and returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param a1  the first arc (<code>null</code> permitted).
 * @param a2  the second arc (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Arc2D a1, Arc2D a2) {
    if (a1 == null) {
        return (a2 == null);
    }
    if (a2 == null) {
        return false;
    }
    if (!a1.getFrame().equals(a2.getFrame())) {
        return false;
    }
    if (a1.getAngleStart() != a2.getAngleStart()) {
        return false;
    }
    if (a1.getAngleExtent() != a2.getAngleExtent()) {
        return false;
    }
    if (a1.getArcType() != a2.getArcType()) {
        return false;
    }
    return true;
}","public void test5253() throws Throwable {
    SystemColor systemColor0 = SystemColor.windowText;
    BevelBorder bevelBorder0 = new BevelBorder(2147483646, systemColor0, systemColor0, systemColor0, systemColor0);
    RenderingHints[] renderingHintsArray0 = new RenderingHints[0];
    JList<RenderingHints> jList0 = new JList<RenderingHints>(renderingHintsArray0);
    Rectangle rectangle0 = bevelBorder0.getInteriorRectangle((Component) jList0, (-984), 1, 1717, (-1));
    Arc2D.Float arc2D_Float0 = new Arc2D.Float(rectangle0, 1717, (-726.63544F), 1);
    boolean boolean0 = ShapeUtilities.equal((Arc2D) null, (Arc2D) arc2D_Float0);
    assertFalse(boolean0);
}","/**
 * Compares two arcs and returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param a1  the first arc (<code>null</code> permitted).
 * @param a2  the second arc (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Ellipse2D e1, Ellipse2D e2) {
    if (e1 == null) {
        return (e2 == null);
    }
    if (e2 == null) {
        return false;
    }
    if (!e1.getFrame().equals(e2.getFrame())) {
        return false;
    }
    return true;
}","public void test5354() throws Throwable {
    Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-1.0F), 48.993F, (-1.0F), 424.01743F);
    Ellipse2D.Float ellipse2D_Float1 = new Ellipse2D.Float();
    boolean boolean0 = ShapeUtilities.equal((Ellipse2D) ellipse2D_Float0, (Ellipse2D) ellipse2D_Float1);
    assertFalse(boolean0);
}","/**
 * Compares two ellipses and returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param e1  the first ellipse (<code>null</code> permitted).
 * @param e2  the second ellipse (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Ellipse2D e1, Ellipse2D e2) {
    if (e1 == null) {
        return (e2 == null);
    }
    if (e2 == null) {
        return false;
    }
    if (!e1.getFrame().equals(e2.getFrame())) {
        return false;
    }
    return true;
}","public void test5455() throws Throwable {
    Ellipse2D.Double ellipse2D_Double0 = new Ellipse2D.Double();
    boolean boolean0 = ShapeUtilities.equal((Ellipse2D) ellipse2D_Double0, (Ellipse2D) null);
    assertFalse(boolean0);
}","/**
 * Compares two ellipses and returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param e1  the first ellipse (<code>null</code> permitted).
 * @param e2  the second ellipse (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Ellipse2D e1, Ellipse2D e2) {
    if (e1 == null) {
        return (e2 == null);
    }
    if (e2 == null) {
        return false;
    }
    if (!e1.getFrame().equals(e2.getFrame())) {
        return false;
    }
    return true;
}","public void test5556() throws Throwable {
    Ellipse2D.Double ellipse2D_Double0 = new Ellipse2D.Double((-1.0), (-1.0), 588.0, 588.0);
    boolean boolean0 = ShapeUtilities.equal((Ellipse2D) null, (Ellipse2D) ellipse2D_Double0);
    assertFalse(boolean0);
}","/**
 * Compares two ellipses and returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param e1  the first ellipse (<code>null</code> permitted).
 * @param e2  the second ellipse (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Ellipse2D e1, Ellipse2D e2) {
    if (e1 == null) {
        return (e2 == null);
    }
    if (e2 == null) {
        return false;
    }
    if (!e1.getFrame().equals(e2.getFrame())) {
        return false;
    }
    return true;
}","public void test5657() throws Throwable {
    boolean boolean0 = ShapeUtilities.equal((Ellipse2D) null, (Ellipse2D) null);
    assertTrue(boolean0);
}","/**
 * Compares two ellipses and returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param e1  the first ellipse (<code>null</code> permitted).
 * @param e2  the second ellipse (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static Shape clone(Shape shape) {
    if (shape instanceof Cloneable) {
        try {
            return (Shape) ObjectUtilities.clone(shape);
        } catch (CloneNotSupportedException cnse) {
        }
    }
    Shape result = null;
    return result;
}","public void test5758() throws Throwable {
    Line2D.Double line2D_Double0 = new Line2D.Double(1047.703, 0.0, 1047.703, 0.0);
    Shape shape0 = ShapeUtilities.clone(line2D_Double0);
    assertNotNull(shape0);
}","/**
 * Returns a clone of the specified shape, or <code>null</code>.  At the
 * current time, this method supports cloning for instances of
 * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>
 * and <code>GeneralPath</code>.
 * <p>
 * <code>RectangularShape</code> includes <code>Arc2D</code>,
 * <code>Ellipse2D</code>, <code>Rectangle2D</code>,
 * <code>RoundRectangle2D</code>.
 *
 * @param shape  the shape to clone (<code>null</code> permitted,
 *               returns <code>null</code>).
 *
 * @return A clone or <code>null</code>.
 */"
"public static boolean equal(Shape s1, Shape s2) {
    if (s1 instanceof Line2D && s2 instanceof Line2D) {
        return equal((Line2D) s1, (Line2D) s2);
    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {
        return equal((Ellipse2D) s1, (Ellipse2D) s2);
    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {
        return equal((Arc2D) s1, (Arc2D) s2);
    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {
        return equal((Polygon) s1, (Polygon) s2);
    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {
        return equal((GeneralPath) s1, (GeneralPath) s2);
    } else {
        // this will handle Rectangle2D...
        return ObjectUtilities.equal(s1, s2);
    }
}","public void test5759() throws Throwable {
    Line2D.Double line2D_Double0 = new Line2D.Double(1047.703, 0.0, 1047.703, 0.0);
    Shape shape0 = ShapeUtilities.clone(line2D_Double0);
    line2D_Double0.y2 = 1.5;
    boolean boolean0 = ShapeUtilities.equal(shape0, (Shape) line2D_Double0);
    assertFalse(boolean0);
}","/**
 * Tests two shapes for equality.  If both shapes are <code>null</code>,
 * this method will return <code>true</code>.
 * <p>
 * In the current implementation, the following shapes are supported:
 * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>
 * (implicit).
 *
 * @param s1  the first shape (<code>null</code> permitted).
 * @param s2  the second shape (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Line2D l1, Line2D l2) {
    if (l1 == null) {
        return (l2 == null);
    }
    if (l2 == null) {
        return false;
    }
    if (!l1.getP1().equals(l2.getP1())) {
        return false;
    }
    if (!l1.getP2().equals(l2.getP2())) {
        return false;
    }
    return true;
}","public void test5860() throws Throwable {
    Line2D.Double line2D_Double0 = new Line2D.Double(Double.POSITIVE_INFINITY, 185, (-1149.476076061802), 0.0F);
    Line2D.Float line2D_Float0 = new Line2D.Float(0.0F, 0.0F, 185, 0.0F);
    boolean boolean0 = ShapeUtilities.equal((Line2D) line2D_Float0, (Line2D) line2D_Double0);
    assertFalse(boolean0);
}","/**
 * Compares two lines are returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param l1  the first line (<code>null</code> permitted).
 * @param l2  the second line (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Line2D l1, Line2D l2) {
    if (l1 == null) {
        return (l2 == null);
    }
    if (l2 == null) {
        return false;
    }
    if (!l1.getP1().equals(l2.getP1())) {
        return false;
    }
    if (!l1.getP2().equals(l2.getP2())) {
        return false;
    }
    return true;
}","public void test5961() throws Throwable {
    Line2D.Double line2D_Double0 = new Line2D.Double();
    boolean boolean0 = ShapeUtilities.equal((Line2D) line2D_Double0, (Line2D) null);
    assertFalse(boolean0);
}","/**
 * Compares two lines are returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param l1  the first line (<code>null</code> permitted).
 * @param l2  the second line (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Line2D l1, Line2D l2) {
    if (l1 == null) {
        return (l2 == null);
    }
    if (l2 == null) {
        return false;
    }
    if (!l1.getP1().equals(l2.getP1())) {
        return false;
    }
    if (!l1.getP2().equals(l2.getP2())) {
        return false;
    }
    return true;
}","public void test6062() throws Throwable {
    Line2D.Float line2D_Float0 = new Line2D.Float();
    boolean boolean0 = ShapeUtilities.equal((Line2D) null, (Line2D) line2D_Float0);
    assertFalse(boolean0);
}","/**
 * Compares two lines are returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param l1  the first line (<code>null</code> permitted).
 * @param l2  the second line (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Line2D l1, Line2D l2) {
    if (l1 == null) {
        return (l2 == null);
    }
    if (l2 == null) {
        return false;
    }
    if (!l1.getP1().equals(l2.getP1())) {
        return false;
    }
    if (!l1.getP2().equals(l2.getP2())) {
        return false;
    }
    return true;
}","public void test6163() throws Throwable {
    boolean boolean0 = ShapeUtilities.equal((Line2D) null, (Line2D) null);
    assertTrue(boolean0);
}","/**
 * Compares two lines are returns <code>true</code> if they are equal or
 * both <code>null</code>.
 *
 * @param l1  the first line (<code>null</code> permitted).
 * @param l2  the second line (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Shape s1, Shape s2) {
    if (s1 instanceof Line2D && s2 instanceof Line2D) {
        return equal((Line2D) s1, (Line2D) s2);
    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {
        return equal((Ellipse2D) s1, (Ellipse2D) s2);
    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {
        return equal((Arc2D) s1, (Arc2D) s2);
    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {
        return equal((Polygon) s1, (Polygon) s2);
    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {
        return equal((GeneralPath) s1, (GeneralPath) s2);
    } else {
        // this will handle Rectangle2D...
        return ObjectUtilities.equal(s1, s2);
    }
}","public void test6264() throws Throwable {
    Polygon polygon0 = new Polygon();
    Arc2D.Double arc2D_Double0 = new Arc2D.Double(0, (-9.855929016800612), (-9.855929016800612), (-9.855929016800612), (-9.855929016800612), 0, 0);
    boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) arc2D_Double0);
    assertFalse(boolean0);
}","/**
 * Tests two shapes for equality.  If both shapes are <code>null</code>,
 * this method will return <code>true</code>.
 * <p>
 * In the current implementation, the following shapes are supported:
 * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>
 * (implicit).
 *
 * @param s1  the first shape (<code>null</code> permitted).
 * @param s2  the second shape (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Shape s1, Shape s2) {
    if (s1 instanceof Line2D && s2 instanceof Line2D) {
        return equal((Line2D) s1, (Line2D) s2);
    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {
        return equal((Ellipse2D) s1, (Ellipse2D) s2);
    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {
        return equal((Arc2D) s1, (Arc2D) s2);
    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {
        return equal((Polygon) s1, (Polygon) s2);
    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {
        return equal((GeneralPath) s1, (GeneralPath) s2);
    } else {
        // this will handle Rectangle2D...
        return ObjectUtilities.equal(s1, s2);
    }
}","public void test6365() throws Throwable {
    Arc2D.Double arc2D_Double0 = new Arc2D.Double();
    boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);
    assertTrue(boolean0);
}","/**
 * Tests two shapes for equality.  If both shapes are <code>null</code>,
 * this method will return <code>true</code>.
 * <p>
 * In the current implementation, the following shapes are supported:
 * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>
 * (implicit).
 *
 * @param s1  the first shape (<code>null</code> permitted).
 * @param s2  the second shape (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Shape s1, Shape s2) {
    if (s1 instanceof Line2D && s2 instanceof Line2D) {
        return equal((Line2D) s1, (Line2D) s2);
    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {
        return equal((Ellipse2D) s1, (Ellipse2D) s2);
    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {
        return equal((Arc2D) s1, (Arc2D) s2);
    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {
        return equal((Polygon) s1, (Polygon) s2);
    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {
        return equal((GeneralPath) s1, (GeneralPath) s2);
    } else {
        // this will handle Rectangle2D...
        return ObjectUtilities.equal(s1, s2);
    }
}","public void test6466() throws Throwable {
    Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-1.0F), 48.993F, (-1.0F), 424.01743F);
    RectangleAnchor rectangleAnchor0 = RectangleAnchor.BOTTOM_RIGHT;
    Shape shape0 = ShapeUtilities.createTranslatedShape((Shape) ellipse2D_Float0, rectangleAnchor0, (double) (-175.63376F), (double) 424.01743F);
    Arc2D.Float arc2D_Float0 = new Arc2D.Float();
    boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, shape0);
    assertFalse(boolean0);
}","/**
 * Tests two shapes for equality.  If both shapes are <code>null</code>,
 * this method will return <code>true</code>.
 * <p>
 * In the current implementation, the following shapes are supported:
 * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>
 * (implicit).
 *
 * @param s1  the first shape (<code>null</code> permitted).
 * @param s2  the second shape (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Shape s1, Shape s2) {
    if (s1 instanceof Line2D && s2 instanceof Line2D) {
        return equal((Line2D) s1, (Line2D) s2);
    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {
        return equal((Ellipse2D) s1, (Ellipse2D) s2);
    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {
        return equal((Arc2D) s1, (Arc2D) s2);
    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {
        return equal((Polygon) s1, (Polygon) s2);
    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {
        return equal((GeneralPath) s1, (GeneralPath) s2);
    } else {
        // this will handle Rectangle2D...
        return ObjectUtilities.equal(s1, s2);
    }
}","public void test6567() throws Throwable {
    Shape shape0 = ShapeUtilities.createDiamond((-1603.3816F));
    Ellipse2D.Double ellipse2D_Double0 = new Ellipse2D.Double();
    boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Double0, shape0);
    assertFalse(boolean0);
}","/**
 * Tests two shapes for equality.  If both shapes are <code>null</code>,
 * this method will return <code>true</code>.
 * <p>
 * In the current implementation, the following shapes are supported:
 * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>
 * (implicit).
 *
 * @param s1  the first shape (<code>null</code> permitted).
 * @param s2  the second shape (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Shape s1, Shape s2) {
    if (s1 instanceof Line2D && s2 instanceof Line2D) {
        return equal((Line2D) s1, (Line2D) s2);
    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {
        return equal((Ellipse2D) s1, (Ellipse2D) s2);
    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {
        return equal((Arc2D) s1, (Arc2D) s2);
    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {
        return equal((Polygon) s1, (Polygon) s2);
    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {
        return equal((GeneralPath) s1, (GeneralPath) s2);
    } else {
        // this will handle Rectangle2D...
        return ObjectUtilities.equal(s1, s2);
    }
}","public void test6668() throws Throwable {
    Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-1617.77F), (-1617.77F), 2971.176F, (-1893.385F));
    boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);
    assertTrue(boolean0);
}","/**
 * Tests two shapes for equality.  If both shapes are <code>null</code>,
 * this method will return <code>true</code>.
 * <p>
 * In the current implementation, the following shapes are supported:
 * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>
 * (implicit).
 *
 * @param s1  the first shape (<code>null</code> permitted).
 * @param s2  the second shape (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Shape s1, Shape s2) {
    if (s1 instanceof Line2D && s2 instanceof Line2D) {
        return equal((Line2D) s1, (Line2D) s2);
    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {
        return equal((Ellipse2D) s1, (Ellipse2D) s2);
    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {
        return equal((Arc2D) s1, (Arc2D) s2);
    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {
        return equal((Polygon) s1, (Polygon) s2);
    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {
        return equal((GeneralPath) s1, (GeneralPath) s2);
    } else {
        // this will handle Rectangle2D...
        return ObjectUtilities.equal(s1, s2);
    }
}","public void test6769() throws Throwable {
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Point2D point2D0 = ShapeUtilities.getPointInRectangle(82.0, 82.0, rectangle2D_Double0);
    Line2D.Double line2D_Double0 = new Line2D.Double(point2D0, point2D0);
    boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) rectangle2D_Double0);
    assertEquals(0.0, line2D_Double0.y2, 0.01);
}","/**
 * Tests two shapes for equality.  If both shapes are <code>null</code>,
 * this method will return <code>true</code>.
 * <p>
 * In the current implementation, the following shapes are supported:
 * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>
 * (implicit).
 *
 * @param s1  the first shape (<code>null</code> permitted).
 * @param s2  the second shape (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static boolean equal(Shape s1, Shape s2) {
    if (s1 instanceof Line2D && s2 instanceof Line2D) {
        return equal((Line2D) s1, (Line2D) s2);
    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {
        return equal((Ellipse2D) s1, (Ellipse2D) s2);
    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {
        return equal((Arc2D) s1, (Arc2D) s2);
    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {
        return equal((Polygon) s1, (Polygon) s2);
    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {
        return equal((GeneralPath) s1, (GeneralPath) s2);
    } else {
        // this will handle Rectangle2D...
        return ObjectUtilities.equal(s1, s2);
    }
}","public void test6872() throws Throwable {
    Line2D.Double line2D_Double0 = new Line2D.Double(1047.703, 0.0, 1047.703, 0.0);
    Shape shape0 = ShapeUtilities.createRegularCross(0, (-1153.61F));
    boolean boolean0 = ShapeUtilities.equal(shape0, (Shape) line2D_Double0);
    assertFalse(boolean0);
}","/**
 * Tests two shapes for equality.  If both shapes are <code>null</code>,
 * this method will return <code>true</code>.
 * <p>
 * In the current implementation, the following shapes are supported:
 * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>
 * (implicit).
 *
 * @param s1  the first shape (<code>null</code> permitted).
 * @param s2  the second shape (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public static Shape clone(Shape shape) {
    if (shape instanceof Cloneable) {
        try {
            return (Shape) ObjectUtilities.clone(shape);
        } catch (CloneNotSupportedException cnse) {
        }
    }
    Shape result = null;
    return result;
}","public void test6973() throws Throwable {
    Polygon polygon0 = new Polygon();
    Shape shape0 = ShapeUtilities.clone(polygon0);
    assertNull(shape0);
}","/**
 * Returns a clone of the specified shape, or <code>null</code>.  At the
 * current time, this method supports cloning for instances of
 * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>
 * and <code>GeneralPath</code>.
 * <p>
 * <code>RectangularShape</code> includes <code>Arc2D</code>,
 * <code>Ellipse2D</code>, <code>Rectangle2D</code>,
 * <code>RoundRectangle2D</code>.
 *
 * @param shape  the shape to clone (<code>null</code> permitted,
 *               returns <code>null</code>).
 *
 * @return A clone or <code>null</code>.
 */"
"public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y) {
    AffineTransform saved = g2.getTransform();
    AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);
    g2.transform(rotate);
    g2.draw(shape);
    g2.setTransform(saved);
}","public void test7175() throws Throwable {
    Shape shape0 = ShapeUtilities.createDownTriangle((-1718.7449F));
    BufferedImage bufferedImage0 = new BufferedImage(3, 3, 3);
    SunGraphics2D sunGraphics2D0 = (SunGraphics2D) bufferedImage0.createGraphics();
    ShapeUtilities.drawRotatedShape(sunGraphics2D0, shape0, (-10.0), (-1.0F), (-1.0F));
    assertEquals(0, sunGraphics2D0.transformState);
}","/**
 * Draws a shape with the specified rotation about <code>(x, y)</code>.
 *
 * @param g2  the graphics device (<code>null</code> not permitted).
 * @param shape  the shape (<code>null</code> not permitted).
 * @param angle  the angle (in radians).
 * @param x  the x coordinate for the rotation point.
 * @param y  the y coordinate for the rotation point.
 */"
