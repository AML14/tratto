focal_method,test_prefix,docstring
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof MultiplePiePlot)) {
        return false;
    }
    MultiplePiePlot that = (MultiplePiePlot) obj;
    if (this.dataExtractOrder != that.dataExtractOrder) {
        return false;
    }
    if (this.limit != that.limit) {
        return false;
    }
    if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {
        return false;
    }
    if (!PaintUtilities.equal(this.aggregatedItemsPaint, that.aggregatedItemsPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    return true;
}","public void test000() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    Color color0 = (Color) JFreeChart.DEFAULT_BACKGROUND_PAINT;
    multiplePiePlot0.setAggregatedItemsPaint(color0);
    MultiplePiePlot multiplePiePlot1 = (MultiplePiePlot) multiplePiePlot0.clone();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertTrue(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is not considered in the equality test.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return <code>true</code> if this plot is equal to <code>obj</code>, and
 *     <code>false</code> otherwise.
 */"
"public double getLimit() {
    return this.limit;
}","public void test001() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    Color color0 = (Color) JFreeChart.DEFAULT_BACKGROUND_PAINT;
    multiplePiePlot0.setAggregatedItemsPaint(color0);
    MultiplePiePlot multiplePiePlot1 = (MultiplePiePlot) multiplePiePlot0.clone();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertEquals(0.0, multiplePiePlot1.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test012() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    assertEquals(0.0, multiplePiePlot1.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof MultiplePiePlot)) {
        return false;
    }
    MultiplePiePlot that = (MultiplePiePlot) obj;
    if (this.dataExtractOrder != that.dataExtractOrder) {
        return false;
    }
    if (this.limit != that.limit) {
        return false;
    }
    if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {
        return false;
    }
    if (!PaintUtilities.equal(this.aggregatedItemsPaint, that.aggregatedItemsPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    return true;
}","public void test013() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    multiplePiePlot1.setLimit(1.0F);
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is not considered in the equality test.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return <code>true</code> if this plot is equal to <code>obj</code>, and
 *     <code>false</code> otherwise.
 */"
"public BufferedImage createBufferedImage(int width, int height, ChartRenderingInfo info) {
    return createBufferedImage(width, height, BufferedImage.TYPE_INT_ARGB, info);
}","public void test024() throws Throwable {
    double[][] doubleArray0 = new double[2][0];
    double[] doubleArray1 = new double[10];
    doubleArray0[0] = doubleArray1;
    DefaultIntervalCategoryDataset defaultIntervalCategoryDataset0 = new DefaultIntervalCategoryDataset(doubleArray0, doubleArray0);
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultIntervalCategoryDataset0);
    JFreeChart jFreeChart0 = new JFreeChart(""hnlXySWvrw"", multiplePiePlot0);
    StandardEntityCollection standardEntityCollection0 = new StandardEntityCollection();
    ChartRenderingInfo chartRenderingInfo0 = new ChartRenderingInfo(standardEntityCollection0);
    // Undeclared exception!
    try {
        jFreeChart0.createBufferedImage(20, 20, chartRenderingInfo0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.jfree.data.category.DefaultIntervalCategoryDataset"", e);
    }
}","/**
 * Creates and returns a buffered image into which the chart has been drawn.
 *
 * @param width  the width.
 * @param height  the height.
 * @param info  carries back chart state information (<code>null</code>
 *              permitted).
 *
 * @return A buffered image.
 */"
"public double getLimit() {
    return this.limit;
}","public void test035() throws Throwable {
    TaskSeriesCollection taskSeriesCollection0 = new TaskSeriesCollection();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(taskSeriesCollection0);
    JFreeChart jFreeChart0 = new JFreeChart("""", multiplePiePlot0);
    RectangleInsets rectangleInsets0 = Axis.DEFAULT_TICK_LABEL_INSETS;
    multiplePiePlot0.setInsets(rectangleInsets0, false);
    jFreeChart0.createBufferedImage(4, 10);
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test046() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    SystemColor systemColor0 = SystemColor.scrollbar;
    multiplePiePlot0.setAggregatedItemsPaint(systemColor0);
    multiplePiePlot0.getAggregatedItemsPaint();
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test057() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    JFreeChart jFreeChart0 = multiplePiePlot0.getPieChart();
    DateTitle dateTitle0 = new DateTitle();
    jFreeChart0.addSubtitle((Title) dateTitle0);
    multiplePiePlot0.getPieChart();
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test068() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test069() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    multiplePiePlot0.setLimit(1.0);
    double double0 = multiplePiePlot0.getLimit();
    assertEquals(1.0, double0, 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test0710() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    multiplePiePlot0.setLimit((-1761.638998));
    double double0 = multiplePiePlot0.getLimit();
    assertEquals((-1761.638998), double0, 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test0811() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    multiplePiePlot0.getDataset();
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public LegendItemCollection getLegendItems() {
    LegendItemCollection result = new LegendItemCollection();
    if (this.dataset != null) {
        List keys = null;
        prefetchSectionPaints();
        if (this.dataExtractOrder == TableOrder.BY_ROW) {
            keys = this.dataset.getColumnKeys();
        } else if (this.dataExtractOrder == TableOrder.BY_COLUMN) {
            keys = this.dataset.getRowKeys();
        }
        if (keys != null) {
            int section = 0;
            Iterator iterator = keys.iterator();
            while (iterator.hasNext()) {
                Comparable key = (Comparable) iterator.next();
                String label = key.toString();
                String description = label;
                Paint paint = (Paint) this.sectionPaints.get(key);
                LegendItem item = new LegendItem(label, description, null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE, paint, Plot.DEFAULT_OUTLINE_STROKE, paint);
                item.setDataset(getDataset());
                result.add(item);
                section++;
            }
        }
        if (this.limit > 0.0) {
            result.add(new LegendItem(this.aggregatedItemsKey.toString(), this.aggregatedItemsKey.toString(), null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE, this.aggregatedItemsPaint, Plot.DEFAULT_OUTLINE_STROKE, this.aggregatedItemsPaint));
        }
    }
    return result;
}","public void test0912() throws Throwable {
    String[] stringArray0 = new String[3];
    DefaultIntervalCategoryDataset defaultIntervalCategoryDataset0 = new DefaultIntervalCategoryDataset(stringArray0, (Number[][]) null, (Number[][]) null);
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultIntervalCategoryDataset0);
    // Undeclared exception!
    try {
        multiplePiePlot0.getLegendItems();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Returns a collection of legend items for the pie chart.
 *
 * @return The legend items.
 */"
"public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) {
    // adjust the drawing area for the plot insets (if any)...
    RectangleInsets insets = getInsets();
    insets.trim(area);
    drawBackground(g2, area);
    drawOutline(g2, area);
    // check that there is some data to display...
    if (DatasetUtilities.isEmptyOrNull(this.dataset)) {
        drawNoDataMessage(g2, area);
        return;
    }
    int pieCount = 0;
    if (this.dataExtractOrder == TableOrder.BY_ROW) {
        pieCount = this.dataset.getRowCount();
    } else {
        pieCount = this.dataset.getColumnCount();
    }
    // the columns variable is always >= rows
    int displayCols = (int) Math.ceil(Math.sqrt(pieCount));
    int displayRows = (int) Math.ceil((double) pieCount / (double) displayCols);
    // swap rows and columns to match plotArea shape
    if (displayCols > displayRows && area.getWidth() < area.getHeight()) {
        int temp = displayCols;
        displayCols = displayRows;
        displayRows = temp;
    }
    prefetchSectionPaints();
    int x = (int) area.getX();
    int y = (int) area.getY();
    int width = ((int) area.getWidth()) / displayCols;
    int height = ((int) area.getHeight()) / displayRows;
    int row = 0;
    int column = 0;
    int diff = (displayRows * displayCols) - pieCount;
    int xoffset = 0;
    Rectangle rect = new Rectangle();
    for (int pieIndex = 0; pieIndex < pieCount; pieIndex++) {
        rect.setBounds(x + xoffset + (width * column), y + (height * row), width, height);
        String title = null;
        if (this.dataExtractOrder == TableOrder.BY_ROW) {
            title = this.dataset.getRowKey(pieIndex).toString();
        } else {
            title = this.dataset.getColumnKey(pieIndex).toString();
        }
        this.pieChart.setTitle(title);
        PieDataset piedataset = null;
        PieDataset dd = new CategoryToPieDataset(this.dataset, this.dataExtractOrder, pieIndex);
        if (this.limit > 0.0) {
            piedataset = DatasetUtilities.createConsolidatedPieDataset(dd, this.aggregatedItemsKey, this.limit);
        } else {
            piedataset = dd;
        }
        PiePlot piePlot = (PiePlot) this.pieChart.getPlot();
        piePlot.setDataset(piedataset);
        piePlot.setPieIndex(pieIndex);
        // update the section colors to match the global colors...
        for (int i = 0; i < piedataset.getItemCount(); i++) {
            Comparable key = piedataset.getKey(i);
            Paint p;
            if (key.equals(this.aggregatedItemsKey)) {
                p = this.aggregatedItemsPaint;
            } else {
                p = (Paint) this.sectionPaints.get(key);
            }
            piePlot.setSectionPaint(key, p);
        }
        ChartRenderingInfo subinfo = null;
        if (info != null) {
            subinfo = new ChartRenderingInfo();
        }
        this.pieChart.draw(g2, rect, subinfo);
        if (info != null) {
            info.getOwner().getEntityCollection().addAll(subinfo.getEntityCollection());
            info.addSubplotInfo(subinfo.getPlotInfo());
        }
        ++column;
        if (column == displayCols) {
            column = 0;
            ++row;
            if (row == displayRows - 1 && diff != 0) {
                xoffset = (diff * width) / 2;
            }
        }
    }
}","public void test1013() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    JFreeChart jFreeChart0 = multiplePiePlot0.getPieChart();
    ChartPanel chartPanel0 = new ChartPanel(jFreeChart0, 2670, 15, 10, 10, 2670, 3224, true, true, true, true, true, true);
    Rectangle2D rectangle2D0 = chartPanel0.getScreenDataArea();
    PlotState plotState0 = new PlotState();
    ChartRenderingInfo chartRenderingInfo0 = new ChartRenderingInfo();
    PlotRenderingInfo plotRenderingInfo0 = chartRenderingInfo0.getPlotInfo();
    // Undeclared exception!
    try {
        multiplePiePlot0.draw((Graphics2D) null, rectangle2D0, (Point2D) null, plotState0, plotRenderingInfo0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jfree.chart.plot.Plot"", e);
    }
}","/**
 * Draws the plot on a Java 2D graphics device (such as the screen or a
 * printer).
 *
 * @param g2  the graphics device.
 * @param area  the area within which the plot should be drawn.
 * @param anchor  the anchor point (<code>null</code> permitted).
 * @param parentState  the state from the parent plot, if there is one.
 * @param info  collects info about the drawing.
 */"
"public double getLimit() {
    return this.limit;
}","public void test1114() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    multiplePiePlot0.getDataset();
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof MultiplePiePlot)) {
        return false;
    }
    MultiplePiePlot that = (MultiplePiePlot) obj;
    if (this.dataExtractOrder != that.dataExtractOrder) {
        return false;
    }
    if (this.limit != that.limit) {
        return false;
    }
    if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {
        return false;
    }
    if (!PaintUtilities.equal(this.aggregatedItemsPaint, that.aggregatedItemsPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    return true;
}","public void test1215() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    multiplePiePlot0.setBackgroundAlpha(10);
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is not considered in the equality test.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return <code>true</code> if this plot is equal to <code>obj</code>, and
 *     <code>false</code> otherwise.
 */"
"public double getLimit() {
    return this.limit;
}","public void test1216() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    multiplePiePlot0.setBackgroundAlpha(10);
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertEquals(0.0, multiplePiePlot1.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof MultiplePiePlot)) {
        return false;
    }
    MultiplePiePlot that = (MultiplePiePlot) obj;
    if (this.dataExtractOrder != that.dataExtractOrder) {
        return false;
    }
    if (this.limit != that.limit) {
        return false;
    }
    if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {
        return false;
    }
    if (!PaintUtilities.equal(this.aggregatedItemsPaint, that.aggregatedItemsPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    return true;
}","public void test1317() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    Color color0 = (Color) JFreeChart.DEFAULT_BACKGROUND_PAINT;
    multiplePiePlot0.setAggregatedItemsPaint(color0);
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertFalse(multiplePiePlot1.equals((Object) multiplePiePlot0));
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is not considered in the equality test.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return <code>true</code> if this plot is equal to <code>obj</code>, and
 *     <code>false</code> otherwise.
 */"
"public double getLimit() {
    return this.limit;
}","public void test1318() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    Color color0 = (Color) JFreeChart.DEFAULT_BACKGROUND_PAINT;
    multiplePiePlot0.setAggregatedItemsPaint(color0);
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertEquals(0.0, multiplePiePlot1.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof MultiplePiePlot)) {
        return false;
    }
    MultiplePiePlot that = (MultiplePiePlot) obj;
    if (this.dataExtractOrder != that.dataExtractOrder) {
        return false;
    }
    if (this.limit != that.limit) {
        return false;
    }
    if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {
        return false;
    }
    if (!PaintUtilities.equal(this.aggregatedItemsPaint, that.aggregatedItemsPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    return true;
}","public void test1319() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    Color color0 = (Color) JFreeChart.DEFAULT_BACKGROUND_PAINT;
    multiplePiePlot0.setAggregatedItemsPaint(color0);
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is not considered in the equality test.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return <code>true</code> if this plot is equal to <code>obj</code>, and
 *     <code>false</code> otherwise.
 */"
"public double getLimit() {
    return this.limit;
}","public void test1420() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    multiplePiePlot0.setAggregatedItemsKey(0.5F);
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertEquals(0.0, multiplePiePlot1.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof MultiplePiePlot)) {
        return false;
    }
    MultiplePiePlot that = (MultiplePiePlot) obj;
    if (this.dataExtractOrder != that.dataExtractOrder) {
        return false;
    }
    if (this.limit != that.limit) {
        return false;
    }
    if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {
        return false;
    }
    if (!PaintUtilities.equal(this.aggregatedItemsPaint, that.aggregatedItemsPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    return true;
}","public void test1421() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    multiplePiePlot0.setAggregatedItemsKey(0.5F);
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is not considered in the equality test.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return <code>true</code> if this plot is equal to <code>obj</code>, and
 *     <code>false</code> otherwise.
 */"
"public double getLimit() {
    return this.limit;
}","public void test1522() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    multiplePiePlot0.setLimit(10);
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertEquals(10.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof MultiplePiePlot)) {
        return false;
    }
    MultiplePiePlot that = (MultiplePiePlot) obj;
    if (this.dataExtractOrder != that.dataExtractOrder) {
        return false;
    }
    if (this.limit != that.limit) {
        return false;
    }
    if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {
        return false;
    }
    if (!PaintUtilities.equal(this.aggregatedItemsPaint, that.aggregatedItemsPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    return true;
}","public void test1523() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    multiplePiePlot0.setLimit(10);
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is not considered in the equality test.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return <code>true</code> if this plot is equal to <code>obj</code>, and
 *     <code>false</code> otherwise.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof MultiplePiePlot)) {
        return false;
    }
    MultiplePiePlot that = (MultiplePiePlot) obj;
    if (this.dataExtractOrder != that.dataExtractOrder) {
        return false;
    }
    if (this.limit != that.limit) {
        return false;
    }
    if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {
        return false;
    }
    if (!PaintUtilities.equal(this.aggregatedItemsPaint, that.aggregatedItemsPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    return true;
}","public void test1624() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    TableOrder tableOrder0 = TableOrder.BY_ROW;
    multiplePiePlot0.setDataExtractOrder(tableOrder0);
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is not considered in the equality test.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return <code>true</code> if this plot is equal to <code>obj</code>, and
 *     <code>false</code> otherwise.
 */"
"public double getLimit() {
    return this.limit;
}","public void test1625() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    TableOrder tableOrder0 = TableOrder.BY_ROW;
    multiplePiePlot0.setDataExtractOrder(tableOrder0);
    MultiplePiePlot multiplePiePlot1 = new MultiplePiePlot();
    boolean boolean0 = multiplePiePlot0.equals(multiplePiePlot1);
    assertEquals(0.0, multiplePiePlot1.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test1726() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    defaultKeyedValues2DDataset0.addChangeListener(multiplePiePlot0);
    multiplePiePlot0.setDataset(defaultKeyedValues2DDataset0);
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test1827() throws Throwable {
    DefaultStatisticalCategoryDataset defaultStatisticalCategoryDataset0 = new DefaultStatisticalCategoryDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultStatisticalCategoryDataset0);
    Object object0 = new Object();
    boolean boolean0 = multiplePiePlot0.equals(object0);
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof MultiplePiePlot)) {
        return false;
    }
    MultiplePiePlot that = (MultiplePiePlot) obj;
    if (this.dataExtractOrder != that.dataExtractOrder) {
        return false;
    }
    if (this.limit != that.limit) {
        return false;
    }
    if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {
        return false;
    }
    if (!PaintUtilities.equal(this.aggregatedItemsPaint, that.aggregatedItemsPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    return true;
}","public void test1828() throws Throwable {
    DefaultStatisticalCategoryDataset defaultStatisticalCategoryDataset0 = new DefaultStatisticalCategoryDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultStatisticalCategoryDataset0);
    Object object0 = new Object();
    boolean boolean0 = multiplePiePlot0.equals(object0);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is not considered in the equality test.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return <code>true</code> if this plot is equal to <code>obj</code>, and
 *     <code>false</code> otherwise.
 */"
"public double getLimit() {
    return this.limit;
}","public void test1929() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    multiplePiePlot0.getLegendItems();
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public int getItemCount() {
    return this.items.size();
}","public void test2030() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    defaultKeyedValues2DDataset0.setValue((Number) 1.0F, (Comparable) 10, (Comparable) 1.0F);
    TableOrder tableOrder0 = TableOrder.BY_ROW;
    multiplePiePlot0.setDataExtractOrder(tableOrder0);
    multiplePiePlot0.getLegendItems();
    LegendItemCollection legendItemCollection0 = multiplePiePlot0.getLegendItems();
    assertEquals(1, legendItemCollection0.getItemCount());
}","/**
 * Returns the number of legend items in the collection.
 *
 * @return The item count.
 */"
"public double getLimit() {
    return this.limit;
}","public void test2031() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    defaultKeyedValues2DDataset0.setValue((Number) 1.0F, (Comparable) 10, (Comparable) 1.0F);
    TableOrder tableOrder0 = TableOrder.BY_ROW;
    multiplePiePlot0.setDataExtractOrder(tableOrder0);
    multiplePiePlot0.getLegendItems();
    LegendItemCollection legendItemCollection0 = multiplePiePlot0.getLegendItems();
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test2132() throws Throwable {
    double[][] doubleArray0 = new double[2][0];
    double[] doubleArray1 = new double[9];
    doubleArray0[0] = doubleArray1;
    doubleArray0[1] = doubleArray1;
    DefaultIntervalCategoryDataset defaultIntervalCategoryDataset0 = new DefaultIntervalCategoryDataset(doubleArray0, doubleArray0);
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultIntervalCategoryDataset0);
    JFreeChart jFreeChart0 = new JFreeChart(""hnlXySWvrw"", multiplePiePlot0);
    jFreeChart0.createBufferedImage(10, 10);
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test2233() throws Throwable {
    double[][] doubleArray0 = new double[2][0];
    double[] doubleArray1 = new double[10];
    doubleArray0[0] = doubleArray1;
    doubleArray0[1] = doubleArray1;
    DefaultIntervalCategoryDataset defaultIntervalCategoryDataset0 = new DefaultIntervalCategoryDataset(doubleArray0, doubleArray0);
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultIntervalCategoryDataset0);
    JFreeChart jFreeChart0 = new JFreeChart(""hnlXySWvrw"", multiplePiePlot0);
    StandardEntityCollection standardEntityCollection0 = new StandardEntityCollection();
    ChartRenderingInfo chartRenderingInfo0 = new ChartRenderingInfo(standardEntityCollection0);
    jFreeChart0.createBufferedImage(8, 8, chartRenderingInfo0);
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test2334() throws Throwable {
    DefaultStatisticalCategoryDataset defaultStatisticalCategoryDataset0 = new DefaultStatisticalCategoryDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultStatisticalCategoryDataset0);
    BufferedImage bufferedImage0 = new BufferedImage(24, 24, 10);
    Graphics2D graphics2D0 = bufferedImage0.createGraphics();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double(547.2595721, (-319.649), (-5.0), 1.0F);
    Point2D point2D0 = RectangleAnchor.coordinates(rectangle2D_Double0, (RectangleAnchor) null);
    Rectangle rectangle0 = new Rectangle(0, 0);
    PlotState plotState0 = new PlotState();
    StandardEntityCollection standardEntityCollection0 = new StandardEntityCollection();
    ChartRenderingInfo chartRenderingInfo0 = new ChartRenderingInfo(standardEntityCollection0);
    PlotRenderingInfo plotRenderingInfo0 = new PlotRenderingInfo(chartRenderingInfo0);
    multiplePiePlot0.draw(graphics2D0, rectangle0, point2D0, plotState0, plotRenderingInfo0);
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public void setAggregatedItemsPaint(Paint paint) {
    if (paint == null) {
        throw new IllegalArgumentException(""Null 'paint' argument."");
    }
    this.aggregatedItemsPaint = paint;
    fireChangeEvent();
}","public void test2435() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    // Undeclared exception!
    try {
        multiplePiePlot0.setAggregatedItemsPaint((Paint) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'paint' argument.
        //
        verifyException(""org.jfree.chart.plot.MultiplePiePlot"", e);
    }
}","/**
 * Sets the paint used to draw the pie section representing the aggregated
 * items and sends a {@link PlotChangeEvent} to all registered listeners.
 *
 * @param paint  the paint (<code>null</code> not permitted).
 *
 * @since 1.0.2
 */"
"public void setAggregatedItemsKey(Comparable key) {
    if (key == null) {
        throw new IllegalArgumentException(""Null 'key' argument."");
    }
    this.aggregatedItemsKey = key;
    fireChangeEvent();
}","public void test2536() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    // Undeclared exception!
    try {
        multiplePiePlot0.setAggregatedItemsKey((Comparable) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'key' argument.
        //
        verifyException(""org.jfree.chart.plot.MultiplePiePlot"", e);
    }
}","/**
 * Sets the key for aggregated items in the pie plots.  You must ensure
 * that this doesn't clash with any keys in the dataset.
 *
 * @param key  the key (<code>null</code> not permitted).
 *
 * @since 1.0.2
 */"
"public void setDataExtractOrder(TableOrder order) {
    if (order == null) {
        throw new IllegalArgumentException(""Null 'order' argument"");
    }
    this.dataExtractOrder = order;
    fireChangeEvent();
}","public void test2637() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    // Undeclared exception!
    try {
        multiplePiePlot0.setDataExtractOrder((TableOrder) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'order' argument
        //
        verifyException(""org.jfree.chart.plot.MultiplePiePlot"", e);
    }
}","/**
 * Sets the data extract order (by row or by column) and sends a
 * {@link PlotChangeEvent} to all registered listeners.
 *
 * @param order  the order (<code>null</code> not permitted).
 */"
"public void setPieChart(JFreeChart pieChart) {
    if (pieChart == null) {
        throw new IllegalArgumentException(""Null 'pieChart' argument."");
    }
    if (!(pieChart.getPlot() instanceof PiePlot)) {
        throw new IllegalArgumentException(""The 'pieChart' argument must "" + ""be a chart based on a PiePlot."");
    }
    this.pieChart = pieChart;
    fireChangeEvent();
}","public void test2738() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    JFreeChart jFreeChart0 = new JFreeChart(multiplePiePlot0);
    // Undeclared exception!
    try {
        multiplePiePlot0.setPieChart(jFreeChart0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The 'pieChart' argument must be a chart based on a PiePlot.
        //
        verifyException(""org.jfree.chart.plot.MultiplePiePlot"", e);
    }
}","/**
 * Sets the chart that is used to draw the individual pie plots.  The
 * chart's plot must be an instance of {@link PiePlot}.
 *
 * @param pieChart  the pie chart (<code>null</code> not permitted).
 *
 * @see #getPieChart()
 */"
"public void setPieChart(JFreeChart pieChart) {
    if (pieChart == null) {
        throw new IllegalArgumentException(""Null 'pieChart' argument."");
    }
    if (!(pieChart.getPlot() instanceof PiePlot)) {
        throw new IllegalArgumentException(""The 'pieChart' argument must "" + ""be a chart based on a PiePlot."");
    }
    this.pieChart = pieChart;
    fireChangeEvent();
}","public void test2839() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    // Undeclared exception!
    try {
        multiplePiePlot0.setPieChart((JFreeChart) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'pieChart' argument.
        //
        verifyException(""org.jfree.chart.plot.MultiplePiePlot"", e);
    }
}","/**
 * Sets the chart that is used to draw the individual pie plots.  The
 * chart's plot must be an instance of {@link PiePlot}.
 *
 * @param pieChart  the pie chart (<code>null</code> not permitted).
 *
 * @see #getPieChart()
 */"
"public double getLimit() {
    return this.limit;
}","public void test2940() throws Throwable {
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot();
    multiplePiePlot0.setDataset((CategoryDataset) null);
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test3041() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    TableOrder tableOrder0 = multiplePiePlot0.getDataExtractOrder();
    multiplePiePlot0.setDataExtractOrder(tableOrder0);
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test3142() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    double double0 = multiplePiePlot0.getLimit();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public int getItemCount() {
    return this.items.size();
}","public void test3244() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    multiplePiePlot0.setLimit(1.0);
    LegendItemCollection legendItemCollection0 = multiplePiePlot0.getLegendItems();
    assertEquals(1, legendItemCollection0.getItemCount());
}","/**
 * Returns the number of legend items in the collection.
 *
 * @return The item count.
 */"
"public double getLimit() {
    return this.limit;
}","public void test3345() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    defaultKeyedValues2DDataset0.setValue((Number) 1.0F, (Comparable) 10, (Comparable) 1.0F);
    multiplePiePlot0.getLegendItems();
    LegendItemCollection legendItemCollection0 = multiplePiePlot0.getLegendItems();
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public int getItemCount() {
    return this.items.size();
}","public void test3346() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    defaultKeyedValues2DDataset0.setValue((Number) 1.0F, (Comparable) 10, (Comparable) 1.0F);
    multiplePiePlot0.getLegendItems();
    LegendItemCollection legendItemCollection0 = multiplePiePlot0.getLegendItems();
    assertEquals(1, legendItemCollection0.getItemCount());
}","/**
 * Returns the number of legend items in the collection.
 *
 * @return The item count.
 */"
"public Comparable getAggregatedItemsKey() {
    return this.aggregatedItemsKey;
}","public void test3447() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    Comparable comparable0 = multiplePiePlot0.getAggregatedItemsKey();
    assertEquals(""Other"", comparable0);
}","/**
 * Returns the key for aggregated items in the pie plots, if there are any.
 * The default value is ""Other"".
 *
 * @return The aggregated items key.
 *
 * @since 1.0.2
 */"
"public double getLimit() {
    return this.limit;
}","public void test3448() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    Comparable comparable0 = multiplePiePlot0.getAggregatedItemsKey();
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public double getLimit() {
    return this.limit;
}","public void test3549() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    String string0 = multiplePiePlot0.getPlotType();
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
"public String getPlotType() {
    return ""Multiple Pie Plot"";
    // TODO: need to fetch this from localised resources
}","public void test3550() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    String string0 = multiplePiePlot0.getPlotType();
    assertEquals(""Multiple Pie Plot"", string0);
}","/**
 * Returns a short string describing the type of plot.
 *
 * @return The plot type.
 */"
"public double getLimit() {
    return this.limit;
}","public void test3651() throws Throwable {
    DefaultKeyedValues2DDataset defaultKeyedValues2DDataset0 = new DefaultKeyedValues2DDataset();
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultKeyedValues2DDataset0);
    JFreeChart jFreeChart0 = multiplePiePlot0.getPieChart();
    multiplePiePlot0.setPieChart(jFreeChart0);
    assertEquals(0.0, multiplePiePlot0.getLimit(), 0.01);
}","/**
 * Returns the limit (as a percentage) below which small pie sections are
 * aggregated.
 *
 * @return The limit percentage.
 */"
