focal_method,test_prefix,docstring
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test0000() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test0001() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setInteriorGap(0.0);
    assertEquals(0.0, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test0012() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.isCircular();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test0013() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.isCircular();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test0014() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.isCircular();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test0015() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.isCircular();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test0016() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.isCircular();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test0017() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.isCircular();
    assertFalse(boolean0);
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test0018() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.isCircular();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test0019() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.isCircular();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test00110() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.isCircular();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test00111() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.isCircular();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test00112() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.isCircular();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test00213() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test00214() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test00215() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test00216() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test00217() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test00218() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public Paint getShadowPaint() {
    return this.shadowPaint;
}","public void test00219() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertNull(paint0);
}","/**
 * Returns the shadow paint.
 *
 * @return The paint (possibly <code>null</code>).
 *
 * @see #setShadowPaint(Paint)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test00220() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test00221() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test00222() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test00223() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test00224() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setShadowPaint((Paint) null);
    Paint paint0 = piePlot0.getShadowPaint();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test00325() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Day day0 = new Day();
    piePlot3D0.getSectionOutlineStroke(day0);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test00326() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Day day0 = new Day();
    piePlot3D0.getSectionOutlineStroke(day0);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test00327() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Day day0 = new Day();
    piePlot3D0.getSectionOutlineStroke(day0);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test00328() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Day day0 = new Day();
    piePlot3D0.getSectionOutlineStroke(day0);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test00329() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Day day0 = new Day();
    piePlot3D0.getSectionOutlineStroke(day0);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test00330() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Day day0 = new Day();
    piePlot3D0.getSectionOutlineStroke(day0);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test00331() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Day day0 = new Day();
    piePlot3D0.getSectionOutlineStroke(day0);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test00332() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Day day0 = new Day();
    piePlot3D0.getSectionOutlineStroke(day0);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test00333() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Day day0 = new Day();
    piePlot3D0.getSectionOutlineStroke(day0);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test00334() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Day day0 = new Day();
    piePlot3D0.getSectionOutlineStroke(day0);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test00335() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Day day0 = new Day();
    piePlot3D0.getSectionOutlineStroke(day0);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test00436() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    MockDate mockDate0 = new MockDate(10, (-820), (-820));
    Quarter quarter0 = new Quarter(mockDate0);
    piePlot3D0.getSectionOutlinePaint(quarter0);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test00437() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    MockDate mockDate0 = new MockDate(10, (-820), (-820));
    Quarter quarter0 = new Quarter(mockDate0);
    piePlot3D0.getSectionOutlinePaint(quarter0);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test00438() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    MockDate mockDate0 = new MockDate(10, (-820), (-820));
    Quarter quarter0 = new Quarter(mockDate0);
    piePlot3D0.getSectionOutlinePaint(quarter0);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test00439() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    MockDate mockDate0 = new MockDate(10, (-820), (-820));
    Quarter quarter0 = new Quarter(mockDate0);
    piePlot3D0.getSectionOutlinePaint(quarter0);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test00440() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    MockDate mockDate0 = new MockDate(10, (-820), (-820));
    Quarter quarter0 = new Quarter(mockDate0);
    piePlot3D0.getSectionOutlinePaint(quarter0);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test00441() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    MockDate mockDate0 = new MockDate(10, (-820), (-820));
    Quarter quarter0 = new Quarter(mockDate0);
    piePlot3D0.getSectionOutlinePaint(quarter0);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test00442() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    MockDate mockDate0 = new MockDate(10, (-820), (-820));
    Quarter quarter0 = new Quarter(mockDate0);
    piePlot3D0.getSectionOutlinePaint(quarter0);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test00443() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    MockDate mockDate0 = new MockDate(10, (-820), (-820));
    Quarter quarter0 = new Quarter(mockDate0);
    piePlot3D0.getSectionOutlinePaint(quarter0);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test00444() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    MockDate mockDate0 = new MockDate(10, (-820), (-820));
    Quarter quarter0 = new Quarter(mockDate0);
    piePlot3D0.getSectionOutlinePaint(quarter0);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test00445() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    MockDate mockDate0 = new MockDate(10, (-820), (-820));
    Quarter quarter0 = new Quarter(mockDate0);
    piePlot3D0.getSectionOutlinePaint(quarter0);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test00446() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    MockDate mockDate0 = new MockDate(10, (-820), (-820));
    Quarter quarter0 = new Quarter(mockDate0);
    piePlot3D0.getSectionOutlinePaint(quarter0);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test00547() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getDataset();
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test00548() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getDataset();
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test00549() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getDataset();
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test00550() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getDataset();
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test00551() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getDataset();
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test00552() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getDataset();
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test00553() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getDataset();
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test00554() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getDataset();
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test00555() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getDataset();
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test00556() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getDataset();
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test00557() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getDataset();
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test00658() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double(0.4, 1.0F, 10, 10);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.689678651025, 4201.65208, 2866.689678651025);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test00659() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double(0.4, 1.0F, 10, 10);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.689678651025, 4201.65208, 2866.689678651025);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test00660() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double(0.4, 1.0F, 10, 10);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.689678651025, 4201.65208, 2866.689678651025);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test00661() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double(0.4, 1.0F, 10, 10);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.689678651025, 4201.65208, 2866.689678651025);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test00662() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double(0.4, 1.0F, 10, 10);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.689678651025, 4201.65208, 2866.689678651025);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test00663() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double(0.4, 1.0F, 10, 10);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.689678651025, 4201.65208, 2866.689678651025);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test00664() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double(0.4, 1.0F, 10, 10);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.689678651025, 4201.65208, 2866.689678651025);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test00665() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double(0.4, 1.0F, 10, 10);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.689678651025, 4201.65208, 2866.689678651025);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test00667() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double(0.4, 1.0F, 10, 10);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.689678651025, 4201.65208, 2866.689678651025);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test00768() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.height = 90.0;
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test00769() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.height = 90.0;
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"protected Rectangle2D getArcBounds(Rectangle2D unexploded, Rectangle2D exploded, double angle, double extent, double explodePercent) {
    if (explodePercent == 0.0) {
        return unexploded;
    } else {
        Arc2D arc1 = new Arc2D.Double(unexploded, angle, extent / 2, Arc2D.OPEN);
        Point2D point1 = arc1.getEndPoint();
        Arc2D.Double arc2 = new Arc2D.Double(exploded, angle, extent / 2, Arc2D.OPEN);
        Point2D point2 = arc2.getEndPoint();
        double deltaX = (point1.getX() - point2.getX()) * explodePercent;
        double deltaY = (point1.getY() - point2.getY()) * explodePercent;
        return new Rectangle2D.Double(unexploded.getX() - deltaX, unexploded.getY() - deltaY, unexploded.getWidth(), unexploded.getHeight());
    }
}","public void test00770() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.height = 90.0;
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertNotSame(rectangle2D0, rectangle2D_Double0);
}","/**
 * Returns a rectangle that can be used to create a pie section (taking
 * into account the amount by which the pie section is 'exploded').
 *
 * @param unexploded  the area inside which the unexploded pie sections are
 *                    drawn.
 * @param exploded  the area inside which the exploded pie sections are
 *                  drawn.
 * @param angle  the start angle.
 * @param extent  the extent of the arc.
 * @param explodePercent  the amount by which the pie section is exploded.
 *
 * @return A rectangle that can be used to create a pie section.
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test00771() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.height = 90.0;
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test00772() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.height = 90.0;
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test00774() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.height = 90.0;
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test00775() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.height = 90.0;
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test00776() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.height = 90.0;
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test00777() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.height = 90.0;
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test00778() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.height = 90.0;
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test00879() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test00880() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test00881() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"protected Rectangle2D getArcBounds(Rectangle2D unexploded, Rectangle2D exploded, double angle, double extent, double explodePercent) {
    if (explodePercent == 0.0) {
        return unexploded;
    } else {
        Arc2D arc1 = new Arc2D.Double(unexploded, angle, extent / 2, Arc2D.OPEN);
        Point2D point1 = arc1.getEndPoint();
        Arc2D.Double arc2 = new Arc2D.Double(exploded, angle, extent / 2, Arc2D.OPEN);
        Point2D point2 = arc2.getEndPoint();
        double deltaX = (point1.getX() - point2.getX()) * explodePercent;
        double deltaY = (point1.getY() - point2.getY()) * explodePercent;
        return new Rectangle2D.Double(unexploded.getX() - deltaX, unexploded.getY() - deltaY, unexploded.getWidth(), unexploded.getHeight());
    }
}","public void test00882() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertEquals((-9.66796875), rectangle2D_Double0.y, 0.01);
}","/**
 * Returns a rectangle that can be used to create a pie section (taking
 * into account the amount by which the pie section is 'exploded').
 *
 * @param unexploded  the area inside which the unexploded pie sections are
 *                    drawn.
 * @param exploded  the area inside which the exploded pie sections are
 *                  drawn.
 * @param angle  the start angle.
 * @param extent  the extent of the arc.
 * @param explodePercent  the amount by which the pie section is exploded.
 *
 * @return A rectangle that can be used to create a pie section.
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test00883() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test00884() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test00885() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test00886() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test00887() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test00889() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test00890() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test00891() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    AffineTransform affineTransform0 = AffineTransform.getQuadrantRotateInstance(14);
    FontRenderContext fontRenderContext0 = new FontRenderContext(affineTransform0, true, true);
    Rectangle2D rectangle2D0 = piePlot0.DEFAULT_LABEL_FONT.getStringBounds(""Null 'distributor' argument."", fontRenderContext0);
    Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double) piePlot0.getArcBounds(rectangle2D0, rectangle2D0, 14, (-2.147483648E9), 1.0F);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test00992() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.x = (-4.0);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test00993() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.x = (-4.0);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test00994() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.x = (-4.0);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test00995() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.x = (-4.0);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test00996() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.x = (-4.0);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test00997() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.x = (-4.0);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test00998() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.x = (-4.0);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test00999() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.x = (-4.0);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test009101() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.x = (-4.0);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test009102() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    rectangle2D_Double0.x = (-4.0);
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 2866.110985, 4201.65208, 2866.110985);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"protected Paint lookupSectionPaint(Comparable key, boolean autoPopulate) {
    Paint result = null;
    // is a paint defined for the specified key
    result = this.sectionPaintMap.getPaint(key);
    if (result != null) {
        return result;
    }
    // nothing defined - do we autoPopulate?
    if (autoPopulate) {
        DrawingSupplier ds = getDrawingSupplier();
        if (ds != null) {
            result = ds.getNextPaint();
            this.sectionPaintMap.put(key, result);
        } else {
            result = this.baseSectionPaint;
        }
    } else {
        result = this.baseSectionPaint;
    }
    return result;
}","public void test010103() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    // Undeclared exception!
    try {
        piePlot0.lookupSectionPaint((Comparable) null, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'key' argument.
        //
        verifyException(""org.jfree.chart.PaintMap"", e);
    }
}","/**
 * Returns the paint for the specified section.  The lookup involves these
 * steps:
 * <ul>
 * <li>if {@link #getSectionPaint(Comparable)} is non-<code>null</code>
 *         return it;</li>
 * <li>if {@link #getSectionPaint(Comparable)} is <code>null</code> but
 *         <code>autoPopulate</code> is <code>true</code>, attempt to fetch
 *         a new paint from the drawing supplier
 *         ({@link #getDrawingSupplier()});
 * <li>if all else fails, return {@link #getBaseSectionPaint()}.
 * </ul>
 *
 * @param key  the section key.
 * @param autoPopulate  a flag that controls whether the drawing supplier
 *     is used to auto-populate the section paint settings.
 *
 * @return The paint.
 *
 * @since 1.0.3
 */"
"protected Stroke lookupSectionOutlineStroke(Comparable key, boolean autoPopulate) {
    Stroke result = null;
    // is a stroke defined for the specified key
    result = this.sectionOutlineStrokeMap.getStroke(key);
    if (result != null) {
        return result;
    }
    // nothing defined - do we autoPopulate?
    if (autoPopulate) {
        DrawingSupplier ds = getDrawingSupplier();
        if (ds != null) {
            result = ds.getNextOutlineStroke();
            this.sectionOutlineStrokeMap.put(key, result);
        } else {
            result = this.baseSectionOutlineStroke;
        }
    } else {
        result = this.baseSectionOutlineStroke;
    }
    return result;
}","public void test011104() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    // Undeclared exception!
    try {
        piePlot0.lookupSectionOutlineStroke((Comparable) null, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'key' argument.
        //
        verifyException(""org.jfree.chart.StrokeMap"", e);
    }
}","/**
 * Returns the outline stroke for the specified section.  The lookup
 * involves these steps:
 * <ul>
 * <li>if {@link #getSectionOutlineStroke(Comparable)} is
 *         non-<code>null</code> return it;</li>
 * <li>if {@link #getSectionOutlineStroke(Comparable)} is
 *         <code>null</code> but <code>autoPopulate</code> is
 *         <code>true</code>, attempt to fetch a new outline stroke from
 *         the drawing supplier ({@link #getDrawingSupplier()});
 * <li>if all else fails, return {@link #getBaseSectionOutlineStroke()}.
 * </ul>
 *
 * @param key  the section key.
 * @param autoPopulate  a flag that controls whether the drawing supplier
 *     is used to auto-populate the section outline stroke settings.
 *
 * @return The stroke.
 *
 * @since 1.0.3
 */"
"//// SECTION OUTLINE STROKE ///////////////////////////////////////////////
/**
 * Returns the outline stroke for the specified section.  This is equivalent
 * to <code>lookupSectionOutlineStroke(section, false)</code>.
 *
 * @param key  the section key.
 *
 * @return The stroke for the specified section.
 *
 * @since 1.0.3
 *
 * @see #lookupSectionOutlineStroke(Comparable, boolean)
 */
protected Stroke lookupSectionOutlineStroke(Comparable key) {
    return lookupSectionOutlineStroke(key, false);
}","public void test012105() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    // Undeclared exception!
    try {
        piePlot3D0.lookupSectionOutlineStroke((Comparable) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'key' argument.
        //
        verifyException(""org.jfree.chart.StrokeMap"", e);
    }
}",""
"protected Paint lookupSectionOutlinePaint(Comparable key, boolean autoPopulate) {
    Paint result = null;
    // is a paint defined for the specified key
    result = this.sectionOutlinePaintMap.getPaint(key);
    if (result != null) {
        return result;
    }
    // nothing defined - do we autoPopulate?
    if (autoPopulate) {
        DrawingSupplier ds = getDrawingSupplier();
        if (ds != null) {
            result = ds.getNextOutlinePaint();
            this.sectionOutlinePaintMap.put(key, result);
        } else {
            result = this.baseSectionOutlinePaint;
        }
    } else {
        result = this.baseSectionOutlinePaint;
    }
    return result;
}","public void test013106() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    // Undeclared exception!
    try {
        piePlot3D0.lookupSectionOutlinePaint((Comparable) null, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'key' argument.
        //
        verifyException(""org.jfree.chart.PaintMap"", e);
    }
}","/**
 * Returns the outline paint for the specified section.  The lookup
 * involves these steps:
 * <ul>
 * <li>if {@link #getSectionOutlinePaint(Comparable)} is
 *         non-<code>null</code> return it;</li>
 * <li>if {@link #getSectionOutlinePaint(Comparable)} is
 *         <code>null</code> but <code>autoPopulate</code> is
 *         <code>true</code>, attempt to fetch a new outline paint from
 *         the drawing supplier ({@link #getDrawingSupplier()});
 * <li>if all else fails, return {@link #getBaseSectionOutlinePaint()}.
 * </ul>
 *
 * @param key  the section key.
 * @param autoPopulate  a flag that controls whether the drawing supplier
 *     is used to auto-populate the section outline paint settings.
 *
 * @return The paint.
 *
 * @since 1.0.3
 */"
"protected Paint lookupSectionOutlinePaint(Comparable key) {
    return lookupSectionOutlinePaint(key, false);
}","public void test014107() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    // Undeclared exception!
    try {
        piePlot0.lookupSectionOutlinePaint((Comparable) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'key' argument.
        //
        verifyException(""org.jfree.chart.PaintMap"", e);
    }
}","/**
 * Returns the outline paint for the specified section.  This is equivalent
 * to <code>lookupSectionPaint(section, false)</code>.
 *
 * @param key  the section key.
 *
 * @return The paint for the specified section.
 *
 * @since 1.0.3
 *
 * @see #lookupSectionOutlinePaint(Comparable, boolean)
 */"
"public double getMaximumExplodePercent() {
    double result = 0.0;
    Iterator iterator = this.dataset.getKeys().iterator();
    while (iterator.hasNext()) {
        Comparable key = (Comparable) iterator.next();
        Number explode = (Number) this.explodePercentages.get(key);
        if (explode != null) {
            result = Math.max(result, explode.doubleValue());
        }
    }
    return result;
}","public void test015108() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    // Undeclared exception!
    try {
        ringPlot0.getMaximumExplodePercent();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Returns the maximum explode percent.
 *
 * @return The percent.
 */"
"protected void drawRightLabel(Graphics2D g2, PiePlotState state, PieLabelRecord record) {
    double anchorX = state.getLinkArea().getMaxX();
    double targetX = anchorX + record.getGap();
    double targetY = record.getAllocatedY();
    if (this.labelLinksVisible) {
        double theta = record.getAngle();
        double linkX = state.getPieCenterX() + Math.cos(theta) * state.getPieWRadius() * record.getLinkPercent();
        double linkY = state.getPieCenterY() - Math.sin(theta) * state.getPieHRadius() * record.getLinkPercent();
        double elbowX = state.getPieCenterX() + Math.cos(theta) * state.getLinkArea().getWidth() / 2.0;
        double elbowY = state.getPieCenterY() - Math.sin(theta) * state.getLinkArea().getHeight() / 2.0;
        double anchorY = elbowY;
        g2.setPaint(this.labelLinkPaint);
        g2.setStroke(this.labelLinkStroke);
        g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));
        g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));
        g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));
    }
    TextBox tb = record.getLabel();
    tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.LEFT);
}","public void test016109() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    BufferedImage bufferedImage0 = new BufferedImage(10, 10, 10);
    Graphics2D graphics2D0 = bufferedImage0.createGraphics();
    PiePlotState piePlotState0 = new PiePlotState((PlotRenderingInfo) null);
    TextBlock textBlock0 = new TextBlock();
    TextBox textBox0 = new TextBox(textBlock0);
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(1.0F, 1.5707963267948966, (-939.337), textBox0, 1.0E-100, (-6719.1425893), (-939.337));
    // Undeclared exception!
    try {
        piePlot3D0.drawRightLabel(graphics2D0, piePlotState0, pieLabelRecord0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Draws a section label on the right side of the pie chart.
 *
 * @param g2  the graphics device.
 * @param state  the state.
 * @param record  the label record.
 */"
"public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor, PlotState parentState, PlotRenderingInfo info) {
    // adjust for insets...
    RectangleInsets insets = getInsets();
    insets.trim(plotArea);
    Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone();
    if (info != null) {
        info.setPlotArea(plotArea);
        info.setDataArea(plotArea);
    }
    drawBackground(g2, plotArea);
    Shape savedClip = g2.getClip();
    g2.clip(plotArea);
    // adjust the plot area by the interior spacing value
    double gapPercent = getInteriorGap();
    double labelPercent = 0.0;
    if (getLabelGenerator() != null) {
        labelPercent = getLabelGap() + getMaximumLabelWidth();
    }
    double gapHorizontal = plotArea.getWidth() * (gapPercent + labelPercent) * 2.0;
    double gapVertical = plotArea.getHeight() * gapPercent * 2.0;
    if (DEBUG_DRAW_INTERIOR) {
        double hGap = plotArea.getWidth() * getInteriorGap();
        double vGap = plotArea.getHeight() * getInteriorGap();
        double igx1 = plotArea.getX() + hGap;
        double igx2 = plotArea.getMaxX() - hGap;
        double igy1 = plotArea.getY() + vGap;
        double igy2 = plotArea.getMaxY() - vGap;
        g2.setPaint(Color.lightGray);
        g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, igy2 - igy1));
    }
    double linkX = plotArea.getX() + gapHorizontal / 2;
    double linkY = plotArea.getY() + gapVertical / 2;
    double linkW = plotArea.getWidth() - gapHorizontal;
    double linkH = plotArea.getHeight() - gapVertical;
    // make the link area a square if the pie chart is to be circular...
    if (isCircular()) {
        // is circular?
        double min = Math.min(linkW, linkH) / 2;
        linkX = (linkX + linkX + linkW) / 2 - min;
        linkY = (linkY + linkY + linkH) / 2 - min;
        linkW = 2 * min;
        linkH = 2 * min;
    }
    PiePlotState state = initialise(g2, plotArea, this, null, info);
    // the link area defines the dog leg points for the linking lines to
    // the labels
    Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, linkH * (1 - this.depthFactor));
    state.setLinkArea(linkAreaXX);
    if (DEBUG_DRAW_LINK_AREA) {
        g2.setPaint(Color.blue);
        g2.draw(linkAreaXX);
        g2.setPaint(Color.yellow);
        g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), linkAreaXX.getWidth(), linkAreaXX.getHeight()));
    }
    // the explode area defines the max circle/ellipse for the exploded pie
    // sections.
    // it is defined by shrinking the linkArea by the linkMargin factor.
    double hh = linkW * getLabelLinkMargin();
    double vv = linkH * getLabelLinkMargin();
    Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, linkY + vv / 2.0, linkW - hh, linkH - vv);
    state.setExplodedPieArea(explodeArea);
    // the pie area defines the circle/ellipse for regular pie sections.
    // it is defined by shrinking the explodeArea by the explodeMargin
    // factor.
    double maximumExplodePercent = getMaximumExplodePercent();
    double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);
    double h1 = explodeArea.getWidth() * percent;
    double v1 = explodeArea.getHeight() * percent;
    Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() + h1 / 2.0, explodeArea.getY() + v1 / 2.0, explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);
    // the link area defines the dog-leg point for the linking lines to
    // the labels
    int depth = (int) (pieArea.getHeight() * this.depthFactor);
    Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, linkH - depth);
    state.setLinkArea(linkArea);
    state.setPieArea(pieArea);
    state.setPieCenterX(pieArea.getCenterX());
    state.setPieCenterY(pieArea.getCenterY() - depth / 2.0);
    state.setPieWRadius(pieArea.getWidth() / 2.0);
    state.setPieHRadius((pieArea.getHeight() - depth) / 2.0);
    // get the data source - return if null;
    PieDataset dataset = getDataset();
    if (DatasetUtilities.isEmptyOrNull(getDataset())) {
        drawNoDataMessage(g2, plotArea);
        g2.setClip(savedClip);
        drawOutline(g2, plotArea);
        return;
    }
    // if too any elements
    if (dataset.getKeys().size() > plotArea.getWidth()) {
        String text = ""Too many elements"";
        Font sfont = new Font(""dialog"", Font.BOLD, 10);
        g2.setFont(sfont);
        FontMetrics fm = g2.getFontMetrics(sfont);
        int stringWidth = fm.stringWidth(text);
        g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() - stringWidth) / 2), (int) (plotArea.getY() + (plotArea.getHeight() / 2)));
        return;
    }
    // if we are drawing a perfect circle, we need to readjust the top left
    // coordinates of the drawing area for the arcs to arrive at this
    // effect.
    if (isCircular()) {
        double min = Math.min(plotArea.getWidth(), plotArea.getHeight()) / 2;
        plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, plotArea.getCenterY() - min, 2 * min, 2 * min);
    }
    // get a list of keys...
    List sectionKeys = dataset.getKeys();
    if (sectionKeys.size() == 0) {
        return;
    }
    // establish the coordinates of the top left corner of the drawing area
    double arcX = pieArea.getX();
    double arcY = pieArea.getY();
    //g2.clip(clipArea);
    Composite originalComposite = g2.getComposite();
    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getForegroundAlpha()));
    double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset);
    double runningTotal = 0;
    if (depth < 0) {
        // if depth is negative don't draw anything
        return;
    }
    ArrayList arcList = new ArrayList();
    Arc2D.Double arc;
    Paint paint;
    Paint outlinePaint;
    Stroke outlineStroke;
    Iterator iterator = sectionKeys.iterator();
    while (iterator.hasNext()) {
        Comparable currentKey = (Comparable) iterator.next();
        Number dataValue = dataset.getValue(currentKey);
        if (dataValue == null) {
            arcList.add(null);
            continue;
        }
        double value = dataValue.doubleValue();
        if (value <= 0) {
            arcList.add(null);
            continue;
        }
        double startAngle = getStartAngle();
        double direction = getDirection().getFactor();
        double angle1 = startAngle + (direction * (runningTotal * 360)) / totalValue;
        double angle2 = startAngle + (direction * (runningTotal + value) * 360) / totalValue;
        if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) {
            arcList.add(new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), pieArea.getHeight() - depth, angle1, angle2 - angle1, Arc2D.PIE));
        } else {
            arcList.add(null);
        }
        runningTotal += value;
    }
    Shape oldClip = g2.getClip();
    Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), pieArea.getWidth(), pieArea.getHeight() - depth);
    Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() + depth, pieArea.getWidth(), pieArea.getHeight() - depth);
    Rectangle2D lower = new Rectangle2D.Double(top.getX(), top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() - top.getCenterY());
    Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), pieArea.getWidth(), bottom.getCenterY() - top.getY());
    Area a = new Area(top);
    a.add(new Area(lower));
    Area b = new Area(bottom);
    b.add(new Area(upper));
    Area pie = new Area(a);
    pie.intersect(b);
    Area front = new Area(pie);
    front.subtract(new Area(top));
    Area back = new Area(pie);
    back.subtract(new Area(bottom));
    // draw the bottom circle
    int[] xs;
    int[] ys;
    arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), pieArea.getHeight() - depth, 0, 360, Arc2D.PIE);
    int categoryCount = arcList.size();
    for (int categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
        arc = (Arc2D.Double) arcList.get(categoryIndex);
        if (arc == null) {
            continue;
        }
        Comparable key = getSectionKey(categoryIndex);
        paint = lookupSectionPaint(key, true);
        outlinePaint = lookupSectionOutlinePaint(key);
        outlineStroke = lookupSectionOutlineStroke(key);
        g2.setPaint(paint);
        g2.fill(arc);
        g2.setPaint(outlinePaint);
        g2.setStroke(outlineStroke);
        g2.draw(arc);
        g2.setPaint(paint);
        Point2D p1 = arc.getStartPoint();
        // draw the height
        xs = new int[] { (int) arc.getCenterX(), (int) arc.getCenterX(), (int) p1.getX(), (int) p1.getX() };
        ys = new int[] { (int) arc.getCenterY(), (int) arc.getCenterY() - depth, (int) p1.getY() - depth, (int) p1.getY() };
        Polygon polygon = new Polygon(xs, ys, 4);
        g2.setPaint(java.awt.Color.lightGray);
        g2.fill(polygon);
        g2.setPaint(outlinePaint);
        g2.setStroke(outlineStroke);
        g2.draw(polygon);
        g2.setPaint(paint);
    }
    g2.setPaint(Color.gray);
    g2.fill(back);
    g2.fill(front);
    // cycle through once drawing only the sides at the back...
    int cat = 0;
    iterator = arcList.iterator();
    while (iterator.hasNext()) {
        Arc2D segment = (Arc2D) iterator.next();
        if (segment != null) {
            Comparable key = getSectionKey(cat);
            paint = lookupSectionPaint(key, true);
            outlinePaint = lookupSectionOutlinePaint(key);
            outlineStroke = lookupSectionOutlineStroke(key);
            drawSide(g2, pieArea, segment, front, back, paint, outlinePaint, outlineStroke, false, true);
        }
        cat++;
    }
    // cycle through again drawing only the sides at the front...
    cat = 0;
    iterator = arcList.iterator();
    while (iterator.hasNext()) {
        Arc2D segment = (Arc2D) iterator.next();
        if (segment != null) {
            Comparable key = getSectionKey(cat);
            paint = lookupSectionPaint(key);
            outlinePaint = lookupSectionOutlinePaint(key);
            outlineStroke = lookupSectionOutlineStroke(key);
            drawSide(g2, pieArea, segment, front, back, paint, outlinePaint, outlineStroke, true, false);
        }
        cat++;
    }
    g2.setClip(oldClip);
    // draw the sections at the top of the pie (and set up tooltips)...
    Arc2D upperArc;
    for (int sectionIndex = 0; sectionIndex < categoryCount; sectionIndex++) {
        arc = (Arc2D.Double) arcList.get(sectionIndex);
        if (arc == null) {
            continue;
        }
        upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(), pieArea.getHeight() - depth, arc.getAngleStart(), arc.getAngleExtent(), Arc2D.PIE);
        Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex);
        paint = lookupSectionPaint(currentKey, true);
        outlinePaint = lookupSectionOutlinePaint(currentKey);
        outlineStroke = lookupSectionOutlineStroke(currentKey);
        g2.setPaint(paint);
        g2.fill(upperArc);
        g2.setStroke(outlineStroke);
        g2.setPaint(outlinePaint);
        g2.draw(upperArc);
        // add a tooltip for the section...
        if (info != null) {
            EntityCollection entities = info.getOwner().getEntityCollection();
            if (entities != null) {
                String tip = null;
                PieToolTipGenerator tipster = getToolTipGenerator();
                if (tipster != null) {
                    // @mgs: using the method's return value was missing
                    tip = tipster.generateToolTip(dataset, currentKey);
                }
                String url = null;
                if (getURLGenerator() != null) {
                    url = getURLGenerator().generateURL(dataset, currentKey, getPieIndex());
                }
                PieSectionEntity entity = new PieSectionEntity(upperArc, dataset, getPieIndex(), sectionIndex, currentKey, tip, url);
                entities.add(entity);
            }
        }
        List keys = dataset.getKeys();
        Rectangle2D adjustedPlotArea = new Rectangle2D.Double(originalPlotArea.getX(), originalPlotArea.getY(), originalPlotArea.getWidth(), originalPlotArea.getHeight() - depth);
        if (getSimpleLabels()) {
            drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, state);
        } else {
            drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, state);
        }
    }
    g2.setClip(savedClip);
    g2.setComposite(originalComposite);
    drawOutline(g2, originalPlotArea);
}","public void test017110() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot();
    Point2D point2D0 = combinedDomainXYPlot0.getQuadrantOrigin();
    PlotState plotState0 = new PlotState();
    JFreeChart jFreeChart0 = new JFreeChart(""SerialDate.monthCodeToString: month outside valid range."", piePlot3D0);
    ChartPanel chartPanel0 = new ChartPanel(jFreeChart0);
    ChartRenderingInfo chartRenderingInfo0 = chartPanel0.getChartRenderingInfo();
    PlotRenderingInfo plotRenderingInfo0 = chartRenderingInfo0.getPlotInfo();
    // Undeclared exception!
    try {
        piePlot3D0.draw((Graphics2D) null, (Rectangle2D) null, point2D0, plotState0, plotRenderingInfo0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.jfree.chart.util.RectangleInsets"", e);
    }
}","/**
 * Draws the plot on a Java 2D graphics device (such as the screen or a
 * printer).  This method is called by the
 * {@link org.jfree.chart.JFreeChart} class, you don't normally need
 * to call it yourself.
 *
 * @param g2  the graphics device.
 * @param plotArea  the area within which the plot should be drawn.
 * @param anchor  the anchor point.
 * @param parentState  the state from the parent plot, if there is one.
 * @param info  collects info about the drawing
 *              (<code>null</code> permitted).
 */"
"public Object clone() throws CloneNotSupportedException {
    PiePlot clone = (PiePlot) super.clone();
    if (clone.dataset != null) {
        clone.dataset.addChangeListener(clone);
    }
    if (this.urlGenerator instanceof PublicCloneable) {
        clone.urlGenerator = (PieURLGenerator) ObjectUtilities.clone(this.urlGenerator);
    }
    clone.legendItemShape = ShapeUtilities.clone(this.legendItemShape);
    if (this.legendLabelGenerator != null) {
        clone.legendLabelGenerator = (PieSectionLabelGenerator) ObjectUtilities.clone(this.legendLabelGenerator);
    }
    if (this.legendLabelToolTipGenerator != null) {
        clone.legendLabelToolTipGenerator = (PieSectionLabelGenerator) ObjectUtilities.clone(this.legendLabelToolTipGenerator);
    }
    if (this.legendLabelURLGenerator instanceof PublicCloneable) {
        clone.legendLabelURLGenerator = (PieURLGenerator) ObjectUtilities.clone(this.legendLabelURLGenerator);
    }
    return clone;
}","public void test018111() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    ringPlot0.setDrawingSupplier((DrawingSupplier) null);
    // Undeclared exception!
    try {
        ringPlot0.clone();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'object' argument.
        //
        verifyException(""org.jfree.chart.util.ObjectUtilities"", e);
    }
}","/**
 * Returns a clone of the plot.
 *
 * @return A clone.
 *
 * @throws CloneNotSupportedException if some component of the plot does
 *         not support cloning.
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test019112() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(4.0, piePlot1.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test019113() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(90.0, piePlot1.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test019114() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(1.0E-5, piePlot1.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test019115() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.025, piePlot1.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test019116() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.025, piePlot1.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test019117() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.14, piePlot1.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test019118() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertTrue(piePlot1.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test019119() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(4.0, piePlot1.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test019120() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.08, piePlot1.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test019121() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertTrue(piePlot1.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test019122() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0, piePlot1.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof PiePlot)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    PiePlot that = (PiePlot) obj;
    if (this.pieIndex != that.pieIndex) {
        return false;
    }
    if (this.interiorGap != that.interiorGap) {
        return false;
    }
    if (this.circular != that.circular) {
        return false;
    }
    if (this.startAngle != that.startAngle) {
        return false;
    }
    if (this.direction != that.direction) {
        return false;
    }
    if (this.ignoreZeroValues != that.ignoreZeroValues) {
        return false;
    }
    if (this.ignoreNullValues != that.ignoreNullValues) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionPaintMap, that.sectionPaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionPaint, that.baseSectionPaint)) {
        return false;
    }
    if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, that.sectionOutlinePaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionOutlinePaint, that.baseSectionOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, that.sectionOutlineStrokeMap)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.baseSectionOutlineStroke, that.baseSectionOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {
        return false;
    }
    if (!(this.shadowXOffset == that.shadowXOffset)) {
        return false;
    }
    if (!(this.shadowYOffset == that.shadowYOffset)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.explodePercentages, that.explodePercentages)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelGenerator, that.labelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelBackgroundPaint, that.labelBackgroundPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelOutlinePaint, that.labelOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelOutlineStroke, that.labelOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelShadowPaint, that.labelShadowPaint)) {
        return false;
    }
    if (this.simpleLabels != that.simpleLabels) {
        return false;
    }
    if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {
        return false;
    }
    if (!this.labelPadding.equals(that.labelPadding)) {
        return false;
    }
    if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {
        return false;
    }
    if (!(this.labelGap == that.labelGap)) {
        return false;
    }
    if (!(this.labelLinkMargin == that.labelLinkMargin)) {
        return false;
    }
    if (this.labelLinksVisible != that.labelLinksVisible) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelLinkStroke, that.labelLinkStroke)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.toolTipGenerator, that.toolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {
        return false;
    }
    if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {
        return false;
    }
    if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelGenerator, that.legendLabelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator, that.legendLabelToolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelURLGenerator, that.legendLabelURLGenerator)) {
        return false;
    }
    // can't find any difference...
    return true;
}","public void test019123() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertTrue(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is NOT included in the test for equality.
 *
 * @param obj  the object to test against (<code>null</code> permitted).
 *
 * @return <code>true</code> or <code>false</code>.
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test020124() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test020125() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test020126() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof PiePlot)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    PiePlot that = (PiePlot) obj;
    if (this.pieIndex != that.pieIndex) {
        return false;
    }
    if (this.interiorGap != that.interiorGap) {
        return false;
    }
    if (this.circular != that.circular) {
        return false;
    }
    if (this.startAngle != that.startAngle) {
        return false;
    }
    if (this.direction != that.direction) {
        return false;
    }
    if (this.ignoreZeroValues != that.ignoreZeroValues) {
        return false;
    }
    if (this.ignoreNullValues != that.ignoreNullValues) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionPaintMap, that.sectionPaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionPaint, that.baseSectionPaint)) {
        return false;
    }
    if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, that.sectionOutlinePaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionOutlinePaint, that.baseSectionOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, that.sectionOutlineStrokeMap)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.baseSectionOutlineStroke, that.baseSectionOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {
        return false;
    }
    if (!(this.shadowXOffset == that.shadowXOffset)) {
        return false;
    }
    if (!(this.shadowYOffset == that.shadowYOffset)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.explodePercentages, that.explodePercentages)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelGenerator, that.labelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelBackgroundPaint, that.labelBackgroundPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelOutlinePaint, that.labelOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelOutlineStroke, that.labelOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelShadowPaint, that.labelShadowPaint)) {
        return false;
    }
    if (this.simpleLabels != that.simpleLabels) {
        return false;
    }
    if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {
        return false;
    }
    if (!this.labelPadding.equals(that.labelPadding)) {
        return false;
    }
    if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {
        return false;
    }
    if (!(this.labelGap == that.labelGap)) {
        return false;
    }
    if (!(this.labelLinkMargin == that.labelLinkMargin)) {
        return false;
    }
    if (this.labelLinksVisible != that.labelLinksVisible) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelLinkStroke, that.labelLinkStroke)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.toolTipGenerator, that.toolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {
        return false;
    }
    if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {
        return false;
    }
    if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelGenerator, that.legendLabelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator, that.legendLabelToolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelURLGenerator, that.legendLabelURLGenerator)) {
        return false;
    }
    // can't find any difference...
    return true;
}","public void test020127() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is NOT included in the test for equality.
 *
 * @param obj  the object to test against (<code>null</code> permitted).
 *
 * @return <code>true</code> or <code>false</code>.
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test020128() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test020129() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test020130() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test020131() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test020132() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test020133() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test020134() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test020135() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    boolean boolean0 = piePlot0.equals(""Fp"");
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test021136() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test021137() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof PiePlot)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    PiePlot that = (PiePlot) obj;
    if (this.pieIndex != that.pieIndex) {
        return false;
    }
    if (this.interiorGap != that.interiorGap) {
        return false;
    }
    if (this.circular != that.circular) {
        return false;
    }
    if (this.startAngle != that.startAngle) {
        return false;
    }
    if (this.direction != that.direction) {
        return false;
    }
    if (this.ignoreZeroValues != that.ignoreZeroValues) {
        return false;
    }
    if (this.ignoreNullValues != that.ignoreNullValues) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionPaintMap, that.sectionPaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionPaint, that.baseSectionPaint)) {
        return false;
    }
    if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, that.sectionOutlinePaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionOutlinePaint, that.baseSectionOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, that.sectionOutlineStrokeMap)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.baseSectionOutlineStroke, that.baseSectionOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {
        return false;
    }
    if (!(this.shadowXOffset == that.shadowXOffset)) {
        return false;
    }
    if (!(this.shadowYOffset == that.shadowYOffset)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.explodePercentages, that.explodePercentages)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelGenerator, that.labelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelBackgroundPaint, that.labelBackgroundPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelOutlinePaint, that.labelOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelOutlineStroke, that.labelOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelShadowPaint, that.labelShadowPaint)) {
        return false;
    }
    if (this.simpleLabels != that.simpleLabels) {
        return false;
    }
    if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {
        return false;
    }
    if (!this.labelPadding.equals(that.labelPadding)) {
        return false;
    }
    if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {
        return false;
    }
    if (!(this.labelGap == that.labelGap)) {
        return false;
    }
    if (!(this.labelLinkMargin == that.labelLinkMargin)) {
        return false;
    }
    if (this.labelLinksVisible != that.labelLinksVisible) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelLinkStroke, that.labelLinkStroke)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.toolTipGenerator, that.toolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {
        return false;
    }
    if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {
        return false;
    }
    if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelGenerator, that.legendLabelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator, that.legendLabelToolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelURLGenerator, that.legendLabelURLGenerator)) {
        return false;
    }
    // can't find any difference...
    return true;
}","public void test021138() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertTrue(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is NOT included in the test for equality.
 *
 * @param obj  the object to test against (<code>null</code> permitted).
 *
 * @return <code>true</code> or <code>false</code>.
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test021139() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test021140() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test021141() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test021142() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test021143() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test021144() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test021145() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test021146() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test021147() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    boolean boolean0 = piePlot0.equals(piePlot0);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test022148() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getLegendItems();
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test022149() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getLegendItems();
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test022150() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getLegendItems();
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test022151() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getLegendItems();
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test022152() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getLegendItems();
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test022153() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getLegendItems();
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test022154() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getLegendItems();
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test022155() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getLegendItems();
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public int getPieIndex() {
    return this.pieIndex;
}","public void test022156() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getLegendItems();
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test022157() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getLegendItems();
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test022158() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getLegendItems();
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test023159() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setCircular(true, true);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test023160() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setCircular(true, true);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test023161() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setCircular(true, true);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test023162() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setCircular(true, true);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test023163() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setCircular(true, true);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test023164() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setCircular(true, true);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test023165() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setCircular(true, true);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test023166() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setCircular(true, true);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test023167() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setCircular(true, true);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test023168() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setCircular(true, true);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test023169() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setCircular(true, true);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test024170() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    double double0 = piePlot0.getInteriorGap();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test024171() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    double double0 = piePlot0.getInteriorGap();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test024172() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    double double0 = piePlot0.getInteriorGap();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test024173() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    double double0 = piePlot0.getInteriorGap();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test024174() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    double double0 = piePlot0.getInteriorGap();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test024175() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    double double0 = piePlot0.getInteriorGap();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test024176() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    double double0 = piePlot0.getInteriorGap();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public int getPieIndex() {
    return this.pieIndex;
}","public void test024177() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    double double0 = piePlot0.getInteriorGap();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test024178() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    double double0 = piePlot0.getInteriorGap();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test024179() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    double double0 = piePlot0.getInteriorGap();
    assertEquals(0.08, double0, 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test024180() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    double double0 = piePlot0.getInteriorGap();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test025181() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    double double0 = piePlot0.getMaximumLabelWidth();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test025182() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    double double0 = piePlot0.getMaximumLabelWidth();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test025183() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    double double0 = piePlot0.getMaximumLabelWidth();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test025184() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    double double0 = piePlot0.getMaximumLabelWidth();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test025185() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    double double0 = piePlot0.getMaximumLabelWidth();
    assertEquals(0.14, double0, 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test025186() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    double double0 = piePlot0.getMaximumLabelWidth();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test025187() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    double double0 = piePlot0.getMaximumLabelWidth();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test025188() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    double double0 = piePlot0.getMaximumLabelWidth();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test025189() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    double double0 = piePlot0.getMaximumLabelWidth();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test025190() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    double double0 = piePlot0.getMaximumLabelWidth();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test025191() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    double double0 = piePlot0.getMaximumLabelWidth();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test026192() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.isCircular();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test026193() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.isCircular();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test026194() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.isCircular();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test026195() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.isCircular();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test026196() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.isCircular();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test026197() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.isCircular();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test026198() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.isCircular();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test026199() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.isCircular();
    assertTrue(boolean0);
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test026200() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.isCircular();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test026201() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.isCircular();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test026202() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.isCircular();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test027203() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getLabelGap();
    assertEquals(0.025, double0, 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test027204() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getLabelGap();
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test027205() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getLabelGap();
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test027206() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getLabelGap();
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test027207() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getLabelGap();
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test027208() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getLabelGap();
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test027209() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getLabelGap();
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test027210() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getLabelGap();
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test027211() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getLabelGap();
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test027212() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getLabelGap();
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test027213() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getLabelGap();
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea, PiePlot plot, Integer index, PlotRenderingInfo info) {
    PiePlotState state = new PiePlotState(info);
    state.setPassesRequired(2);
    state.setTotal(DatasetUtilities.calculatePieDatasetTotal(plot.getDataset()));
    state.setLatestAngle(plot.getStartAngle());
    return state;
}","public void test028214() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double[][] doubleArray0 = new double[4][5];
    DefaultIntervalCategoryDataset defaultIntervalCategoryDataset0 = new DefaultIntervalCategoryDataset(doubleArray0, doubleArray0);
    MultiplePiePlot multiplePiePlot0 = new MultiplePiePlot(defaultIntervalCategoryDataset0);
    JFreeChart jFreeChart0 = multiplePiePlot0.getPieChart();
    BufferedImage bufferedImage0 = jFreeChart0.createBufferedImage(128, 10, 10, (ChartRenderingInfo) null);
    Graphics2D graphics2D0 = bufferedImage0.createGraphics();
    // Undeclared exception!
    try {
        piePlot3D0.initialise(graphics2D0, (Rectangle2D) null, piePlot3D0, (Integer) 10, (PlotRenderingInfo) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'dataset' argument.
        //
        verifyException(""org.jfree.data.general.DatasetUtilities"", e);
    }
}","/**
 * Initialises the drawing procedure.  This method will be called before
 * the first item is rendered, giving the plot an opportunity to initialise
 * any state information it wants to maintain.
 *
 * @param g2  the graphics device.
 * @param plotArea  the plot area (<code>null</code> not permitted).
 * @param plot  the plot.
 * @param index  the secondary index (<code>null</code> for primary
 *               renderer).
 * @param info  collects chart rendering information for return to caller.
 *
 * @return A state object (maintains state information relevant to one
 *         chart drawing).
 */"
"public Object clone() throws CloneNotSupportedException {
    PiePlot clone = (PiePlot) super.clone();
    if (clone.dataset != null) {
        clone.dataset.addChangeListener(clone);
    }
    if (this.urlGenerator instanceof PublicCloneable) {
        clone.urlGenerator = (PieURLGenerator) ObjectUtilities.clone(this.urlGenerator);
    }
    clone.legendItemShape = ShapeUtilities.clone(this.legendItemShape);
    if (this.legendLabelGenerator != null) {
        clone.legendLabelGenerator = (PieSectionLabelGenerator) ObjectUtilities.clone(this.legendLabelGenerator);
    }
    if (this.legendLabelToolTipGenerator != null) {
        clone.legendLabelToolTipGenerator = (PieSectionLabelGenerator) ObjectUtilities.clone(this.legendLabelToolTipGenerator);
    }
    if (this.legendLabelURLGenerator instanceof PublicCloneable) {
        clone.legendLabelURLGenerator = (PieURLGenerator) ObjectUtilities.clone(this.legendLabelURLGenerator);
    }
    return clone;
}","public void test029215() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertNotSame(ringPlot1, ringPlot0);
}","/**
 * Returns a clone of the plot.
 *
 * @return A clone.
 *
 * @throws CloneNotSupportedException if some component of the plot does
 *         not support cloning.
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test029216() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertEquals(0.08, ringPlot1.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof RingPlot)) {
        return false;
    }
    RingPlot that = (RingPlot) obj;
    if (this.separatorsVisible != that.separatorsVisible) {
        return false;
    }
    if (!ObjectUtilities.equal(this.separatorStroke, that.separatorStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.separatorPaint, that.separatorPaint)) {
        return false;
    }
    if (this.innerSeparatorExtension != that.innerSeparatorExtension) {
        return false;
    }
    if (this.outerSeparatorExtension != that.outerSeparatorExtension) {
        return false;
    }
    if (this.sectionDepth != that.sectionDepth) {
        return false;
    }
    return super.equals(obj);
}","public void test029217() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertTrue(ringPlot1.equals((Object) ringPlot0));
}","/**
 * Tests this plot for equality with an arbitrary object.
 *
 * @param obj  the object to test against (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test029218() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertEquals(4.0, ringPlot1.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test029219() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertEquals(1.0E-5, ringPlot1.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test029220() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertEquals(0.025, ringPlot1.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test029221() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertTrue(ringPlot1.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test029222() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertEquals(0.025, ringPlot1.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test029223() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertEquals(0, ringPlot1.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test029224() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertEquals(0.14, ringPlot1.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test029225() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertEquals(90.0, ringPlot1.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test029226() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertEquals(4.0, ringPlot1.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test029227() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    RingPlot ringPlot1 = (RingPlot) ringPlot0.clone();
    assertTrue(ringPlot1.getSectionOutlinesVisible());
}",""
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test030228() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertEquals(1.0E-5, piePlot3D1.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test030229() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertEquals(0.025, piePlot3D1.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test030230() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertEquals(4.0, piePlot3D1.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test030231() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertEquals(90.0, piePlot3D1.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test030232() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertEquals(0.025, piePlot3D1.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test030233() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertEquals(0, piePlot3D1.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test030234() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertEquals(0.08, piePlot3D1.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public Object clone() throws CloneNotSupportedException {
    PiePlot clone = (PiePlot) super.clone();
    if (clone.dataset != null) {
        clone.dataset.addChangeListener(clone);
    }
    if (this.urlGenerator instanceof PublicCloneable) {
        clone.urlGenerator = (PieURLGenerator) ObjectUtilities.clone(this.urlGenerator);
    }
    clone.legendItemShape = ShapeUtilities.clone(this.legendItemShape);
    if (this.legendLabelGenerator != null) {
        clone.legendLabelGenerator = (PieSectionLabelGenerator) ObjectUtilities.clone(this.legendLabelGenerator);
    }
    if (this.legendLabelToolTipGenerator != null) {
        clone.legendLabelToolTipGenerator = (PieSectionLabelGenerator) ObjectUtilities.clone(this.legendLabelToolTipGenerator);
    }
    if (this.legendLabelURLGenerator instanceof PublicCloneable) {
        clone.legendLabelURLGenerator = (PieURLGenerator) ObjectUtilities.clone(this.legendLabelURLGenerator);
    }
    return clone;
}","public void test030235() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertNotSame(piePlot3D1, piePlot3D0);
}","/**
 * Returns a clone of the plot.
 *
 * @return A clone.
 *
 * @throws CloneNotSupportedException if some component of the plot does
 *         not support cloning.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof PiePlot3D)) {
        return false;
    }
    PiePlot3D that = (PiePlot3D) obj;
    if (this.depthFactor != that.depthFactor) {
        return false;
    }
    if (this.darkerSides != that.darkerSides) {
        return false;
    }
    return super.equals(obj);
}","public void test030236() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertTrue(piePlot3D1.equals((Object) piePlot3D0));
}","/**
 * Tests this plot for equality with an arbitrary object.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test030237() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertEquals(4.0, piePlot3D1.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test030238() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertTrue(piePlot3D1.getSectionOutlinesVisible());
}",""
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test030239() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertEquals(0.14, piePlot3D1.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test030240() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = (PiePlot3D) piePlot3D0.clone();
    assertFalse(piePlot3D1.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof PiePlot3D)) {
        return false;
    }
    PiePlot3D that = (PiePlot3D) obj;
    if (this.depthFactor != that.depthFactor) {
        return false;
    }
    if (this.darkerSides != that.darkerSides) {
        return false;
    }
    return super.equals(obj);
}","public void test031241() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = new PiePlot3D();
    assertTrue(piePlot3D1.equals((Object) piePlot3D0));
}","/**
 * Tests this plot for equality with an arbitrary object.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof PiePlot3D)) {
        return false;
    }
    PiePlot3D that = (PiePlot3D) obj;
    if (this.depthFactor != that.depthFactor) {
        return false;
    }
    if (this.darkerSides != that.darkerSides) {
        return false;
    }
    return super.equals(obj);
}","public void test031242() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PiePlot3D piePlot3D1 = new PiePlot3D();
    piePlot3D0.setLabelPadding(piePlot3D1.DEFAULT_INSETS);
    boolean boolean0 = piePlot3D1.equals(piePlot3D0);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.
 *
 * @param obj  the object (<code>null</code> permitted).
 *
 * @return A boolean.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof PiePlot)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    PiePlot that = (PiePlot) obj;
    if (this.pieIndex != that.pieIndex) {
        return false;
    }
    if (this.interiorGap != that.interiorGap) {
        return false;
    }
    if (this.circular != that.circular) {
        return false;
    }
    if (this.startAngle != that.startAngle) {
        return false;
    }
    if (this.direction != that.direction) {
        return false;
    }
    if (this.ignoreZeroValues != that.ignoreZeroValues) {
        return false;
    }
    if (this.ignoreNullValues != that.ignoreNullValues) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionPaintMap, that.sectionPaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionPaint, that.baseSectionPaint)) {
        return false;
    }
    if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, that.sectionOutlinePaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionOutlinePaint, that.baseSectionOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, that.sectionOutlineStrokeMap)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.baseSectionOutlineStroke, that.baseSectionOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {
        return false;
    }
    if (!(this.shadowXOffset == that.shadowXOffset)) {
        return false;
    }
    if (!(this.shadowYOffset == that.shadowYOffset)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.explodePercentages, that.explodePercentages)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelGenerator, that.labelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelBackgroundPaint, that.labelBackgroundPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelOutlinePaint, that.labelOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelOutlineStroke, that.labelOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelShadowPaint, that.labelShadowPaint)) {
        return false;
    }
    if (this.simpleLabels != that.simpleLabels) {
        return false;
    }
    if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {
        return false;
    }
    if (!this.labelPadding.equals(that.labelPadding)) {
        return false;
    }
    if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {
        return false;
    }
    if (!(this.labelGap == that.labelGap)) {
        return false;
    }
    if (!(this.labelLinkMargin == that.labelLinkMargin)) {
        return false;
    }
    if (this.labelLinksVisible != that.labelLinksVisible) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelLinkStroke, that.labelLinkStroke)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.toolTipGenerator, that.toolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {
        return false;
    }
    if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {
        return false;
    }
    if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelGenerator, that.legendLabelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator, that.legendLabelToolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelURLGenerator, that.legendLabelURLGenerator)) {
        return false;
    }
    // can't find any difference...
    return true;
}","public void test032243() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    assertTrue(piePlot1.equals((Object) piePlot0));
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is NOT included in the test for equality.
 *
 * @param obj  the object to test against (<code>null</code> permitted).
 *
 * @return <code>true</code> or <code>false</code>.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof PiePlot)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    PiePlot that = (PiePlot) obj;
    if (this.pieIndex != that.pieIndex) {
        return false;
    }
    if (this.interiorGap != that.interiorGap) {
        return false;
    }
    if (this.circular != that.circular) {
        return false;
    }
    if (this.startAngle != that.startAngle) {
        return false;
    }
    if (this.direction != that.direction) {
        return false;
    }
    if (this.ignoreZeroValues != that.ignoreZeroValues) {
        return false;
    }
    if (this.ignoreNullValues != that.ignoreNullValues) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionPaintMap, that.sectionPaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionPaint, that.baseSectionPaint)) {
        return false;
    }
    if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, that.sectionOutlinePaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionOutlinePaint, that.baseSectionOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, that.sectionOutlineStrokeMap)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.baseSectionOutlineStroke, that.baseSectionOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {
        return false;
    }
    if (!(this.shadowXOffset == that.shadowXOffset)) {
        return false;
    }
    if (!(this.shadowYOffset == that.shadowYOffset)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.explodePercentages, that.explodePercentages)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelGenerator, that.labelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelBackgroundPaint, that.labelBackgroundPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelOutlinePaint, that.labelOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelOutlineStroke, that.labelOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelShadowPaint, that.labelShadowPaint)) {
        return false;
    }
    if (this.simpleLabels != that.simpleLabels) {
        return false;
    }
    if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {
        return false;
    }
    if (!this.labelPadding.equals(that.labelPadding)) {
        return false;
    }
    if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {
        return false;
    }
    if (!(this.labelGap == that.labelGap)) {
        return false;
    }
    if (!(this.labelLinkMargin == that.labelLinkMargin)) {
        return false;
    }
    if (this.labelLinksVisible != that.labelLinksVisible) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelLinkStroke, that.labelLinkStroke)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.toolTipGenerator, that.toolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {
        return false;
    }
    if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {
        return false;
    }
    if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelGenerator, that.legendLabelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator, that.legendLabelToolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelURLGenerator, that.legendLabelURLGenerator)) {
        return false;
    }
    // can't find any difference...
    return true;
}","public void test032244() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot1.setSectionOutlineStroke(10, piePlot0.DEFAULT_OUTLINE_STROKE);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is NOT included in the test for equality.
 *
 * @param obj  the object to test against (<code>null</code> permitted).
 *
 * @return <code>true</code> or <code>false</code>.
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof PiePlot)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    PiePlot that = (PiePlot) obj;
    if (this.pieIndex != that.pieIndex) {
        return false;
    }
    if (this.interiorGap != that.interiorGap) {
        return false;
    }
    if (this.circular != that.circular) {
        return false;
    }
    if (this.startAngle != that.startAngle) {
        return false;
    }
    if (this.direction != that.direction) {
        return false;
    }
    if (this.ignoreZeroValues != that.ignoreZeroValues) {
        return false;
    }
    if (this.ignoreNullValues != that.ignoreNullValues) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionPaintMap, that.sectionPaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionPaint, that.baseSectionPaint)) {
        return false;
    }
    if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, that.sectionOutlinePaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionOutlinePaint, that.baseSectionOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, that.sectionOutlineStrokeMap)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.baseSectionOutlineStroke, that.baseSectionOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {
        return false;
    }
    if (!(this.shadowXOffset == that.shadowXOffset)) {
        return false;
    }
    if (!(this.shadowYOffset == that.shadowYOffset)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.explodePercentages, that.explodePercentages)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelGenerator, that.labelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelBackgroundPaint, that.labelBackgroundPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelOutlinePaint, that.labelOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelOutlineStroke, that.labelOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelShadowPaint, that.labelShadowPaint)) {
        return false;
    }
    if (this.simpleLabels != that.simpleLabels) {
        return false;
    }
    if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {
        return false;
    }
    if (!this.labelPadding.equals(that.labelPadding)) {
        return false;
    }
    if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {
        return false;
    }
    if (!(this.labelGap == that.labelGap)) {
        return false;
    }
    if (!(this.labelLinkMargin == that.labelLinkMargin)) {
        return false;
    }
    if (this.labelLinksVisible != that.labelLinksVisible) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelLinkStroke, that.labelLinkStroke)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.toolTipGenerator, that.toolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {
        return false;
    }
    if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {
        return false;
    }
    if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelGenerator, that.legendLabelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator, that.legendLabelToolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelURLGenerator, that.legendLabelURLGenerator)) {
        return false;
    }
    // can't find any difference...
    return true;
}","public void test033245() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setCircular(false, false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is NOT included in the test for equality.
 *
 * @param obj  the object to test against (<code>null</code> permitted).
 *
 * @return <code>true</code> or <code>false</code>.
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test033246() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setCircular(false, false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertFalse(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test034247() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.14, piePlot1.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test034248() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertTrue(piePlot1.getSectionOutlinesVisible());
}",""
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test034249() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(4.0, piePlot1.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test034250() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(90.0, piePlot1.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test034251() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(1.0E-5, piePlot1.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test034252() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.025, piePlot1.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test034253() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(4.0, piePlot1.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test034254() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.08, piePlot1.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof PiePlot)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    PiePlot that = (PiePlot) obj;
    if (this.pieIndex != that.pieIndex) {
        return false;
    }
    if (this.interiorGap != that.interiorGap) {
        return false;
    }
    if (this.circular != that.circular) {
        return false;
    }
    if (this.startAngle != that.startAngle) {
        return false;
    }
    if (this.direction != that.direction) {
        return false;
    }
    if (this.ignoreZeroValues != that.ignoreZeroValues) {
        return false;
    }
    if (this.ignoreNullValues != that.ignoreNullValues) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionPaintMap, that.sectionPaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionPaint, that.baseSectionPaint)) {
        return false;
    }
    if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, that.sectionOutlinePaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionOutlinePaint, that.baseSectionOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, that.sectionOutlineStrokeMap)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.baseSectionOutlineStroke, that.baseSectionOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {
        return false;
    }
    if (!(this.shadowXOffset == that.shadowXOffset)) {
        return false;
    }
    if (!(this.shadowYOffset == that.shadowYOffset)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.explodePercentages, that.explodePercentages)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelGenerator, that.labelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelBackgroundPaint, that.labelBackgroundPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelOutlinePaint, that.labelOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelOutlineStroke, that.labelOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelShadowPaint, that.labelShadowPaint)) {
        return false;
    }
    if (this.simpleLabels != that.simpleLabels) {
        return false;
    }
    if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {
        return false;
    }
    if (!this.labelPadding.equals(that.labelPadding)) {
        return false;
    }
    if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {
        return false;
    }
    if (!(this.labelGap == that.labelGap)) {
        return false;
    }
    if (!(this.labelLinkMargin == that.labelLinkMargin)) {
        return false;
    }
    if (this.labelLinksVisible != that.labelLinksVisible) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelLinkStroke, that.labelLinkStroke)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.toolTipGenerator, that.toolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {
        return false;
    }
    if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {
        return false;
    }
    if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelGenerator, that.legendLabelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator, that.legendLabelToolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelURLGenerator, that.legendLabelURLGenerator)) {
        return false;
    }
    // can't find any difference...
    return true;
}","public void test034255() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is NOT included in the test for equality.
 *
 * @param obj  the object to test against (<code>null</code> permitted).
 *
 * @return <code>true</code> or <code>false</code>.
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test034256() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0, piePlot1.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test034257() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertTrue(piePlot1.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test034258() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setBackgroundImageAlignment(100);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.025, piePlot1.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test035259() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test035260() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test035261() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test035262() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test035263() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test035264() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test035265() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test035266() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test035267() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getStartAngle() {
    return this.startAngle;
}","public void test035268() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test035269() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"protected Rectangle2D getArcBounds(Rectangle2D unexploded, Rectangle2D exploded, double angle, double extent, double explodePercent) {
    if (explodePercent == 0.0) {
        return unexploded;
    } else {
        Arc2D arc1 = new Arc2D.Double(unexploded, angle, extent / 2, Arc2D.OPEN);
        Point2D point1 = arc1.getEndPoint();
        Arc2D.Double arc2 = new Arc2D.Double(exploded, angle, extent / 2, Arc2D.OPEN);
        Point2D point2 = arc2.getEndPoint();
        double deltaX = (point1.getX() - point2.getX()) * explodePercent;
        double deltaY = (point1.getY() - point2.getY()) * explodePercent;
        return new Rectangle2D.Double(unexploded.getX() - deltaX, unexploded.getY() - deltaY, unexploded.getWidth(), unexploded.getHeight());
    }
}","public void test035270() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle2D rectangle2D0 = piePlot0.getArcBounds(rectangle2D_Double0, rectangle2D_Double0, 0.0, (-920.87242462), 0.0);
    assertSame(rectangle2D0, rectangle2D_Double0);
}","/**
 * Returns a rectangle that can be used to create a pie section (taking
 * into account the amount by which the pie section is 'exploded').
 *
 * @param unexploded  the area inside which the unexploded pie sections are
 *                    drawn.
 * @param exploded  the area inside which the exploded pie sections are
 *                  drawn.
 * @param angle  the start angle.
 * @param extent  the extent of the arc.
 * @param explodePercent  the amount by which the pie section is exploded.
 *
 * @return A rectangle that can be used to create a pie section.
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test036271() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLegendItems();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test036272() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLegendItems();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test036273() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLegendItems();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test036274() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLegendItems();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test036275() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLegendItems();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public int getPieIndex() {
    return this.pieIndex;
}","public void test036276() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLegendItems();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test036277() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLegendItems();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test036278() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLegendItems();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test036279() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLegendItems();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test036280() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLegendItems();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test036281() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLegendItems();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"protected void drawPie(Graphics2D g2, Rectangle2D plotArea, PlotRenderingInfo info) {
    PiePlotState state = initialise(g2, plotArea, this, null, info);
    // adjust the plot area for interior spacing and labels...
    double labelReserve = 0.0;
    if (this.labelGenerator != null && !this.simpleLabels) {
        labelReserve = this.labelGap + this.maximumLabelWidth;
    }
    double gapHorizontal = plotArea.getWidth() * (this.interiorGap + labelReserve) * 2.0;
    double gapVertical = plotArea.getHeight() * this.interiorGap * 2.0;
    if (DEBUG_DRAW_INTERIOR) {
        double hGap = plotArea.getWidth() * this.interiorGap;
        double vGap = plotArea.getHeight() * this.interiorGap;
        double igx1 = plotArea.getX() + hGap;
        double igx2 = plotArea.getMaxX() - hGap;
        double igy1 = plotArea.getY() + vGap;
        double igy2 = plotArea.getMaxY() - vGap;
        g2.setPaint(Color.gray);
        g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, igy2 - igy1));
    }
    double linkX = plotArea.getX() + gapHorizontal / 2;
    double linkY = plotArea.getY() + gapVertical / 2;
    double linkW = plotArea.getWidth() - gapHorizontal;
    double linkH = plotArea.getHeight() - gapVertical;
    // make the link area a square if the pie chart is to be circular...
    if (this.circular) {
        double min = Math.min(linkW, linkH) / 2;
        linkX = (linkX + linkX + linkW) / 2 - min;
        linkY = (linkY + linkY + linkH) / 2 - min;
        linkW = 2 * min;
        linkH = 2 * min;
    }
    // the link area defines the dog leg points for the linking lines to
    // the labels
    Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, linkH);
    state.setLinkArea(linkArea);
    if (DEBUG_DRAW_LINK_AREA) {
        g2.setPaint(Color.blue);
        g2.draw(linkArea);
        g2.setPaint(Color.yellow);
        g2.draw(new Ellipse2D.Double(linkArea.getX(), linkArea.getY(), linkArea.getWidth(), linkArea.getHeight()));
    }
    // the explode area defines the max circle/ellipse for the exploded
    // pie sections.  it is defined by shrinking the linkArea by the
    // linkMargin factor.
    double lm = 0.0;
    if (!this.simpleLabels) {
        lm = this.labelLinkMargin;
    }
    double hh = linkArea.getWidth() * lm * 2.0;
    double vv = linkArea.getHeight() * lm * 2.0;
    Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, linkY + vv / 2.0, linkW - hh, linkH - vv);
    state.setExplodedPieArea(explodeArea);
    // the pie area defines the circle/ellipse for regular pie sections.
    // it is defined by shrinking the explodeArea by the explodeMargin
    // factor.
    double maximumExplodePercent = getMaximumExplodePercent();
    double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);
    double h1 = explodeArea.getWidth() * percent;
    double v1 = explodeArea.getHeight() * percent;
    Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() + h1 / 2.0, explodeArea.getY() + v1 / 2.0, explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);
    if (DEBUG_DRAW_PIE_AREA) {
        g2.setPaint(Color.green);
        g2.draw(pieArea);
    }
    state.setPieArea(pieArea);
    state.setPieCenterX(pieArea.getCenterX());
    state.setPieCenterY(pieArea.getCenterY());
    state.setPieWRadius(pieArea.getWidth() / 2.0);
    state.setPieHRadius(pieArea.getHeight() / 2.0);
    // plot the data (unless the dataset is null)...
    if ((this.dataset != null) && (this.dataset.getKeys().size() > 0)) {
        List keys = this.dataset.getKeys();
        double totalValue = DatasetUtilities.calculatePieDatasetTotal(this.dataset);
        int passesRequired = state.getPassesRequired();
        for (int pass = 0; pass < passesRequired; pass++) {
            double runningTotal = 0.0;
            for (int section = 0; section < keys.size(); section++) {
                Number n = this.dataset.getValue(section);
                if (n != null) {
                    double value = n.doubleValue();
                    if (value > 0.0) {
                        runningTotal += value;
                        drawItem(g2, section, explodeArea, state, pass);
                    }
                }
            }
        }
        if (this.simpleLabels) {
            drawSimpleLabels(g2, keys, totalValue, plotArea, linkArea, state);
        } else {
            drawLabels(g2, keys, totalValue, plotArea, linkArea, state);
        }
    } else {
        drawNoDataMessage(g2, plotArea);
    }
}","public void test037282() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    JFreeChart jFreeChart0 = new JFreeChart(ringPlot0);
    ChartRenderingInfo chartRenderingInfo0 = new ChartRenderingInfo();
    BufferedImage bufferedImage0 = jFreeChart0.createBufferedImage(36, 10, 10, chartRenderingInfo0);
    Graphics2D graphics2D0 = bufferedImage0.createGraphics();
    // Undeclared exception!
    try {
        ringPlot0.drawPie(graphics2D0, (Rectangle2D) null, (PlotRenderingInfo) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'dataset' argument.
        //
        verifyException(""org.jfree.data.general.DatasetUtilities"", e);
    }
}","/**
 * Draws the pie.
 *
 * @param g2  the graphics device.
 * @param plotArea  the plot area.
 * @param info  chart rendering info.
 */"
"public void setLegendLabelGenerator(PieSectionLabelGenerator generator) {
    if (generator == null) {
        throw new IllegalArgumentException(""Null 'generator' argument."");
    }
    this.legendLabelGenerator = generator;
    notifyListeners(new PlotChangeEvent(this));
}","public void test038283() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    // Undeclared exception!
    try {
        piePlot0.setLegendLabelGenerator((PieSectionLabelGenerator) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'generator' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the legend label generator and sends a {@link PlotChangeEvent} to
 * all registered listeners.
 *
 * @param generator  the generator (<code>null</code> not permitted).
 *
 * @see #getLegendLabelGenerator()
 */"
"public void setLegendItemShape(Shape shape) {
    if (shape == null) {
        throw new IllegalArgumentException(""Null 'shape' argument."");
    }
    this.legendItemShape = shape;
    notifyListeners(new PlotChangeEvent(this));
}","public void test039284() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    // Undeclared exception!
    try {
        ringPlot0.setLegendItemShape((Shape) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'shape' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the shape used for legend items and sends a {@link PlotChangeEvent}
 * to all registered listeners.
 *
 * @param shape  the shape (<code>null</code> not permitted).
 *
 * @see #getLegendItemShape()
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test040285() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle rectangle0 = rectangle2D_Double0.getBounds();
    piePlot0.setLegendItemShape(rectangle0);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test040286() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle rectangle0 = rectangle2D_Double0.getBounds();
    piePlot0.setLegendItemShape(rectangle0);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test040287() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle rectangle0 = rectangle2D_Double0.getBounds();
    piePlot0.setLegendItemShape(rectangle0);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test040288() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle rectangle0 = rectangle2D_Double0.getBounds();
    piePlot0.setLegendItemShape(rectangle0);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test040289() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle rectangle0 = rectangle2D_Double0.getBounds();
    piePlot0.setLegendItemShape(rectangle0);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test040290() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle rectangle0 = rectangle2D_Double0.getBounds();
    piePlot0.setLegendItemShape(rectangle0);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test040291() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle rectangle0 = rectangle2D_Double0.getBounds();
    piePlot0.setLegendItemShape(rectangle0);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test040292() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle rectangle0 = rectangle2D_Double0.getBounds();
    piePlot0.setLegendItemShape(rectangle0);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test040293() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle rectangle0 = rectangle2D_Double0.getBounds();
    piePlot0.setLegendItemShape(rectangle0);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test040294() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle rectangle0 = rectangle2D_Double0.getBounds();
    piePlot0.setLegendItemShape(rectangle0);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test040295() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Rectangle2D.Double rectangle2D_Double0 = new Rectangle2D.Double();
    Rectangle rectangle0 = rectangle2D_Double0.getBounds();
    piePlot0.setLegendItemShape(rectangle0);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public void setLabelDistributor(AbstractPieLabelDistributor distributor) {
    if (distributor == null) {
        throw new IllegalArgumentException(""Null 'distributor' argument."");
    }
    this.labelDistributor = distributor;
    notifyListeners(new PlotChangeEvent(this));
}","public void test041296() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    // Undeclared exception!
    try {
        piePlot0.setLabelDistributor((AbstractPieLabelDistributor) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'distributor' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the label distributor and sends a {@link PlotChangeEvent} to all
 * registered listeners.
 *
 * @param distributor  the distributor (<code>null</code> not permitted).
 *
 * @since 1.0.6
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test042297() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    AbstractPieLabelDistributor abstractPieLabelDistributor0 = ringPlot0.getLabelDistributor();
    ringPlot0.setLabelDistributor(abstractPieLabelDistributor0);
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test042298() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    AbstractPieLabelDistributor abstractPieLabelDistributor0 = ringPlot0.getLabelDistributor();
    ringPlot0.setLabelDistributor(abstractPieLabelDistributor0);
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test042299() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    AbstractPieLabelDistributor abstractPieLabelDistributor0 = ringPlot0.getLabelDistributor();
    ringPlot0.setLabelDistributor(abstractPieLabelDistributor0);
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test042300() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    AbstractPieLabelDistributor abstractPieLabelDistributor0 = ringPlot0.getLabelDistributor();
    ringPlot0.setLabelDistributor(abstractPieLabelDistributor0);
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test042301() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    AbstractPieLabelDistributor abstractPieLabelDistributor0 = ringPlot0.getLabelDistributor();
    ringPlot0.setLabelDistributor(abstractPieLabelDistributor0);
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test042302() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    AbstractPieLabelDistributor abstractPieLabelDistributor0 = ringPlot0.getLabelDistributor();
    ringPlot0.setLabelDistributor(abstractPieLabelDistributor0);
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test042303() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    AbstractPieLabelDistributor abstractPieLabelDistributor0 = ringPlot0.getLabelDistributor();
    ringPlot0.setLabelDistributor(abstractPieLabelDistributor0);
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test042304() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    AbstractPieLabelDistributor abstractPieLabelDistributor0 = ringPlot0.getLabelDistributor();
    ringPlot0.setLabelDistributor(abstractPieLabelDistributor0);
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test042305() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    AbstractPieLabelDistributor abstractPieLabelDistributor0 = ringPlot0.getLabelDistributor();
    ringPlot0.setLabelDistributor(abstractPieLabelDistributor0);
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test042306() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    AbstractPieLabelDistributor abstractPieLabelDistributor0 = ringPlot0.getLabelDistributor();
    ringPlot0.setLabelDistributor(abstractPieLabelDistributor0);
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test042307() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    AbstractPieLabelDistributor abstractPieLabelDistributor0 = ringPlot0.getLabelDistributor();
    ringPlot0.setLabelDistributor(abstractPieLabelDistributor0);
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public void setSimpleLabelOffset(RectangleInsets offset) {
    if (offset == null) {
        throw new IllegalArgumentException(""Null 'offset' argument."");
    }
    this.simpleLabelOffset = offset;
    notifyListeners(new PlotChangeEvent(this));
}","public void test043308() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    // Undeclared exception!
    try {
        ringPlot0.setSimpleLabelOffset((RectangleInsets) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'offset' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the offset for the simple labels and sends a
 * {@link PlotChangeEvent} to all registered listeners.
 *
 * @param offset  the offset (<code>null</code> not permitted).
 *
 * @since 1.0.7
 *
 * @see #getSimpleLabelOffset()
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test044309() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSimpleLabelOffset(piePlot0.DEFAULT_INSETS);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test044310() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSimpleLabelOffset(piePlot0.DEFAULT_INSETS);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test044311() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSimpleLabelOffset(piePlot0.DEFAULT_INSETS);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test044312() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSimpleLabelOffset(piePlot0.DEFAULT_INSETS);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test044313() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSimpleLabelOffset(piePlot0.DEFAULT_INSETS);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test044314() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSimpleLabelOffset(piePlot0.DEFAULT_INSETS);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test044315() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSimpleLabelOffset(piePlot0.DEFAULT_INSETS);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test044316() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSimpleLabelOffset(piePlot0.DEFAULT_INSETS);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test044317() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSimpleLabelOffset(piePlot0.DEFAULT_INSETS);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test044318() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSimpleLabelOffset(piePlot0.DEFAULT_INSETS);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test044319() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSimpleLabelOffset(piePlot0.DEFAULT_INSETS);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public void setLabelPaint(Paint paint) {
    if (paint == null) {
        throw new IllegalArgumentException(""Null 'paint' argument."");
    }
    this.labelPaint = paint;
    notifyListeners(new PlotChangeEvent(this));
}","public void test045320() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    // Undeclared exception!
    try {
        piePlot0.setLabelPaint((Paint) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'paint' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the section label paint and sends a {@link PlotChangeEvent} to all
 * registered listeners.
 *
 * @param paint  the paint (<code>null</code> not permitted).
 *
 * @see #getLabelPaint()
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test046321() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    Object[][] objectArray0 = new Object[6][7];
    DefaultTableModel defaultTableModel0 = new DefaultTableModel(objectArray0, objectArray0[1]);
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable(defaultTableModel0, defaultTableColumnModel0);
    Color color0 = jTable0.getGridColor();
    ringPlot0.setLabelPaint(color0);
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test046322() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    Object[][] objectArray0 = new Object[6][7];
    DefaultTableModel defaultTableModel0 = new DefaultTableModel(objectArray0, objectArray0[1]);
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable(defaultTableModel0, defaultTableColumnModel0);
    Color color0 = jTable0.getGridColor();
    ringPlot0.setLabelPaint(color0);
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test046323() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    Object[][] objectArray0 = new Object[6][7];
    DefaultTableModel defaultTableModel0 = new DefaultTableModel(objectArray0, objectArray0[1]);
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable(defaultTableModel0, defaultTableColumnModel0);
    Color color0 = jTable0.getGridColor();
    ringPlot0.setLabelPaint(color0);
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test046324() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    Object[][] objectArray0 = new Object[6][7];
    DefaultTableModel defaultTableModel0 = new DefaultTableModel(objectArray0, objectArray0[1]);
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable(defaultTableModel0, defaultTableColumnModel0);
    Color color0 = jTable0.getGridColor();
    ringPlot0.setLabelPaint(color0);
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test046325() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    Object[][] objectArray0 = new Object[6][7];
    DefaultTableModel defaultTableModel0 = new DefaultTableModel(objectArray0, objectArray0[1]);
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable(defaultTableModel0, defaultTableColumnModel0);
    Color color0 = jTable0.getGridColor();
    ringPlot0.setLabelPaint(color0);
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test046326() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    Object[][] objectArray0 = new Object[6][7];
    DefaultTableModel defaultTableModel0 = new DefaultTableModel(objectArray0, objectArray0[1]);
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable(defaultTableModel0, defaultTableColumnModel0);
    Color color0 = jTable0.getGridColor();
    ringPlot0.setLabelPaint(color0);
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test046327() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    Object[][] objectArray0 = new Object[6][7];
    DefaultTableModel defaultTableModel0 = new DefaultTableModel(objectArray0, objectArray0[1]);
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable(defaultTableModel0, defaultTableColumnModel0);
    Color color0 = jTable0.getGridColor();
    ringPlot0.setLabelPaint(color0);
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test046328() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    Object[][] objectArray0 = new Object[6][7];
    DefaultTableModel defaultTableModel0 = new DefaultTableModel(objectArray0, objectArray0[1]);
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable(defaultTableModel0, defaultTableColumnModel0);
    Color color0 = jTable0.getGridColor();
    ringPlot0.setLabelPaint(color0);
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test046329() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    Object[][] objectArray0 = new Object[6][7];
    DefaultTableModel defaultTableModel0 = new DefaultTableModel(objectArray0, objectArray0[1]);
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable(defaultTableModel0, defaultTableColumnModel0);
    Color color0 = jTable0.getGridColor();
    ringPlot0.setLabelPaint(color0);
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test046330() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    Object[][] objectArray0 = new Object[6][7];
    DefaultTableModel defaultTableModel0 = new DefaultTableModel(objectArray0, objectArray0[1]);
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable(defaultTableModel0, defaultTableColumnModel0);
    Color color0 = jTable0.getGridColor();
    ringPlot0.setLabelPaint(color0);
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test046331() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    Object[][] objectArray0 = new Object[6][7];
    DefaultTableModel defaultTableModel0 = new DefaultTableModel(objectArray0, objectArray0[1]);
    DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel();
    JTable jTable0 = new JTable(defaultTableModel0, defaultTableColumnModel0);
    Color color0 = jTable0.getGridColor();
    ringPlot0.setLabelPaint(color0);
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public void setLabelFont(Font font) {
    if (font == null) {
        throw new IllegalArgumentException(""Null 'font' argument."");
    }
    this.labelFont = font;
    notifyListeners(new PlotChangeEvent(this));
}","public void test047332() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    // Undeclared exception!
    try {
        ringPlot0.setLabelFont((Font) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'font' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the section label font and sends a {@link PlotChangeEvent} to all
 * registered listeners.
 *
 * @param font  the font (<code>null</code> not permitted).
 *
 * @see #getLabelFont()
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test048333() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    CandlestickRenderer candlestickRenderer0 = new CandlestickRenderer();
    ringPlot0.setLabelFont(candlestickRenderer0.DEFAULT_VALUE_LABEL_FONT);
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test048334() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    CandlestickRenderer candlestickRenderer0 = new CandlestickRenderer();
    ringPlot0.setLabelFont(candlestickRenderer0.DEFAULT_VALUE_LABEL_FONT);
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test048335() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    CandlestickRenderer candlestickRenderer0 = new CandlestickRenderer();
    ringPlot0.setLabelFont(candlestickRenderer0.DEFAULT_VALUE_LABEL_FONT);
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test048336() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    CandlestickRenderer candlestickRenderer0 = new CandlestickRenderer();
    ringPlot0.setLabelFont(candlestickRenderer0.DEFAULT_VALUE_LABEL_FONT);
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test048337() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    CandlestickRenderer candlestickRenderer0 = new CandlestickRenderer();
    ringPlot0.setLabelFont(candlestickRenderer0.DEFAULT_VALUE_LABEL_FONT);
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test048338() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    CandlestickRenderer candlestickRenderer0 = new CandlestickRenderer();
    ringPlot0.setLabelFont(candlestickRenderer0.DEFAULT_VALUE_LABEL_FONT);
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test048339() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    CandlestickRenderer candlestickRenderer0 = new CandlestickRenderer();
    ringPlot0.setLabelFont(candlestickRenderer0.DEFAULT_VALUE_LABEL_FONT);
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test048340() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    CandlestickRenderer candlestickRenderer0 = new CandlestickRenderer();
    ringPlot0.setLabelFont(candlestickRenderer0.DEFAULT_VALUE_LABEL_FONT);
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test048341() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    CandlestickRenderer candlestickRenderer0 = new CandlestickRenderer();
    ringPlot0.setLabelFont(candlestickRenderer0.DEFAULT_VALUE_LABEL_FONT);
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test048342() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    CandlestickRenderer candlestickRenderer0 = new CandlestickRenderer();
    ringPlot0.setLabelFont(candlestickRenderer0.DEFAULT_VALUE_LABEL_FONT);
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test048343() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    CandlestickRenderer candlestickRenderer0 = new CandlestickRenderer();
    ringPlot0.setLabelFont(candlestickRenderer0.DEFAULT_VALUE_LABEL_FONT);
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public void setLabelLinkStroke(Stroke stroke) {
    if (stroke == null) {
        throw new IllegalArgumentException(""Null 'stroke' argument."");
    }
    this.labelLinkStroke = stroke;
    notifyListeners(new PlotChangeEvent(this));
}","public void test049344() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultPieDataset0);
    // Undeclared exception!
    try {
        piePlot3D0.setLabelLinkStroke((Stroke) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'stroke' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the link stroke and sends a {@link PlotChangeEvent} to all
 * registered listeners.
 *
 * @param stroke  the stroke.
 *
 * @see #getLabelLinkStroke()
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test050345() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    SpiderWebPlot spiderWebPlot0 = new SpiderWebPlot();
    Stroke stroke0 = spiderWebPlot0.getSeriesOutlineStroke(10);
    piePlot0.setLabelLinkStroke(stroke0);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test050346() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    SpiderWebPlot spiderWebPlot0 = new SpiderWebPlot();
    Stroke stroke0 = spiderWebPlot0.getSeriesOutlineStroke(10);
    piePlot0.setLabelLinkStroke(stroke0);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test050347() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    SpiderWebPlot spiderWebPlot0 = new SpiderWebPlot();
    Stroke stroke0 = spiderWebPlot0.getSeriesOutlineStroke(10);
    piePlot0.setLabelLinkStroke(stroke0);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test050348() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    SpiderWebPlot spiderWebPlot0 = new SpiderWebPlot();
    Stroke stroke0 = spiderWebPlot0.getSeriesOutlineStroke(10);
    piePlot0.setLabelLinkStroke(stroke0);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test050349() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    SpiderWebPlot spiderWebPlot0 = new SpiderWebPlot();
    Stroke stroke0 = spiderWebPlot0.getSeriesOutlineStroke(10);
    piePlot0.setLabelLinkStroke(stroke0);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test050350() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    SpiderWebPlot spiderWebPlot0 = new SpiderWebPlot();
    Stroke stroke0 = spiderWebPlot0.getSeriesOutlineStroke(10);
    piePlot0.setLabelLinkStroke(stroke0);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test050351() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    SpiderWebPlot spiderWebPlot0 = new SpiderWebPlot();
    Stroke stroke0 = spiderWebPlot0.getSeriesOutlineStroke(10);
    piePlot0.setLabelLinkStroke(stroke0);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test050352() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    SpiderWebPlot spiderWebPlot0 = new SpiderWebPlot();
    Stroke stroke0 = spiderWebPlot0.getSeriesOutlineStroke(10);
    piePlot0.setLabelLinkStroke(stroke0);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test050353() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    SpiderWebPlot spiderWebPlot0 = new SpiderWebPlot();
    Stroke stroke0 = spiderWebPlot0.getSeriesOutlineStroke(10);
    piePlot0.setLabelLinkStroke(stroke0);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test050354() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    SpiderWebPlot spiderWebPlot0 = new SpiderWebPlot();
    Stroke stroke0 = spiderWebPlot0.getSeriesOutlineStroke(10);
    piePlot0.setLabelLinkStroke(stroke0);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test050355() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    SpiderWebPlot spiderWebPlot0 = new SpiderWebPlot();
    Stroke stroke0 = spiderWebPlot0.getSeriesOutlineStroke(10);
    piePlot0.setLabelLinkStroke(stroke0);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public void setLabelLinkPaint(Paint paint) {
    if (paint == null) {
        throw new IllegalArgumentException(""Null 'paint' argument."");
    }
    this.labelLinkPaint = paint;
    notifyListeners(new PlotChangeEvent(this));
}","public void test051356() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    // Undeclared exception!
    try {
        ringPlot0.setLabelLinkPaint((Paint) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'paint' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the paint used for the lines that connect pie sections to their
 * corresponding labels, and sends a {@link PlotChangeEvent} to all
 * registered listeners.
 *
 * @param paint  the paint (<code>null</code> not permitted).
 *
 * @see #getLabelLinkPaint()
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test052357() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinkPaint(piePlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test052358() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinkPaint(piePlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test052359() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinkPaint(piePlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test052360() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinkPaint(piePlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test052361() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinkPaint(piePlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test052362() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinkPaint(piePlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test052363() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinkPaint(piePlot0.DEFAULT_OUTLINE_PAINT);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test052364() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinkPaint(piePlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test052365() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinkPaint(piePlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test052366() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinkPaint(piePlot0.DEFAULT_OUTLINE_PAINT);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test052367() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinkPaint(piePlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test053368() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test053369() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test053370() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test053371() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test053372() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test053373() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test053374() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMaximumExplodePercent() {
    double result = 0.0;
    Iterator iterator = this.dataset.getKeys().iterator();
    while (iterator.hasNext()) {
        Comparable key = (Comparable) iterator.next();
        Number explode = (Number) this.explodePercentages.get(key);
        if (explode != null) {
            result = Math.max(result, explode.doubleValue());
        }
    }
    return result;
}","public void test053375() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the maximum explode percent.
 *
 * @return The percent.
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test053376() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public boolean isCircular() {
    return this.circular;
}","public void test053377() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test053378() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test053379() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    Instant instant0 = MockInstant.ofEpochSecond((-1430L), (long) 0);
    Date date0 = Date.from(instant0);
    Year year0 = new Year(date0);
    TextBox textBox0 = new TextBox("""");
    PieLabelRecord pieLabelRecord0 = new PieLabelRecord(year0, 0, 0, textBox0, (-1430L), 0.0, 0);
    defaultPieDataset0.insertValue(0, (Comparable) pieLabelRecord0, 0.0);
    PiePlot piePlot0 = new PiePlot(defaultPieDataset0);
    double double0 = piePlot0.getMaximumExplodePercent();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public void setExplodePercent(Comparable key, double percent) {
    if (key == null) {
        throw new IllegalArgumentException(""Null 'key' argument."");
    }
    if (this.explodePercentages == null) {
        this.explodePercentages = new TreeMap();
    }
    this.explodePercentages.put(key, new Double(percent));
    notifyListeners(new PlotChangeEvent(this));
}","public void test054380() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    // Undeclared exception!
    try {
        piePlot0.setExplodePercent((Comparable) null, 10);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'key' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the amount that a pie section should be exploded and sends a
 * {@link PlotChangeEvent} to all registered listeners.
 *
 * @param key  the section key (<code>null</code> not permitted).
 * @param percent  the explode percentage (0.30 = 30 percent).
 *
 * @since 1.0.3
 *
 * @see #getExplodePercent(Comparable)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test055381() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setExplodePercent(1.0F, 10);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test055382() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setExplodePercent(1.0F, 10);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test055383() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setExplodePercent(1.0F, 10);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test055384() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setExplodePercent(1.0F, 10);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test055385() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setExplodePercent(1.0F, 10);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test055386() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setExplodePercent(1.0F, 10);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test055387() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setExplodePercent(1.0F, 10);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test055388() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setExplodePercent(1.0F, 10);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test055389() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setExplodePercent(1.0F, 10);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test055390() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setExplodePercent(1.0F, 10);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test055391() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setExplodePercent(1.0F, 10);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test056392() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test056393() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test056394() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test056395() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test056396() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test056397() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test056398() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test056399() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test056400() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getExplodePercent(Comparable key) {
    double result = 0.0;
    if (this.explodePercentages != null) {
        Number percent = (Number) this.explodePercentages.get(key);
        if (percent != null) {
            result = percent.doubleValue();
        }
    }
    return result;
}","public void test056401() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the amount that the section with the specified key should be
 * exploded.
 *
 * @param key  the key (<code>null</code> not permitted).
 *
 * @return The amount that the section with the specified key should be
 *     exploded.
 *
 * @throws IllegalArgumentException if <code>key</code> is
 *     <code>null</code>.
 *
 * @since 1.0.3
 *
 * @see #setExplodePercent(Comparable, double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test056402() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test056403() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond(2294L);
    double double0 = ringPlot0.getExplodePercent(fixedMillisecond0);
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getExplodePercent(Comparable key) {
    double result = 0.0;
    if (this.explodePercentages != null) {
        Number percent = (Number) this.explodePercentages.get(key);
        if (percent != null) {
            result = percent.doubleValue();
        }
    }
    return result;
}","public void test057404() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultPieDataset0);
    // Undeclared exception!
    try {
        piePlot3D0.getExplodePercent((Comparable) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.TreeMap"", e);
    }
}","/**
 * Returns the amount that the section with the specified key should be
 * exploded.
 *
 * @param key  the key (<code>null</code> not permitted).
 *
 * @return The amount that the section with the specified key should be
 *     exploded.
 *
 * @throws IllegalArgumentException if <code>key</code> is
 *     <code>null</code>.
 *
 * @since 1.0.3
 *
 * @see #setExplodePercent(Comparable, double)
 */"
"public void setBaseSectionOutlineStroke(Stroke stroke) {
    if (stroke == null) {
        throw new IllegalArgumentException(""Null 'stroke' argument."");
    }
    this.baseSectionOutlineStroke = stroke;
    notifyListeners(new PlotChangeEvent(this));
}","public void test058405() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    // Undeclared exception!
    try {
        piePlot0.setBaseSectionOutlineStroke((Stroke) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'stroke' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the base section stroke.
 *
 * @param stroke  the stroke (<code>null</code> not permitted).
 *
 * @see #getBaseSectionOutlineStroke()
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test059406() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    BasicStroke basicStroke0 = (BasicStroke) PeriodAxisLabelInfo.DEFAULT_DIVIDER_STROKE;
    ringPlot0.setBaseSectionOutlineStroke(basicStroke0);
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test059407() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    BasicStroke basicStroke0 = (BasicStroke) PeriodAxisLabelInfo.DEFAULT_DIVIDER_STROKE;
    ringPlot0.setBaseSectionOutlineStroke(basicStroke0);
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test059408() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    BasicStroke basicStroke0 = (BasicStroke) PeriodAxisLabelInfo.DEFAULT_DIVIDER_STROKE;
    ringPlot0.setBaseSectionOutlineStroke(basicStroke0);
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test059409() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    BasicStroke basicStroke0 = (BasicStroke) PeriodAxisLabelInfo.DEFAULT_DIVIDER_STROKE;
    ringPlot0.setBaseSectionOutlineStroke(basicStroke0);
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test059410() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    BasicStroke basicStroke0 = (BasicStroke) PeriodAxisLabelInfo.DEFAULT_DIVIDER_STROKE;
    ringPlot0.setBaseSectionOutlineStroke(basicStroke0);
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test059411() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    BasicStroke basicStroke0 = (BasicStroke) PeriodAxisLabelInfo.DEFAULT_DIVIDER_STROKE;
    ringPlot0.setBaseSectionOutlineStroke(basicStroke0);
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test059412() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    BasicStroke basicStroke0 = (BasicStroke) PeriodAxisLabelInfo.DEFAULT_DIVIDER_STROKE;
    ringPlot0.setBaseSectionOutlineStroke(basicStroke0);
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test059413() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    BasicStroke basicStroke0 = (BasicStroke) PeriodAxisLabelInfo.DEFAULT_DIVIDER_STROKE;
    ringPlot0.setBaseSectionOutlineStroke(basicStroke0);
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test059414() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    BasicStroke basicStroke0 = (BasicStroke) PeriodAxisLabelInfo.DEFAULT_DIVIDER_STROKE;
    ringPlot0.setBaseSectionOutlineStroke(basicStroke0);
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test059415() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    BasicStroke basicStroke0 = (BasicStroke) PeriodAxisLabelInfo.DEFAULT_DIVIDER_STROKE;
    ringPlot0.setBaseSectionOutlineStroke(basicStroke0);
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test059416() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    BasicStroke basicStroke0 = (BasicStroke) PeriodAxisLabelInfo.DEFAULT_DIVIDER_STROKE;
    ringPlot0.setBaseSectionOutlineStroke(basicStroke0);
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test060417() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test060418() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test060419() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test060420() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test060421() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"protected Stroke lookupSectionOutlineStroke(Comparable key, boolean autoPopulate) {
    Stroke result = null;
    // is a stroke defined for the specified key
    result = this.sectionOutlineStrokeMap.getStroke(key);
    if (result != null) {
        return result;
    }
    // nothing defined - do we autoPopulate?
    if (autoPopulate) {
        DrawingSupplier ds = getDrawingSupplier();
        if (ds != null) {
            result = ds.getNextOutlineStroke();
            this.sectionOutlineStrokeMap.put(key, result);
        } else {
            result = this.baseSectionOutlineStroke;
        }
    } else {
        result = this.baseSectionOutlineStroke;
    }
    return result;
}","public void test060422() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertNotNull(basicStroke0);
}","/**
 * Returns the outline stroke for the specified section.  The lookup
 * involves these steps:
 * <ul>
 * <li>if {@link #getSectionOutlineStroke(Comparable)} is
 *         non-<code>null</code> return it;</li>
 * <li>if {@link #getSectionOutlineStroke(Comparable)} is
 *         <code>null</code> but <code>autoPopulate</code> is
 *         <code>true</code>, attempt to fetch a new outline stroke from
 *         the drawing supplier ({@link #getDrawingSupplier()});
 * <li>if all else fails, return {@link #getBaseSectionOutlineStroke()}.
 * </ul>
 *
 * @param key  the section key.
 * @param autoPopulate  a flag that controls whether the drawing supplier
 *     is used to auto-populate the section outline stroke settings.
 *
 * @return The stroke.
 *
 * @since 1.0.3
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test060423() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test060424() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test060425() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test060426() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test060428() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test060429() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    LogAxis logAxis0 = new LogAxis(""Mx'wM@\""J <w,&aBP"");
    NumberTickUnit numberTickUnit0 = logAxis0.getTickUnit();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.lookupSectionOutlineStroke(numberTickUnit0, true);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public void setBaseSectionOutlinePaint(Paint paint) {
    if (paint == null) {
        throw new IllegalArgumentException(""Null 'paint' argument."");
    }
    this.baseSectionOutlinePaint = paint;
    notifyListeners(new PlotChangeEvent(this));
}","public void test061430() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    // Undeclared exception!
    try {
        ringPlot0.setBaseSectionOutlinePaint((Paint) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'paint' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the base section paint.
 *
 * @param paint  the paint (<code>null</code> not permitted).
 *
 * @see #getBaseSectionOutlinePaint()
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test062431() throws Throwable {
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot();
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setBaseSectionOutlinePaint(combinedRangeCategoryPlot0.DEFAULT_OUTLINE_PAINT);
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test062432() throws Throwable {
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot();
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setBaseSectionOutlinePaint(combinedRangeCategoryPlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test062433() throws Throwable {
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot();
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setBaseSectionOutlinePaint(combinedRangeCategoryPlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test062434() throws Throwable {
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot();
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setBaseSectionOutlinePaint(combinedRangeCategoryPlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test062435() throws Throwable {
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot();
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setBaseSectionOutlinePaint(combinedRangeCategoryPlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test062436() throws Throwable {
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot();
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setBaseSectionOutlinePaint(combinedRangeCategoryPlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test062437() throws Throwable {
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot();
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setBaseSectionOutlinePaint(combinedRangeCategoryPlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test062438() throws Throwable {
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot();
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setBaseSectionOutlinePaint(combinedRangeCategoryPlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test062439() throws Throwable {
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot();
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setBaseSectionOutlinePaint(combinedRangeCategoryPlot0.DEFAULT_OUTLINE_PAINT);
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getStartAngle() {
    return this.startAngle;
}","public void test062440() throws Throwable {
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot();
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setBaseSectionOutlinePaint(combinedRangeCategoryPlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test062441() throws Throwable {
    CombinedRangeCategoryPlot combinedRangeCategoryPlot0 = new CombinedRangeCategoryPlot();
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setBaseSectionOutlinePaint(combinedRangeCategoryPlot0.DEFAULT_OUTLINE_PAINT);
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"protected Paint lookupSectionOutlinePaint(Comparable key, boolean autoPopulate) {
    Paint result = null;
    // is a paint defined for the specified key
    result = this.sectionOutlinePaintMap.getPaint(key);
    if (result != null) {
        return result;
    }
    // nothing defined - do we autoPopulate?
    if (autoPopulate) {
        DrawingSupplier ds = getDrawingSupplier();
        if (ds != null) {
            result = ds.getNextOutlinePaint();
            this.sectionOutlinePaintMap.put(key, result);
        } else {
            result = this.baseSectionOutlinePaint;
        }
    } else {
        result = this.baseSectionOutlinePaint;
    }
    return result;
}","public void test063442() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertNotNull(color0);
}","/**
 * Returns the outline paint for the specified section.  The lookup
 * involves these steps:
 * <ul>
 * <li>if {@link #getSectionOutlinePaint(Comparable)} is
 *         non-<code>null</code> return it;</li>
 * <li>if {@link #getSectionOutlinePaint(Comparable)} is
 *         <code>null</code> but <code>autoPopulate</code> is
 *         <code>true</code>, attempt to fetch a new outline paint from
 *         the drawing supplier ({@link #getDrawingSupplier()});
 * <li>if all else fails, return {@link #getBaseSectionOutlinePaint()}.
 * </ul>
 *
 * @param key  the section key.
 * @param autoPopulate  a flag that controls whether the drawing supplier
 *     is used to auto-populate the section outline paint settings.
 *
 * @return The paint.
 *
 * @since 1.0.3
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test063443() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test063445() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test063446() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test063447() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test063448() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test063449() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test063450() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test063451() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test063452() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test063453() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test063454() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint(""Mx'wM@\""J <w,&aBP"", true);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public void setBaseSectionPaint(Paint paint) {
    if (paint == null) {
        throw new IllegalArgumentException(""Null 'paint' argument."");
    }
    this.baseSectionPaint = paint;
    notifyListeners(new PlotChangeEvent(this));
}","public void test064455() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    RingPlot ringPlot0 = new RingPlot(defaultPieDataset0);
    // Undeclared exception!
    try {
        ringPlot0.setBaseSectionPaint((Paint) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'paint' argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the base section paint and sends a {@link PlotChangeEvent} to all
 * registered listeners.
 *
 * @param paint  the paint (<code>null</code> not permitted).
 *
 * @see #getBaseSectionPaint()
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test065456() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    LogAxis logAxis0 = new LogAxis();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot(logAxis0);
    piePlot3D0.setBaseSectionPaint(combinedDomainXYPlot0.DEFAULT_BACKGROUND_PAINT);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test065457() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    LogAxis logAxis0 = new LogAxis();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot(logAxis0);
    piePlot3D0.setBaseSectionPaint(combinedDomainXYPlot0.DEFAULT_BACKGROUND_PAINT);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test065458() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    LogAxis logAxis0 = new LogAxis();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot(logAxis0);
    piePlot3D0.setBaseSectionPaint(combinedDomainXYPlot0.DEFAULT_BACKGROUND_PAINT);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test065459() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    LogAxis logAxis0 = new LogAxis();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot(logAxis0);
    piePlot3D0.setBaseSectionPaint(combinedDomainXYPlot0.DEFAULT_BACKGROUND_PAINT);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test065460() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    LogAxis logAxis0 = new LogAxis();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot(logAxis0);
    piePlot3D0.setBaseSectionPaint(combinedDomainXYPlot0.DEFAULT_BACKGROUND_PAINT);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test065461() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    LogAxis logAxis0 = new LogAxis();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot(logAxis0);
    piePlot3D0.setBaseSectionPaint(combinedDomainXYPlot0.DEFAULT_BACKGROUND_PAINT);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test065462() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    LogAxis logAxis0 = new LogAxis();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot(logAxis0);
    piePlot3D0.setBaseSectionPaint(combinedDomainXYPlot0.DEFAULT_BACKGROUND_PAINT);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test065463() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    LogAxis logAxis0 = new LogAxis();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot(logAxis0);
    piePlot3D0.setBaseSectionPaint(combinedDomainXYPlot0.DEFAULT_BACKGROUND_PAINT);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test065464() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    LogAxis logAxis0 = new LogAxis();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot(logAxis0);
    piePlot3D0.setBaseSectionPaint(combinedDomainXYPlot0.DEFAULT_BACKGROUND_PAINT);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test065465() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    LogAxis logAxis0 = new LogAxis();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot(logAxis0);
    piePlot3D0.setBaseSectionPaint(combinedDomainXYPlot0.DEFAULT_BACKGROUND_PAINT);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test065466() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    LogAxis logAxis0 = new LogAxis();
    CombinedDomainXYPlot combinedDomainXYPlot0 = new CombinedDomainXYPlot(logAxis0);
    piePlot3D0.setBaseSectionPaint(combinedDomainXYPlot0.DEFAULT_BACKGROUND_PAINT);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test066467() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test066468() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test066469() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test066470() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"protected Comparable getSectionKey(int section) {
    Comparable key = null;
    if (this.dataset != null) {
        if (section >= 0 && section < this.dataset.getItemCount()) {
            key = this.dataset.getKey(section);
        }
    }
    if (key == null) {
        key = new Integer(section);
    }
    return key;
}","public void test066471() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertEquals((-1117), comparable0);
}","/**
 * Returns a key for the specified section.  If there is no such section
 * in the dataset, we generate a key.  This is to provide some backward
 * compatibility for the (now deprecated) methods that get/set attributes
 * based on section indices.  The preferred way of doing this now is to
 * link the attributes directly to the section key (there are new methods
 * for this, starting from version 1.0.3).
 *
 * @param section  the section index.
 *
 * @return The key.
 *
 * @since 1.0.3
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test066472() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test066473() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test066474() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test066475() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test066476() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test066477() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test066478() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Comparable comparable0 = piePlot0.getSectionKey((-1117));
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"protected Comparable getSectionKey(int section) {
    Comparable key = null;
    if (this.dataset != null) {
        if (section >= 0 && section < this.dataset.getItemCount()) {
            key = this.dataset.getKey(section);
        }
    }
    if (key == null) {
        key = new Integer(section);
    }
    return key;
}","public void test067480() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertNotNull(comparable0);
}","/**
 * Returns a key for the specified section.  If there is no such section
 * in the dataset, we generate a key.  This is to provide some backward
 * compatibility for the (now deprecated) methods that get/set attributes
 * based on section indices.  The preferred way of doing this now is to
 * link the attributes directly to the section key (there are new methods
 * for this, starting from version 1.0.3).
 *
 * @param section  the section index.
 *
 * @return The key.
 *
 * @since 1.0.3
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test067481() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test067482() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test067483() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test067484() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test067486() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test067487() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test067488() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test067489() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getStartAngle() {
    return this.startAngle;
}","public void test067490() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test067491() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test067492() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    Comparable comparable0 = piePlot3D0.getSectionKey(100);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"protected Comparable getSectionKey(int section) {
    Comparable key = null;
    if (this.dataset != null) {
        if (section >= 0 && section < this.dataset.getItemCount()) {
            key = this.dataset.getKey(section);
        }
    }
    if (key == null) {
        key = new Integer(section);
    }
    return key;
}","public void test068493() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertEquals((-1455), comparable0);
}","/**
 * Returns a key for the specified section.  If there is no such section
 * in the dataset, we generate a key.  This is to provide some backward
 * compatibility for the (now deprecated) methods that get/set attributes
 * based on section indices.  The preferred way of doing this now is to
 * link the attributes directly to the section key (there are new methods
 * for this, starting from version 1.0.3).
 *
 * @param section  the section index.
 *
 * @return The key.
 *
 * @since 1.0.3
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test068494() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test068496() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test068497() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test068498() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test068499() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test068500() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test068501() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test068502() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test068503() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test068504() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test068505() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Comparable comparable0 = piePlot0.getSectionKey((-1455));
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test069506() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test069507() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"//// SECTION PAINT ////////////////////////////////////////////////////////
/**
 * Returns the paint for the specified section.  This is equivalent to
 * <code>lookupSectionPaint(section, false)</code>.
 *
 * @param key  the section key.
 *
 * @return The paint for the specified section.
 *
 * @since 1.0.3
 *
 * @see #lookupSectionPaint(Comparable, boolean)
 */
protected Paint lookupSectionPaint(Comparable key) {
    return lookupSectionPaint(key, false);
}","public void test069508() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertSame(color0, paint0);
}",""
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test069510() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test069511() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test069512() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test069513() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test069514() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test069515() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test069516() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test069517() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test069519() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    FixedMillisecond fixedMillisecond0 = new FixedMillisecond();
    Paint paint0 = piePlot3D0.lookupSectionPaint(fixedMillisecond0, true);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(fixedMillisecond0);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test070520() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test070521() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setInteriorGap(0.08);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test070522() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setInteriorGap(0.08);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test070523() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setInteriorGap(0.08);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getStartAngle() {
    return this.startAngle;
}","public void test070524() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setInteriorGap(0.08);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test070525() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setInteriorGap(0.08);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test070526() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setInteriorGap(0.08);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test070527() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setInteriorGap(0.08);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test070528() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setInteriorGap(0.08);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test070529() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setInteriorGap(0.08);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test070530() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setInteriorGap(0.08);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test071531() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setInteriorGap(0.14);
    assertEquals(0.14, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public void setInteriorGap(double percent) {
    if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {
        throw new IllegalArgumentException(""Invalid 'percent' ("" + percent + "") argument."");
    }
    if (this.interiorGap != percent) {
        this.interiorGap = percent;
        notifyListeners(new PlotChangeEvent(this));
    }
}","public void test072532() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    // Undeclared exception!
    try {
        piePlot3D0.setInteriorGap((byte) 10);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid 'percent' (10.0) argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the interior gap and sends a {@link PlotChangeEvent} to all
 * registered listeners.  This controls the space between the edges of the
 * pie plot and the plot area itself (the region where the section labels
 * appear).
 *
 * @param percent  the gap (as a percentage of the available drawing space).
 *
 * @see #getInteriorGap()
 */"
"public void setInteriorGap(double percent) {
    if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {
        throw new IllegalArgumentException(""Invalid 'percent' ("" + percent + "") argument."");
    }
    if (this.interiorGap != percent) {
        this.interiorGap = percent;
        notifyListeners(new PlotChangeEvent(this));
    }
}","public void test073533() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    // Undeclared exception!
    try {
        ringPlot0.setInteriorGap((-381.597372));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid 'percent' (-381.597372) argument.
        //
        verifyException(""org.jfree.chart.plot.PiePlot"", e);
    }
}","/**
 * Sets the interior gap and sends a {@link PlotChangeEvent} to all
 * registered listeners.  This controls the space between the edges of the
 * pie plot and the plot area itself (the region where the section labels
 * appear).
 *
 * @param percent  the gap (as a percentage of the available drawing space).
 *
 * @see #getInteriorGap()
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test074534() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rotation rotation0 = Rotation.CLOCKWISE;
    piePlot0.setDirection(rotation0);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test074535() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rotation rotation0 = Rotation.CLOCKWISE;
    piePlot0.setDirection(rotation0);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test074536() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rotation rotation0 = Rotation.CLOCKWISE;
    piePlot0.setDirection(rotation0);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test074537() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rotation rotation0 = Rotation.CLOCKWISE;
    piePlot0.setDirection(rotation0);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test074538() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rotation rotation0 = Rotation.CLOCKWISE;
    piePlot0.setDirection(rotation0);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test074539() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rotation rotation0 = Rotation.CLOCKWISE;
    piePlot0.setDirection(rotation0);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test074540() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rotation rotation0 = Rotation.CLOCKWISE;
    piePlot0.setDirection(rotation0);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test074541() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rotation rotation0 = Rotation.CLOCKWISE;
    piePlot0.setDirection(rotation0);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test074542() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rotation rotation0 = Rotation.CLOCKWISE;
    piePlot0.setDirection(rotation0);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test074543() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rotation rotation0 = Rotation.CLOCKWISE;
    piePlot0.setDirection(rotation0);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test074544() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Rotation rotation0 = Rotation.CLOCKWISE;
    piePlot0.setDirection(rotation0);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test075545() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setDataset((PieDataset) null);
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test075546() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setDataset((PieDataset) null);
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test075547() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setDataset((PieDataset) null);
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test075548() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setDataset((PieDataset) null);
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test075549() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setDataset((PieDataset) null);
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test075550() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setDataset((PieDataset) null);
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test075551() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setDataset((PieDataset) null);
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test075552() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setDataset((PieDataset) null);
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test075553() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setDataset((PieDataset) null);
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test075554() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setDataset((PieDataset) null);
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test075555() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setDataset((PieDataset) null);
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test076556() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setDataset(defaultKeyedValuesDataset0);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test076557() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setDataset(defaultKeyedValuesDataset0);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test076558() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setDataset(defaultKeyedValuesDataset0);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test076559() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setDataset(defaultKeyedValuesDataset0);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test076560() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setDataset(defaultKeyedValuesDataset0);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test076561() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setDataset(defaultKeyedValuesDataset0);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test076562() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setDataset(defaultKeyedValuesDataset0);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test076563() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setDataset(defaultKeyedValuesDataset0);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test076564() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setDataset(defaultKeyedValuesDataset0);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test076565() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setDataset(defaultKeyedValuesDataset0);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test076566() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setDataset(defaultKeyedValuesDataset0);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test077567() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot3D0.getLabelGenerator();
    piePlot3D0.setLegendLabelToolTipGenerator(pieSectionLabelGenerator0);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test077568() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot3D0.getLabelGenerator();
    piePlot3D0.setLegendLabelToolTipGenerator(pieSectionLabelGenerator0);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test077569() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot3D0.getLabelGenerator();
    piePlot3D0.setLegendLabelToolTipGenerator(pieSectionLabelGenerator0);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test077570() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot3D0.getLabelGenerator();
    piePlot3D0.setLegendLabelToolTipGenerator(pieSectionLabelGenerator0);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test077571() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot3D0.getLabelGenerator();
    piePlot3D0.setLegendLabelToolTipGenerator(pieSectionLabelGenerator0);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test077572() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot3D0.getLabelGenerator();
    piePlot3D0.setLegendLabelToolTipGenerator(pieSectionLabelGenerator0);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test077573() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot3D0.getLabelGenerator();
    piePlot3D0.setLegendLabelToolTipGenerator(pieSectionLabelGenerator0);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public int getPieIndex() {
    return this.pieIndex;
}","public void test077574() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot3D0.getLabelGenerator();
    piePlot3D0.setLegendLabelToolTipGenerator(pieSectionLabelGenerator0);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test077575() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot3D0.getLabelGenerator();
    piePlot3D0.setLegendLabelToolTipGenerator(pieSectionLabelGenerator0);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test077576() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot3D0.getLabelGenerator();
    piePlot3D0.setLegendLabelToolTipGenerator(pieSectionLabelGenerator0);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test077577() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot3D0.getLabelGenerator();
    piePlot3D0.setLegendLabelToolTipGenerator(pieSectionLabelGenerator0);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test078578() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendLabelToolTipGenerator();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test078579() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendLabelToolTipGenerator();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test078580() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendLabelToolTipGenerator();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test078581() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendLabelToolTipGenerator();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test078582() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendLabelToolTipGenerator();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test078583() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendLabelToolTipGenerator();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test078584() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendLabelToolTipGenerator();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test078585() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendLabelToolTipGenerator();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test078586() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendLabelToolTipGenerator();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test078587() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendLabelToolTipGenerator();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test078588() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendLabelToolTipGenerator();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test079589() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getSectionPaint(1.0F);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test079590() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getSectionPaint(1.0F);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test079591() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getSectionPaint(1.0F);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test079592() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getSectionPaint(1.0F);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test079593() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getSectionPaint(1.0F);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test079594() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getSectionPaint(1.0F);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test079595() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getSectionPaint(1.0F);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test079596() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getSectionPaint(1.0F);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test079597() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getSectionPaint(1.0F);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test079598() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getSectionPaint(1.0F);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test079599() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getSectionPaint(1.0F);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test080600() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Color color0 = (Color) piePlot0.getLabelPaint();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test080601() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Color color0 = (Color) piePlot0.getLabelPaint();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test080602() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Color color0 = (Color) piePlot0.getLabelPaint();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test080603() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Color color0 = (Color) piePlot0.getLabelPaint();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test080604() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Color color0 = (Color) piePlot0.getLabelPaint();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test080605() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Color color0 = (Color) piePlot0.getLabelPaint();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test080606() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Color color0 = (Color) piePlot0.getLabelPaint();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test080607() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Color color0 = (Color) piePlot0.getLabelPaint();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test080608() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Color color0 = (Color) piePlot0.getLabelPaint();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test080609() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Color color0 = (Color) piePlot0.getLabelPaint();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test080610() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    Color color0 = (Color) piePlot0.getLabelPaint();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test081612() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelBackgroundPaint();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test081613() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelBackgroundPaint();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test081614() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelBackgroundPaint();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test081615() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelBackgroundPaint();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test081616() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelBackgroundPaint();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test081617() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelBackgroundPaint();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test081618() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelBackgroundPaint();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test081619() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelBackgroundPaint();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test081620() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelBackgroundPaint();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test081621() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelBackgroundPaint();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test081623() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelBackgroundPaint();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test082624() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.getBaseSectionOutlineStroke();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test082625() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.getBaseSectionOutlineStroke();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test082626() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.getBaseSectionOutlineStroke();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test082627() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.getBaseSectionOutlineStroke();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test082628() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.getBaseSectionOutlineStroke();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test082629() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.getBaseSectionOutlineStroke();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test082630() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.getBaseSectionOutlineStroke();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test082631() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.getBaseSectionOutlineStroke();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test082632() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.getBaseSectionOutlineStroke();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test082633() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.getBaseSectionOutlineStroke();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test082634() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.getBaseSectionOutlineStroke();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test083635() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendItemShape();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test083636() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendItemShape();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test083637() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendItemShape();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test083638() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendItemShape();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test083639() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendItemShape();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test083640() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendItemShape();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test083641() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendItemShape();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test083642() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendItemShape();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test083643() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendItemShape();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test083644() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendItemShape();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test083645() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLegendItemShape();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test084646() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.setLabelGap(1663.0);
    assertEquals(1663.0, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test085647() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.getLabelLinkStroke();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test085648() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.getLabelLinkStroke();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test085649() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.getLabelLinkStroke();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test085650() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.getLabelLinkStroke();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test085651() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.getLabelLinkStroke();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test085652() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.getLabelLinkStroke();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test085653() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.getLabelLinkStroke();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test085654() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.getLabelLinkStroke();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test085655() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.getLabelLinkStroke();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test085656() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.getLabelLinkStroke();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test085657() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    BasicStroke basicStroke0 = (BasicStroke) piePlot3D0.getLabelLinkStroke();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test086659() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getStartAngle();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test086660() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getStartAngle();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test086661() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getStartAngle();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test086662() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getStartAngle();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getStartAngle() {
    return this.startAngle;
}","public void test086663() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getStartAngle();
    assertEquals(90.0, double0, 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test086664() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getStartAngle();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test086665() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getStartAngle();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test086666() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getStartAngle();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test086667() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getStartAngle();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test086668() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getStartAngle();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test086669() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getStartAngle();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test087670() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Locale locale0 = Locale.UK;
    StandardPieSectionLabelGenerator standardPieSectionLabelGenerator0 = new StandardPieSectionLabelGenerator(locale0);
    piePlot3D0.setLabelGenerator(standardPieSectionLabelGenerator0);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test087671() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Locale locale0 = Locale.UK;
    StandardPieSectionLabelGenerator standardPieSectionLabelGenerator0 = new StandardPieSectionLabelGenerator(locale0);
    piePlot3D0.setLabelGenerator(standardPieSectionLabelGenerator0);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test087672() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Locale locale0 = Locale.UK;
    StandardPieSectionLabelGenerator standardPieSectionLabelGenerator0 = new StandardPieSectionLabelGenerator(locale0);
    piePlot3D0.setLabelGenerator(standardPieSectionLabelGenerator0);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test087673() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Locale locale0 = Locale.UK;
    StandardPieSectionLabelGenerator standardPieSectionLabelGenerator0 = new StandardPieSectionLabelGenerator(locale0);
    piePlot3D0.setLabelGenerator(standardPieSectionLabelGenerator0);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test087674() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Locale locale0 = Locale.UK;
    StandardPieSectionLabelGenerator standardPieSectionLabelGenerator0 = new StandardPieSectionLabelGenerator(locale0);
    piePlot3D0.setLabelGenerator(standardPieSectionLabelGenerator0);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test087675() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Locale locale0 = Locale.UK;
    StandardPieSectionLabelGenerator standardPieSectionLabelGenerator0 = new StandardPieSectionLabelGenerator(locale0);
    piePlot3D0.setLabelGenerator(standardPieSectionLabelGenerator0);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test087676() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Locale locale0 = Locale.UK;
    StandardPieSectionLabelGenerator standardPieSectionLabelGenerator0 = new StandardPieSectionLabelGenerator(locale0);
    piePlot3D0.setLabelGenerator(standardPieSectionLabelGenerator0);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test087677() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Locale locale0 = Locale.UK;
    StandardPieSectionLabelGenerator standardPieSectionLabelGenerator0 = new StandardPieSectionLabelGenerator(locale0);
    piePlot3D0.setLabelGenerator(standardPieSectionLabelGenerator0);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test087678() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Locale locale0 = Locale.UK;
    StandardPieSectionLabelGenerator standardPieSectionLabelGenerator0 = new StandardPieSectionLabelGenerator(locale0);
    piePlot3D0.setLabelGenerator(standardPieSectionLabelGenerator0);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test087679() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Locale locale0 = Locale.UK;
    StandardPieSectionLabelGenerator standardPieSectionLabelGenerator0 = new StandardPieSectionLabelGenerator(locale0);
    piePlot3D0.setLabelGenerator(standardPieSectionLabelGenerator0);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test087680() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Locale locale0 = Locale.UK;
    StandardPieSectionLabelGenerator standardPieSectionLabelGenerator0 = new StandardPieSectionLabelGenerator(locale0);
    piePlot3D0.setLabelGenerator(standardPieSectionLabelGenerator0);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test088681() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test088682() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    ringPlot0.setMinimumArcAngleToDraw(0.0);
    assertEquals(0.0, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test089683() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test089684() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test089685() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test089686() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE STROKE ///////////////////////////////////////////////
/**
 * Returns the outline stroke for the specified section.  This is equivalent
 * to <code>lookupSectionOutlineStroke(section, false)</code>.
 *
 * @param key  the section key.
 *
 * @return The stroke for the specified section.
 *
 * @since 1.0.3
 *
 * @see #lookupSectionOutlineStroke(Comparable, boolean)
 */
protected Stroke lookupSectionOutlineStroke(Comparable key) {
    return lookupSectionOutlineStroke(key, false);
}","public void test089687() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertNotNull(basicStroke0);
}",""
"public boolean isCircular() {
    return this.circular;
}","public void test089688() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test089689() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test089691() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test089692() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test089693() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test089694() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test089695() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    BasicStroke basicStroke0 = (BasicStroke) piePlot0.lookupSectionOutlineStroke(true);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test090696() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setPieIndex(0);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test090697() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setPieIndex(0);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test090698() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setPieIndex(0);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test090699() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setPieIndex(0);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test090700() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setPieIndex(0);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test090701() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setPieIndex(0);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test090702() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setPieIndex(0);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test090703() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setPieIndex(0);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test090704() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setPieIndex(0);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test090705() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setPieIndex(0);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test090706() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setPieIndex(0);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test091707() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getSimpleLabels();
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test091708() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getSimpleLabels();
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test091709() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getSimpleLabels();
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test091710() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getSimpleLabels();
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test091711() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getSimpleLabels();
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test091712() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getSimpleLabels();
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test091713() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getSimpleLabels();
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test091714() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getSimpleLabels();
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test091715() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getSimpleLabels();
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test091716() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getSimpleLabels();
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test091717() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.getSimpleLabels();
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test092718() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLabelFont();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test092719() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLabelFont();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test092720() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLabelFont();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test092721() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLabelFont();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test092722() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLabelFont();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test092723() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLabelFont();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test092724() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLabelFont();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test092725() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLabelFont();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test092726() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLabelFont();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test092727() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLabelFont();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test092728() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getLabelFont();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test093729() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    ringPlot0.setShadowXOffset(2597.28394812988);
    assertEquals(2597.28394812988, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test094730() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getToolTipGenerator();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test094731() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getToolTipGenerator();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test094732() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getToolTipGenerator();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public boolean isCircular() {
    return this.circular;
}","public void test094733() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getToolTipGenerator();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test094734() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getToolTipGenerator();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test094735() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getToolTipGenerator();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test094736() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getToolTipGenerator();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test094737() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getToolTipGenerator();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test094738() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getToolTipGenerator();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test094739() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getToolTipGenerator();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test094740() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getToolTipGenerator();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test095741() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    ringPlot0.getPlotType();
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test095742() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    ringPlot0.getPlotType();
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test095743() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    ringPlot0.getPlotType();
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test095744() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    ringPlot0.getPlotType();
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test095745() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    ringPlot0.getPlotType();
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test095746() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    ringPlot0.getPlotType();
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test095747() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    ringPlot0.getPlotType();
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test095748() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    ringPlot0.getPlotType();
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test095749() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    ringPlot0.getPlotType();
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test095750() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    ringPlot0.getPlotType();
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test095751() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    RingPlot ringPlot0 = new RingPlot(defaultKeyedValuesDataset0);
    ringPlot0.getPlotType();
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test096752() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getURLGenerator();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test096753() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getURLGenerator();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test096754() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getURLGenerator();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test096755() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getURLGenerator();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test096756() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getURLGenerator();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test096757() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getURLGenerator();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test096758() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getURLGenerator();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test096759() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getURLGenerator();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test096760() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getURLGenerator();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test096761() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getURLGenerator();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test096762() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getURLGenerator();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test097763() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    DateAxis dateAxis0 = new DateAxis(""1Q|(6Lb#&?lg)EI\u0004"");
    ringPlot0.setSectionPaint(""1Q|(6Lb#&?lg)EI\u0004"", dateAxis0.DEFAULT_AXIS_LABEL_PAINT);
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test097764() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    DateAxis dateAxis0 = new DateAxis(""1Q|(6Lb#&?lg)EI\u0004"");
    ringPlot0.setSectionPaint(""1Q|(6Lb#&?lg)EI\u0004"", dateAxis0.DEFAULT_AXIS_LABEL_PAINT);
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test097765() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    DateAxis dateAxis0 = new DateAxis(""1Q|(6Lb#&?lg)EI\u0004"");
    ringPlot0.setSectionPaint(""1Q|(6Lb#&?lg)EI\u0004"", dateAxis0.DEFAULT_AXIS_LABEL_PAINT);
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test097766() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    DateAxis dateAxis0 = new DateAxis(""1Q|(6Lb#&?lg)EI\u0004"");
    ringPlot0.setSectionPaint(""1Q|(6Lb#&?lg)EI\u0004"", dateAxis0.DEFAULT_AXIS_LABEL_PAINT);
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test097767() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    DateAxis dateAxis0 = new DateAxis(""1Q|(6Lb#&?lg)EI\u0004"");
    ringPlot0.setSectionPaint(""1Q|(6Lb#&?lg)EI\u0004"", dateAxis0.DEFAULT_AXIS_LABEL_PAINT);
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test097768() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    DateAxis dateAxis0 = new DateAxis(""1Q|(6Lb#&?lg)EI\u0004"");
    ringPlot0.setSectionPaint(""1Q|(6Lb#&?lg)EI\u0004"", dateAxis0.DEFAULT_AXIS_LABEL_PAINT);
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test097769() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    DateAxis dateAxis0 = new DateAxis(""1Q|(6Lb#&?lg)EI\u0004"");
    ringPlot0.setSectionPaint(""1Q|(6Lb#&?lg)EI\u0004"", dateAxis0.DEFAULT_AXIS_LABEL_PAINT);
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test097770() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    DateAxis dateAxis0 = new DateAxis(""1Q|(6Lb#&?lg)EI\u0004"");
    ringPlot0.setSectionPaint(""1Q|(6Lb#&?lg)EI\u0004"", dateAxis0.DEFAULT_AXIS_LABEL_PAINT);
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test097771() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    DateAxis dateAxis0 = new DateAxis(""1Q|(6Lb#&?lg)EI\u0004"");
    ringPlot0.setSectionPaint(""1Q|(6Lb#&?lg)EI\u0004"", dateAxis0.DEFAULT_AXIS_LABEL_PAINT);
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test097772() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    DateAxis dateAxis0 = new DateAxis(""1Q|(6Lb#&?lg)EI\u0004"");
    ringPlot0.setSectionPaint(""1Q|(6Lb#&?lg)EI\u0004"", dateAxis0.DEFAULT_AXIS_LABEL_PAINT);
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test097773() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    DateAxis dateAxis0 = new DateAxis(""1Q|(6Lb#&?lg)EI\u0004"");
    ringPlot0.setSectionPaint(""1Q|(6Lb#&?lg)EI\u0004"", dateAxis0.DEFAULT_AXIS_LABEL_PAINT);
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test098774() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator();
    piePlot3D0.setURLGenerator(standardPieURLGenerator0);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test098775() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator();
    piePlot3D0.setURLGenerator(standardPieURLGenerator0);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test098776() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator();
    piePlot3D0.setURLGenerator(standardPieURLGenerator0);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test098777() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator();
    piePlot3D0.setURLGenerator(standardPieURLGenerator0);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test098778() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator();
    piePlot3D0.setURLGenerator(standardPieURLGenerator0);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test098779() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator();
    piePlot3D0.setURLGenerator(standardPieURLGenerator0);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test098780() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator();
    piePlot3D0.setURLGenerator(standardPieURLGenerator0);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public int getPieIndex() {
    return this.pieIndex;
}","public void test098781() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator();
    piePlot3D0.setURLGenerator(standardPieURLGenerator0);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test098782() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator();
    piePlot3D0.setURLGenerator(standardPieURLGenerator0);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test098783() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator();
    piePlot3D0.setURLGenerator(standardPieURLGenerator0);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test098784() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator();
    piePlot3D0.setURLGenerator(standardPieURLGenerator0);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test099785() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test099786() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test099787() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test099788() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test099789() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"protected Paint lookupSectionOutlinePaint(Comparable key) {
    return lookupSectionOutlinePaint(key, false);
}","public void test099790() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertNotNull(color0);
}","/**
 * Returns the outline paint for the specified section.  This is equivalent
 * to <code>lookupSectionPaint(section, false)</code>.
 *
 * @param key  the section key.
 *
 * @return The paint for the specified section.
 *
 * @since 1.0.3
 *
 * @see #lookupSectionOutlinePaint(Comparable, boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test099791() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test099793() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test099794() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test099795() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test099796() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test099797() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.lookupSectionOutlinePaint((byte) 10);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test100798() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionOutlinePaint();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test100799() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionOutlinePaint();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test100800() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionOutlinePaint();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test100801() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionOutlinePaint();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test100802() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionOutlinePaint();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test100803() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionOutlinePaint();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test100804() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionOutlinePaint();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test100805() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionOutlinePaint();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test100806() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionOutlinePaint();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test100807() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionOutlinePaint();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test100809() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionOutlinePaint();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test101810() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreNullValues();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public int getPieIndex() {
    return this.pieIndex;
}","public void test101811() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreNullValues();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test101812() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreNullValues();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test101813() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreNullValues();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test101814() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreNullValues();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test101815() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreNullValues();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test101816() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreNullValues();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test101817() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreNullValues();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test101818() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreNullValues();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test101819() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreNullValues();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test101820() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreNullValues();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test102821() throws Throwable {
    TableOrder tableOrder0 = TableOrder.BY_ROW;
    CategoryToPieDataset categoryToPieDataset0 = new CategoryToPieDataset((CategoryDataset) null, tableOrder0, 293);
    PiePlot3D piePlot3D0 = new PiePlot3D(categoryToPieDataset0);
    piePlot3D0.setMaximumLabelWidth(2.0);
    assertEquals(2.0, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public Paint getSectionOutlinePaint(Comparable key) {
    // null argument check delegated...
    return this.sectionOutlinePaintMap.getPaint(key);
}","public void test103822() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    // Undeclared exception!
    try {
        piePlot3D0.getSectionOutlinePaint((Comparable) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'key' argument.
        //
        verifyException(""org.jfree.chart.PaintMap"", e);
    }
}","/**
 * Returns the outline paint associated with the specified key, or
 * <code>null</code> if there is no paint associated with the key.
 *
 * @param key  the key (<code>null</code> not permitted).
 *
 * @return The paint associated with the specified key, or
 *     <code>null</code>.
 *
 * @throws IllegalArgumentException if <code>key</code> is
 *     <code>null</code>.
 *
 * @see #setSectionOutlinePaint(Comparable, Paint)
 *
 * @since 1.0.3
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test104823() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator(""llDX)"", ""llDX)"");
    piePlot3D0.setLegendLabelURLGenerator(standardPieURLGenerator0);
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test104824() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator(""llDX)"", ""llDX)"");
    piePlot3D0.setLegendLabelURLGenerator(standardPieURLGenerator0);
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test104825() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator(""llDX)"", ""llDX)"");
    piePlot3D0.setLegendLabelURLGenerator(standardPieURLGenerator0);
    piePlot3D0.getLegendLabelURLGenerator();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test104826() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator(""llDX)"", ""llDX)"");
    piePlot3D0.setLegendLabelURLGenerator(standardPieURLGenerator0);
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test104827() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator(""llDX)"", ""llDX)"");
    piePlot3D0.setLegendLabelURLGenerator(standardPieURLGenerator0);
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test104828() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator(""llDX)"", ""llDX)"");
    piePlot3D0.setLegendLabelURLGenerator(standardPieURLGenerator0);
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test104829() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator(""llDX)"", ""llDX)"");
    piePlot3D0.setLegendLabelURLGenerator(standardPieURLGenerator0);
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test104830() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator(""llDX)"", ""llDX)"");
    piePlot3D0.setLegendLabelURLGenerator(standardPieURLGenerator0);
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test104831() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator(""llDX)"", ""llDX)"");
    piePlot3D0.setLegendLabelURLGenerator(standardPieURLGenerator0);
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test104832() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator(""llDX)"", ""llDX)"");
    piePlot3D0.setLegendLabelURLGenerator(standardPieURLGenerator0);
    piePlot3D0.getLegendLabelURLGenerator();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test104833() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    StandardPieURLGenerator standardPieURLGenerator0 = new StandardPieURLGenerator(""llDX)"", ""llDX)"");
    piePlot3D0.setLegendLabelURLGenerator(standardPieURLGenerator0);
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test105834() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test105835() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test105836() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test105837() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test105838() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public boolean getIgnoreNullValues() {
    return this.ignoreNullValues;
}","public void test105839() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertFalse(piePlot0.getIgnoreNullValues());
}","/**
 * Returns the flag that controls whether <code>null</code> values in the
 * dataset are ignored.
 *
 * @return A boolean.
 *
 * @see #setIgnoreNullValues(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test105840() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test105841() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test105842() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test105843() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test105844() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test105845() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setIgnoreNullValues(false);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test106846() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test106847() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test106848() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test106849() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test106850() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test106851() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test106852() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test106853() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test106854() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test106855() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getTop() {
    return this.top;
}","public void test106856() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertEquals(2.0, rectangleInsets0.getTop(), 0.01);
}","/**
 * Returns the top insets.
 *
 * @return The top insets.
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test106857() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getLabelPadding();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test107858() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public int getPieIndex() {
    return this.pieIndex;
}","public void test107859() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test107860() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test107861() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test107862() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test107863() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test107864() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test107865() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test107866() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test107867() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test107868() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getTop() {
    return this.top;
}","public void test107869() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    RectangleInsets rectangleInsets0 = piePlot3D0.getSimpleLabelOffset();
    assertEquals(0.18, rectangleInsets0.getTop(), 0.01);
}","/**
 * Returns the top insets.
 *
 * @return The top insets.
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test108870() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D((PieDataset) null);
    piePlot3D0.setCircular(true);
    assertTrue(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test109871() throws Throwable {
    DefaultPieDataset defaultPieDataset0 = new DefaultPieDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultPieDataset0);
    piePlot3D0.setStartAngle(0.025);
    assertEquals(0.025, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test110872() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test110873() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.setShadowYOffset(0.0);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test111874() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) SpiderWebPlot.DEFAULT_LABEL_OUTLINE_PAINT;
    piePlot0.setSectionOutlinePaint("""", color0);
    Color color1 = (Color) piePlot0.lookupSectionOutlinePaint("""", false);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test111875() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) SpiderWebPlot.DEFAULT_LABEL_OUTLINE_PAINT;
    piePlot0.setSectionOutlinePaint("""", color0);
    Color color1 = (Color) piePlot0.lookupSectionOutlinePaint("""", false);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test111876() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) SpiderWebPlot.DEFAULT_LABEL_OUTLINE_PAINT;
    piePlot0.setSectionOutlinePaint("""", color0);
    Color color1 = (Color) piePlot0.lookupSectionOutlinePaint("""", false);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test111877() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) SpiderWebPlot.DEFAULT_LABEL_OUTLINE_PAINT;
    piePlot0.setSectionOutlinePaint("""", color0);
    Color color1 = (Color) piePlot0.lookupSectionOutlinePaint("""", false);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test111878() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) SpiderWebPlot.DEFAULT_LABEL_OUTLINE_PAINT;
    piePlot0.setSectionOutlinePaint("""", color0);
    Color color1 = (Color) piePlot0.lookupSectionOutlinePaint("""", false);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test111879() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) SpiderWebPlot.DEFAULT_LABEL_OUTLINE_PAINT;
    piePlot0.setSectionOutlinePaint("""", color0);
    Color color1 = (Color) piePlot0.lookupSectionOutlinePaint("""", false);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test111880() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) SpiderWebPlot.DEFAULT_LABEL_OUTLINE_PAINT;
    piePlot0.setSectionOutlinePaint("""", color0);
    Color color1 = (Color) piePlot0.lookupSectionOutlinePaint("""", false);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test111881() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) SpiderWebPlot.DEFAULT_LABEL_OUTLINE_PAINT;
    piePlot0.setSectionOutlinePaint("""", color0);
    Color color1 = (Color) piePlot0.lookupSectionOutlinePaint("""", false);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test111882() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) SpiderWebPlot.DEFAULT_LABEL_OUTLINE_PAINT;
    piePlot0.setSectionOutlinePaint("""", color0);
    Color color1 = (Color) piePlot0.lookupSectionOutlinePaint("""", false);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test111884() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) SpiderWebPlot.DEFAULT_LABEL_OUTLINE_PAINT;
    piePlot0.setSectionOutlinePaint("""", color0);
    Color color1 = (Color) piePlot0.lookupSectionOutlinePaint("""", false);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test111885() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) SpiderWebPlot.DEFAULT_LABEL_OUTLINE_PAINT;
    piePlot0.setSectionOutlinePaint("""", color0);
    Color color1 = (Color) piePlot0.lookupSectionOutlinePaint("""", false);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test112886() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getShadowYOffset();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test112887() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getShadowYOffset();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test112888() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getShadowYOffset();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test112889() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getShadowYOffset();
    assertEquals(4.0, double0, 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test112890() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getShadowYOffset();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test112891() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getShadowYOffset();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test112892() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getShadowYOffset();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test112893() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getShadowYOffset();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test112894() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getShadowYOffset();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test112895() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getShadowYOffset();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test112896() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getShadowYOffset();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test113897() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test113898() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test113899() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test113900() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test113901() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test113902() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test113903() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test113904() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test113905() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test113906() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean getLabelLinksVisible() {
    return this.labelLinksVisible;
}","public void test113907() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertTrue(boolean0);
}","/**
 * Returns the flag that controls whether or not label linking lines are
 * visible.
 *
 * @return A boolean.
 *
 * @see #setLabelLinksVisible(boolean)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test113908() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot piePlot0 = new PiePlot(jDBCPieDataset0);
    boolean boolean0 = piePlot0.getLabelLinksVisible();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test114909() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    StandardPieToolTipGenerator standardPieToolTipGenerator0 = new StandardPieToolTipGenerator(""69%N#p"");
    ringPlot0.setToolTipGenerator(standardPieToolTipGenerator0);
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test114910() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    StandardPieToolTipGenerator standardPieToolTipGenerator0 = new StandardPieToolTipGenerator(""69%N#p"");
    ringPlot0.setToolTipGenerator(standardPieToolTipGenerator0);
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test114911() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    StandardPieToolTipGenerator standardPieToolTipGenerator0 = new StandardPieToolTipGenerator(""69%N#p"");
    ringPlot0.setToolTipGenerator(standardPieToolTipGenerator0);
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test114912() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    StandardPieToolTipGenerator standardPieToolTipGenerator0 = new StandardPieToolTipGenerator(""69%N#p"");
    ringPlot0.setToolTipGenerator(standardPieToolTipGenerator0);
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test114913() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    StandardPieToolTipGenerator standardPieToolTipGenerator0 = new StandardPieToolTipGenerator(""69%N#p"");
    ringPlot0.setToolTipGenerator(standardPieToolTipGenerator0);
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test114914() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    StandardPieToolTipGenerator standardPieToolTipGenerator0 = new StandardPieToolTipGenerator(""69%N#p"");
    ringPlot0.setToolTipGenerator(standardPieToolTipGenerator0);
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test114915() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    StandardPieToolTipGenerator standardPieToolTipGenerator0 = new StandardPieToolTipGenerator(""69%N#p"");
    ringPlot0.setToolTipGenerator(standardPieToolTipGenerator0);
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test114916() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    StandardPieToolTipGenerator standardPieToolTipGenerator0 = new StandardPieToolTipGenerator(""69%N#p"");
    ringPlot0.setToolTipGenerator(standardPieToolTipGenerator0);
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test114917() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    StandardPieToolTipGenerator standardPieToolTipGenerator0 = new StandardPieToolTipGenerator(""69%N#p"");
    ringPlot0.setToolTipGenerator(standardPieToolTipGenerator0);
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test114918() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    StandardPieToolTipGenerator standardPieToolTipGenerator0 = new StandardPieToolTipGenerator(""69%N#p"");
    ringPlot0.setToolTipGenerator(standardPieToolTipGenerator0);
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test114919() throws Throwable {
    RingPlot ringPlot0 = new RingPlot((PieDataset) null);
    StandardPieToolTipGenerator standardPieToolTipGenerator0 = new StandardPieToolTipGenerator(""69%N#p"");
    ringPlot0.setToolTipGenerator(standardPieToolTipGenerator0);
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public Stroke getSectionOutlineStroke(Comparable key) {
    // null argument check delegated...
    return this.sectionOutlineStrokeMap.getStroke(key);
}","public void test115920() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCCategoryDataset jDBCCategoryDataset0 = new JDBCCategoryDataset(connection0);
    TableOrder tableOrder0 = TableOrder.BY_COLUMN;
    CategoryToPieDataset categoryToPieDataset0 = new CategoryToPieDataset(jDBCCategoryDataset0, tableOrder0, 55);
    PiePlot piePlot0 = new PiePlot(categoryToPieDataset0);
    // Undeclared exception!
    try {
        piePlot0.getSectionOutlineStroke((Comparable) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null 'key' argument.
        //
        verifyException(""org.jfree.chart.StrokeMap"", e);
    }
}","/**
 * Returns the outline stroke associated with the specified key, or
 * <code>null</code> if there is no stroke associated with the key.
 *
 * @param key  the key (<code>null</code> not permitted).
 *
 * @return The stroke associated with the specified key, or
 *     <code>null</code>.
 *
 * @throws IllegalArgumentException if <code>key</code> is
 *     <code>null</code>.
 *
 * @see #setSectionOutlineStroke(Comparable, Stroke)
 *
 * @since 1.0.3
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test116921() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test116922() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setSectionOutlinesVisible(false);
    assertFalse(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test117923() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionPaint();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test117924() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionPaint();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test117925() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionPaint();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test117926() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionPaint();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test117927() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionPaint();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test117928() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionPaint();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test117929() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionPaint();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test117930() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionPaint();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test117931() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionPaint();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test117933() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionPaint();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test117934() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getBaseSectionPaint();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public Paint getLabelBackgroundPaint() {
    return this.labelBackgroundPaint;
}","public void test118935() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertNull(paint0);
}","/**
 * Returns the section label background paint.
 *
 * @return The paint (possibly <code>null</code>).
 *
 * @see #setLabelBackgroundPaint(Paint)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test118936() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test118937() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test118938() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test118939() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test118940() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test118941() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test118942() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test118943() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test118944() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test118945() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test118946() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelBackgroundPaint((Paint) null);
    Paint paint0 = piePlot0.getLabelBackgroundPaint();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test119947() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getShadowXOffset();
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test119948() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getShadowXOffset();
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test119949() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getShadowXOffset();
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test119950() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getShadowXOffset();
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test119951() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getShadowXOffset();
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test119952() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getShadowXOffset();
    assertEquals(4.0, double0, 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test119953() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getShadowXOffset();
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test119954() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getShadowXOffset();
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test119955() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getShadowXOffset();
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test119956() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getShadowXOffset();
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test119957() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    double double0 = ringPlot0.getShadowXOffset();
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean getIgnoreZeroValues() {
    return this.ignoreZeroValues;
}","public void test120958() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.setIgnoreZeroValues(true);
    assertTrue(piePlot3D0.getIgnoreZeroValues());
}","/**
 * Returns the flag that controls whether zero values in the
 * dataset are ignored.
 *
 * @return A boolean.
 *
 * @see #setIgnoreZeroValues(boolean)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test121959() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot0.getLegendLabelGenerator();
    piePlot0.setLegendLabelGenerator(pieSectionLabelGenerator0);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test121960() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot0.getLegendLabelGenerator();
    piePlot0.setLegendLabelGenerator(pieSectionLabelGenerator0);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test121961() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot0.getLegendLabelGenerator();
    piePlot0.setLegendLabelGenerator(pieSectionLabelGenerator0);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test121962() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot0.getLegendLabelGenerator();
    piePlot0.setLegendLabelGenerator(pieSectionLabelGenerator0);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test121963() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot0.getLegendLabelGenerator();
    piePlot0.setLegendLabelGenerator(pieSectionLabelGenerator0);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test121964() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot0.getLegendLabelGenerator();
    piePlot0.setLegendLabelGenerator(pieSectionLabelGenerator0);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test121965() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot0.getLegendLabelGenerator();
    piePlot0.setLegendLabelGenerator(pieSectionLabelGenerator0);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test121966() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot0.getLegendLabelGenerator();
    piePlot0.setLegendLabelGenerator(pieSectionLabelGenerator0);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test121967() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot0.getLegendLabelGenerator();
    piePlot0.setLegendLabelGenerator(pieSectionLabelGenerator0);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test121968() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot0.getLegendLabelGenerator();
    piePlot0.setLegendLabelGenerator(pieSectionLabelGenerator0);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test121969() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    PieSectionLabelGenerator pieSectionLabelGenerator0 = piePlot0.getLegendLabelGenerator();
    piePlot0.setLegendLabelGenerator(pieSectionLabelGenerator0);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test122970() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getLegendLabelURLGenerator();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test122971() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test122972() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test122973() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test122974() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test122975() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getLegendLabelURLGenerator();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test122976() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test122977() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test122978() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test122979() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test122980() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    piePlot3D0.getLegendLabelURLGenerator();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test123981() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelOutlineStroke(piePlot0.DEFAULT_LABEL_OUTLINE_STROKE);
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test123982() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelOutlineStroke(piePlot0.DEFAULT_LABEL_OUTLINE_STROKE);
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test123983() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelOutlineStroke(piePlot0.DEFAULT_LABEL_OUTLINE_STROKE);
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test123984() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelOutlineStroke(piePlot0.DEFAULT_LABEL_OUTLINE_STROKE);
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test123985() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelOutlineStroke(piePlot0.DEFAULT_LABEL_OUTLINE_STROKE);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test123986() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelOutlineStroke(piePlot0.DEFAULT_LABEL_OUTLINE_STROKE);
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test123987() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelOutlineStroke(piePlot0.DEFAULT_LABEL_OUTLINE_STROKE);
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test123988() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelOutlineStroke(piePlot0.DEFAULT_LABEL_OUTLINE_STROKE);
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test123989() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelOutlineStroke(piePlot0.DEFAULT_LABEL_OUTLINE_STROKE);
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test123990() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelOutlineStroke(piePlot0.DEFAULT_LABEL_OUTLINE_STROKE);
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test123991() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelOutlineStroke(piePlot0.DEFAULT_LABEL_OUTLINE_STROKE);
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test124992() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelLinkPaint();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test124993() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelLinkPaint();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test124994() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelLinkPaint();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test124995() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelLinkPaint();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test124996() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelLinkPaint();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test124997() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelLinkPaint();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test124998() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelLinkPaint();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test124999() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelLinkPaint();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1241000() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelLinkPaint();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1241001() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelLinkPaint();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1241003() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelLinkPaint();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1251004() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getShadowPaint();
    piePlot3D0.setLabelOutlinePaint(color0);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1251005() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getShadowPaint();
    piePlot3D0.setLabelOutlinePaint(color0);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test1251006() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getShadowPaint();
    piePlot3D0.setLabelOutlinePaint(color0);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1251007() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getShadowPaint();
    piePlot3D0.setLabelOutlinePaint(color0);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1251008() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getShadowPaint();
    piePlot3D0.setLabelOutlinePaint(color0);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1251009() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getShadowPaint();
    piePlot3D0.setLabelOutlinePaint(color0);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1251011() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getShadowPaint();
    piePlot3D0.setLabelOutlinePaint(color0);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1251012() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getShadowPaint();
    piePlot3D0.setLabelOutlinePaint(color0);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1251013() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getShadowPaint();
    piePlot3D0.setLabelOutlinePaint(color0);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1251014() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getShadowPaint();
    piePlot3D0.setLabelOutlinePaint(color0);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1251015() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    Color color0 = (Color) piePlot3D0.getShadowPaint();
    piePlot3D0.setLabelOutlinePaint(color0);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1261016() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getMinimumArcAngleToDraw();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1261017() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getMinimumArcAngleToDraw();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1261018() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getMinimumArcAngleToDraw();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1261019() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getMinimumArcAngleToDraw();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1261020() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getMinimumArcAngleToDraw();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1261021() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getMinimumArcAngleToDraw();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1261022() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getMinimumArcAngleToDraw();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1261023() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getMinimumArcAngleToDraw();
    assertEquals(1.0E-5, double0, 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test1261024() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getMinimumArcAngleToDraw();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1261025() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getMinimumArcAngleToDraw();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1261026() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    double double0 = piePlot0.getMinimumArcAngleToDraw();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1271027() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelShadowPaint();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1271028() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelShadowPaint();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1271029() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelShadowPaint();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1271030() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelShadowPaint();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1271031() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelShadowPaint();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1271032() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelShadowPaint();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1271033() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelShadowPaint();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1271034() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelShadowPaint();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1271035() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelShadowPaint();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test1271036() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelShadowPaint();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1271037() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    Color color0 = (Color) piePlot0.getLabelShadowPaint();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1281039() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.getDataset();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1281040() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.getDataset();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1281041() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.getDataset();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1281042() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.getDataset();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test1281043() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.getDataset();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1281044() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.getDataset();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1281045() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.getDataset();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1281046() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.getDataset();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1281047() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.getDataset();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1281048() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.getDataset();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1281049() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    piePlot3D0.getDataset();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1291050() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinksVisible(false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.025, piePlot1.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1291051() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinksVisible(false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(1.0E-5, piePlot1.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1291052() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinksVisible(false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertTrue(piePlot1.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1291053() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinksVisible(false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.14, piePlot1.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof PiePlot)) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    PiePlot that = (PiePlot) obj;
    if (this.pieIndex != that.pieIndex) {
        return false;
    }
    if (this.interiorGap != that.interiorGap) {
        return false;
    }
    if (this.circular != that.circular) {
        return false;
    }
    if (this.startAngle != that.startAngle) {
        return false;
    }
    if (this.direction != that.direction) {
        return false;
    }
    if (this.ignoreZeroValues != that.ignoreZeroValues) {
        return false;
    }
    if (this.ignoreNullValues != that.ignoreNullValues) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionPaintMap, that.sectionPaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionPaint, that.baseSectionPaint)) {
        return false;
    }
    if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, that.sectionOutlinePaintMap)) {
        return false;
    }
    if (!PaintUtilities.equal(this.baseSectionOutlinePaint, that.baseSectionOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, that.sectionOutlineStrokeMap)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.baseSectionOutlineStroke, that.baseSectionOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {
        return false;
    }
    if (!(this.shadowXOffset == that.shadowXOffset)) {
        return false;
    }
    if (!(this.shadowYOffset == that.shadowYOffset)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.explodePercentages, that.explodePercentages)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelGenerator, that.labelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelBackgroundPaint, that.labelBackgroundPaint)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelOutlinePaint, that.labelOutlinePaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelOutlineStroke, that.labelOutlineStroke)) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelShadowPaint, that.labelShadowPaint)) {
        return false;
    }
    if (this.simpleLabels != that.simpleLabels) {
        return false;
    }
    if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {
        return false;
    }
    if (!this.labelPadding.equals(that.labelPadding)) {
        return false;
    }
    if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {
        return false;
    }
    if (!(this.labelGap == that.labelGap)) {
        return false;
    }
    if (!(this.labelLinkMargin == that.labelLinkMargin)) {
        return false;
    }
    if (this.labelLinksVisible != that.labelLinksVisible) {
        return false;
    }
    if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.labelLinkStroke, that.labelLinkStroke)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.toolTipGenerator, that.toolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {
        return false;
    }
    if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {
        return false;
    }
    if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelGenerator, that.legendLabelGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator, that.legendLabelToolTipGenerator)) {
        return false;
    }
    if (!ObjectUtilities.equal(this.legendLabelURLGenerator, that.legendLabelURLGenerator)) {
        return false;
    }
    // can't find any difference...
    return true;
}","public void test1291054() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinksVisible(false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertFalse(boolean0);
}","/**
 * Tests this plot for equality with an arbitrary object.  Note that the
 * plot's dataset is NOT included in the test for equality.
 *
 * @param obj  the object to test against (<code>null</code> permitted).
 *
 * @return <code>true</code> or <code>false</code>.
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test1291055() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinksVisible(false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.025, piePlot1.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1291056() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinksVisible(false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(0.08, piePlot1.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1291057() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinksVisible(false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(90.0, piePlot1.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1291058() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinksVisible(false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(4.0, piePlot1.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1291059() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinksVisible(false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertTrue(piePlot1.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1291060() throws Throwable {
    PiePlot piePlot0 = new PiePlot((PieDataset) null);
    piePlot0.setLabelLinksVisible(false);
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot1 = new PiePlot(defaultKeyedValuesDataset0);
    boolean boolean0 = piePlot0.equals(piePlot1);
    assertEquals(4.0, piePlot1.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1301061() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    int int0 = piePlot3D0.getPieIndex();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1301062() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    int int0 = piePlot3D0.getPieIndex();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1301063() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    int int0 = piePlot3D0.getPieIndex();
    assertEquals(0, int0);
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1301064() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    int int0 = piePlot3D0.getPieIndex();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1301065() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    int int0 = piePlot3D0.getPieIndex();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1301066() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    int int0 = piePlot3D0.getPieIndex();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1301067() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    int int0 = piePlot3D0.getPieIndex();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1301068() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    int int0 = piePlot3D0.getPieIndex();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1301069() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    int int0 = piePlot3D0.getPieIndex();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test1301070() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    int int0 = piePlot3D0.getPieIndex();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1301071() throws Throwable {
    Connection connection0 = mock(Connection.class, new ViolatedAssumptionAnswer());
    JDBCPieDataset jDBCPieDataset0 = new JDBCPieDataset(connection0);
    PiePlot3D piePlot3D0 = new PiePlot3D(jDBCPieDataset0);
    int int0 = piePlot3D0.getPieIndex();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1311072() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.getSectionOutlinesVisible();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1311073() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.getSectionOutlinesVisible();
    assertTrue(boolean0);
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test1311074() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.getSectionOutlinesVisible();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1311075() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.getSectionOutlinesVisible();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1311076() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.getSectionOutlinesVisible();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1311077() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.getSectionOutlinesVisible();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1311078() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.getSectionOutlinesVisible();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1311079() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.getSectionOutlinesVisible();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1311080() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.getSectionOutlinesVisible();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1311081() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.getSectionOutlinesVisible();
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1311082() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    boolean boolean0 = piePlot3D0.getSectionOutlinesVisible();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1321083() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLabelOutlineStroke();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1321084() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLabelOutlineStroke();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1321085() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLabelOutlineStroke();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1321086() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLabelOutlineStroke();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1321087() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLabelOutlineStroke();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1321088() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLabelOutlineStroke();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1321089() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLabelOutlineStroke();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1321090() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLabelOutlineStroke();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test1321091() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLabelOutlineStroke();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1321092() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLabelOutlineStroke();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1321093() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getLabelOutlineStroke();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test1331094() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1331095() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1331096() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertEquals(0.025, piePlot3D0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1331097() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1331098() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1331099() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1331100() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1331101() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"//// SECTION PAINT ////////////////////////////////////////////////////////
/**
 * Returns the paint for the specified section.  This is equivalent to
 * <code>lookupSectionPaint(section, false)</code>.
 *
 * @param key  the section key.
 *
 * @return The paint for the specified section.
 *
 * @since 1.0.3
 *
 * @see #lookupSectionPaint(Comparable, boolean)
 */
protected Paint lookupSectionPaint(Comparable key) {
    return lookupSectionPaint(key, false);
}","public void test1331103() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertNotNull(color0);
}",""
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1331104() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1331105() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1331106() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    XYDataItem xYDataItem0 = new XYDataItem((Number) 0.08, (Number) 1.0F);
    Color color0 = (Color) piePlot3D0.lookupSectionPaint(xYDataItem0);
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1341107() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreZeroValues();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1341108() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreZeroValues();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1341109() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreZeroValues();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1341110() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreZeroValues();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1341111() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreZeroValues();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1341112() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreZeroValues();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1341113() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreZeroValues();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1341114() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreZeroValues();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1341115() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreZeroValues();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1341116() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreZeroValues();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test1341117() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot piePlot0 = new PiePlot(defaultKeyedValuesDataset0);
    piePlot0.getIgnoreZeroValues();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1351118() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1351119() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.setLabelLinkMargin(1.0);
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1361120() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getDirection();
    assertTrue(piePlot0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test1361121() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getDirection();
    assertEquals(0.025, piePlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1361122() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getDirection();
    assertEquals(0, piePlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1361123() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getDirection();
    assertTrue(piePlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1361124() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getDirection();
    assertEquals(0.14, piePlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1361125() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getDirection();
    assertEquals(0.025, piePlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1361126() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getDirection();
    assertEquals(4.0, piePlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1361127() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getDirection();
    assertEquals(0.08, piePlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1361128() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getDirection();
    assertEquals(90.0, piePlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1361129() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getDirection();
    assertEquals(1.0E-5, piePlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1361130() throws Throwable {
    PiePlot piePlot0 = new PiePlot();
    piePlot0.getDirection();
    assertEquals(4.0, piePlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1371131() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    Color color0 = (Color) ringPlot0.getLabelOutlinePaint();
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1371132() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    Color color0 = (Color) ringPlot0.getLabelOutlinePaint();
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1371133() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    Color color0 = (Color) ringPlot0.getLabelOutlinePaint();
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1371134() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    Color color0 = (Color) ringPlot0.getLabelOutlinePaint();
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1371135() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    Color color0 = (Color) ringPlot0.getLabelOutlinePaint();
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getStartAngle() {
    return this.startAngle;
}","public void test1371136() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    Color color0 = (Color) ringPlot0.getLabelOutlinePaint();
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1371137() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    Color color0 = (Color) ringPlot0.getLabelOutlinePaint();
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1371138() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    Color color0 = (Color) ringPlot0.getLabelOutlinePaint();
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1371139() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    Color color0 = (Color) ringPlot0.getLabelOutlinePaint();
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test1371141() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    Color color0 = (Color) ringPlot0.getLabelOutlinePaint();
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1371142() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    Color color0 = (Color) ringPlot0.getLabelOutlinePaint();
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1381143() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getLabelLinkMargin();
    assertEquals(1.0E-5, piePlot3D0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1381144() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getLabelLinkMargin();
    assertFalse(piePlot3D0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1381145() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getLabelLinkMargin();
    assertEquals(4.0, piePlot3D0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1381146() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getLabelLinkMargin();
    assertEquals(4.0, piePlot3D0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1381147() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getLabelLinkMargin();
    assertEquals(90.0, piePlot3D0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1381148() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getLabelLinkMargin();
    assertTrue(piePlot3D0.getSectionOutlinesVisible());
}",""
"public double getLabelGap() {
    return this.labelGap;
}","public void test1381149() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getLabelLinkMargin();
    assertEquals(0.025, piePlot3D0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1381150() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getLabelLinkMargin();
    assertEquals(0.025, double0, 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1381151() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getLabelLinkMargin();
    assertEquals(0.14, piePlot3D0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1381152() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getLabelLinkMargin();
    assertEquals(0, piePlot3D0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1381153() throws Throwable {
    PiePlot3D piePlot3D0 = new PiePlot3D();
    double double0 = piePlot3D0.getLabelLinkMargin();
    assertEquals(0.08, piePlot3D0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public double getShadowXOffset() {
    return this.shadowXOffset;
}","public void test1391154() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setLabelShadowPaint((Paint) null);
    assertEquals(4.0, ringPlot0.getShadowXOffset(), 0.01);
}","/**
 * Returns the x-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowXOffset(double)
 */"
"public int getPieIndex() {
    return this.pieIndex;
}","public void test1391155() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setLabelShadowPaint((Paint) null);
    assertEquals(0, ringPlot0.getPieIndex());
}","/**
 * Returns the pie index (this is used by the {@link MultiplePiePlot} class
 * to track subplots).
 *
 * @return The pie index.
 *
 * @see #setPieIndex(int)
 */"
"public double getLabelLinkMargin() {
    return this.labelLinkMargin;
}","public void test1391156() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setLabelShadowPaint((Paint) null);
    assertEquals(0.025, ringPlot0.getLabelLinkMargin(), 0.01);
}","/**
 * Returns the margin (expressed as a percentage of the width or height)
 * between the edge of the pie and the link point.
 *
 * @return The link margin (as a percentage, where 0.05 is five percent).
 *
 * @see #setLabelLinkMargin(double)
 */"
"public double getLabelGap() {
    return this.labelGap;
}","public void test1391157() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setLabelShadowPaint((Paint) null);
    assertEquals(0.025, ringPlot0.getLabelGap(), 0.01);
}","/**
 * Returns the gap between the edge of the pie and the labels, expressed as
 * a percentage of the plot width.
 *
 * @return The gap (a percentage, where 0.05 = five percent).
 *
 * @see #setLabelGap(double)
 */"
"public double getInteriorGap() {
    return this.interiorGap;
}","public void test1391158() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setLabelShadowPaint((Paint) null);
    assertEquals(0.08, ringPlot0.getInteriorGap(), 0.01);
}","/**
 * Returns the interior gap, measured as a percentage of the available
 * drawing space.
 *
 * @return The gap (as a percentage of the available drawing space).
 *
 * @see #setInteriorGap(double)
 */"
"public boolean isCircular() {
    return this.circular;
}","public void test1391159() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setLabelShadowPaint((Paint) null);
    assertTrue(ringPlot0.isCircular());
}","/**
 * Returns a flag indicating whether the pie chart is circular, or
 * stretched into an elliptical shape.
 *
 * @return A flag indicating whether the pie chart is circular.
 *
 * @see #setCircular(boolean)
 */"
"public double getStartAngle() {
    return this.startAngle;
}","public void test1391160() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setLabelShadowPaint((Paint) null);
    assertEquals(90.0, ringPlot0.getStartAngle(), 0.01);
}","/**
 * Returns the start angle for the first pie section.  This is measured in
 * degrees starting from 3 o'clock and measuring anti-clockwise.
 *
 * @return The start angle.
 *
 * @see #setStartAngle(double)
 */"
"public double getMaximumLabelWidth() {
    return this.maximumLabelWidth;
}","public void test1391161() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setLabelShadowPaint((Paint) null);
    assertEquals(0.14, ringPlot0.getMaximumLabelWidth(), 0.01);
}","/**
 * Returns the maximum label width as a percentage of the plot width.
 *
 * @return The width (a percentage, where 0.20 = 20 percent).
 *
 * @see #setMaximumLabelWidth(double)
 */"
"public double getMinimumArcAngleToDraw() {
    return this.minimumArcAngleToDraw;
}","public void test1391162() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setLabelShadowPaint((Paint) null);
    assertEquals(1.0E-5, ringPlot0.getMinimumArcAngleToDraw(), 0.01);
}","/**
 * Returns the minimum arc angle that will be drawn.  Pie sections for an
 * angle smaller than this are not drawn, to avoid a JDK bug.
 *
 * @return The minimum angle.
 *
 * @see #setMinimumArcAngleToDraw(double)
 */"
"//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
/**
 * Returns the flag that controls whether or not the outline is drawn for
 * each pie section.
 *
 * @return The flag that controls whether or not the outline is drawn for
 *         each pie section.
 *
 * @see #setSectionOutlinesVisible(boolean)
 */
public boolean getSectionOutlinesVisible() {
    return this.sectionOutlinesVisible;
}","public void test1391163() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setLabelShadowPaint((Paint) null);
    assertTrue(ringPlot0.getSectionOutlinesVisible());
}",""
"public double getShadowYOffset() {
    return this.shadowYOffset;
}","public void test1391164() throws Throwable {
    RingPlot ringPlot0 = new RingPlot();
    ringPlot0.setLabelShadowPaint((Paint) null);
    assertEquals(4.0, ringPlot0.getShadowYOffset(), 0.01);
}","/**
 * Returns the y-offset for the shadow effect.
 *
 * @return The offset (in Java2D units).
 *
 * @see #setShadowYOffset(double)
 */"
"public boolean getSimpleLabels() {
    return this.simpleLabels;
}","public void test1401165() throws Throwable {
    DefaultKeyedValuesDataset defaultKeyedValuesDataset0 = new DefaultKeyedValuesDataset();
    PiePlot3D piePlot3D0 = new PiePlot3D(defaultKeyedValuesDataset0);
    piePlot3D0.setSimpleLabels(true);
    assertTrue(piePlot3D0.getSimpleLabels());
}","/**
 * Returns the flag that controls whether simple or extended labels are
 * displayed on the plot.
 *
 * @return A boolean.
 *
 * @since 1.0.7
 */"
