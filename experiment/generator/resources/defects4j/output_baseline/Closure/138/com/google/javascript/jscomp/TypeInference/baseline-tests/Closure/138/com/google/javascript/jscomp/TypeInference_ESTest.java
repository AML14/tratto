/*
 * This file was automatically generated by EvoSuite
 * Sun Nov 19 22:45:14 GMT 2023
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.Multimap;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.DefaultCodingConvention;
import com.google.javascript.jscomp.FlowScope;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.LoggerErrorManager;
import com.google.javascript.jscomp.PrintStreamErrorManager;
import com.google.javascript.jscomp.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.rhino.ErrorReporter;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.ObjectType;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
import java.util.Vector;
import java.util.logging.Logger;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test0000() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(89, 89, 89);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node1 = new Node(100, node0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test0011() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node0 = new Node(86, 0, 0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0022() throws Throwable {
        Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseTestCode("d1");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
        Multimap<Scope, Scope.Var> multimap0 = typeInference0.getAssignedOuterLocalVars();
    }

    @Test(timeout = 4000)
    public void test0033() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(101, 101, 101);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node1 = new Node(33, 15, 4);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test0044() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node0 = new Node(120, 17, 0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0055() throws Throwable {
        Node node0 = new Node(122, 122, 122);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Scope.Var scope_Var0 = scope0.declare("*1dnJG?,fw7di>", node0, (JSType) null, (CompilerInput) null);
        arrayList0.add(scope_Var0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);
    }

    @Test(timeout = 4000)
    public void test0066() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(96, 96, 100);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Scope.Var scope_Var0 = scope0.declare("K<", node0, (JSType) null, (CompilerInput) null);
        scope0.undeclare(scope_Var0);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        arrayList0.add(scope_Var0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    }

    @Test(timeout = 4000)
    public void test0077() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(51, 51, 51);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createScope(node0, (Scope) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    }

    @Test(timeout = 4000)
    public void test0088() throws Throwable {
        Node node0 = new Node(62);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Node node1 = new Node(1, node0);
        JSType[] jSTypeArray0 = new JSType[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeArray0);
        scope0.declare("]*oxk\"/_", node0, jSType0, (CompilerInput) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler((PrintStream) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    }

    @Test(timeout = 4000)
    public void test0099() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node((-117), (-117), (-117));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Node node1 = new Node(117, node0);
        scope0.declare("Te@GYj7bIY9", node0, (JSType) null, (CompilerInput) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    }

    @Test(timeout = 4000)
    public void test01010() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(63);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
        controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node0, flowScope0);
    }

    @Test(timeout = 4000)
    public void test01111() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(51, 51, 123);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention) compiler0.defaultCodingConvention;
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
        controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test01212() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
        controlFlowGraph0.connectIfNotFound((Node) null, controlFlowGraph_Branch0, (Node) null);
        FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
        typeInference0.branchedFlowThrough((Node) null, flowScope0);
    }

    @Test(timeout = 4000)
    public void test01313() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(111, 111, 995);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        node0.addChildrenToBack(node0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
        controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
        FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test01414() throws Throwable {
        Node node0 = new Node(122);
        Node node1 = new Node(4, node0, node0, node0, node0, 1, 33);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node1, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test01515() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Node node0 = new Node(5);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node0, flowScope0);
    }

    @Test(timeout = 4000)
    public void test01616() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(51, 51, 123);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(6, 7, 7);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01717() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(7);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test01818() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node0 = new Node(8, 27, 46);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01919() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(148, 148, 148);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(9, 19, (-2624));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02020() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(148);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node1 = new Node(10, 39, 19);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02121() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node((-593), (-593), (-593));
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(11, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02222() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node0 = new Node(12, 21, 129);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node0, flowScope0);
    }

    @Test(timeout = 4000)
    public void test02323() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(13, (-2663), (-2614));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test02424() throws Throwable {
        Node node0 = new Node(74, 74, 74);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(14, node0, node0, node0, 40, 33);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test02525() throws Throwable {
        Node node0 = new Node(15);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test02626() throws Throwable {
        Node node0 = new Node(122, 122, 122);
        Node node1 = new Node(16, node0, node0, node0, node0, 1, 33);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node1, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test02727() throws Throwable {
        Node node0 = new Node(17);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test02828() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.getRoot();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(19, "+");
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02929() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node((-117), (-117), (-117));
        Node node1 = new Node(20, 36, 18);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node1, (ObjectType) null);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03030() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(101, 101, 101);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node1 = new Node(21, node0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test03131() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(122, 122, 122);
        Node node1 = new Node(22, node0, node0, node0, node0, 3, 14);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test03232() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(99);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Node node1 = new Node(23, node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test03333() throws Throwable {
        Node node0 = new Node(74);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        Node node1 = new Node(24, 7, 13);
        Stack<Scope.Var> stack0 = new Stack<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, stack0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test03434() throws Throwable {
        Node node0 = new Node(1695, 1887, (-1314));
        Node node1 = new Node(25, node0, node0, node0, node0, 31, 84);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node1, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test03535() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(51, 51, 123);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention) compiler0.defaultCodingConvention;
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(26);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test03636() throws Throwable {
        Node node0 = new Node(81, 81, 81);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((PrintStream) null);
        Compiler compiler0 = new Compiler(printStreamErrorManager0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node1 = new Node(28, (-2961), 30);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03737() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node0 = new Node(29, 42, 108);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03838() throws Throwable {
        Node node0 = new Node(122, 122, 122);
        Node node1 = new Node(30, node0, node0, node0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test03939() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(31, 31, 123);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test04040() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(122, (-671), 122);
        Node node1 = new Node(34, node0, node0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test04141() throws Throwable {
        Node node0 = new Node(74);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(36, 2, 100000);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test04242() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(122, 123, 123);
        Node node1 = new Node(37, node0, node0, node0, node0, 34, 1);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node1, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test04343() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        JSType[] jSTypeArray0 = new JSType[3];
        Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
        typeInference0.branchedFlowThrough(node0, flowScope0);
    }

    @Test(timeout = 4000)
    public void test04444() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node0 = Node.newString("Invalid token: ");
        typeInference0.branchedFlowThrough(node0, flowScope0);
    }

    @Test(timeout = 4000)
    public void test04545() throws Throwable {
        Node node0 = new Node(41);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test04646() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(111, 111, 111);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node1 = new Node(42, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04747() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node0 = new Node(43, 0, 28);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04848() throws Throwable {
        Node node0 = new Node(44);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test04949() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(101, 101, 101);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(45, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05050() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(101, 101, 101);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
        Node node1 = new Node(46, 16, 6);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05151() throws Throwable {
        Node node0 = new Node(74, 74, 74);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        Compiler compiler0 = new Compiler();
        CodingConvention codingConvention0 = compiler0.getCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node1 = new Node(47, 28, 4095);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test05252() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node((-584), (-584), (-584));
        Node node1 = new Node(48, node0, node0, node0, node0, 33, 9);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(10);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test05353() throws Throwable {
        Node node0 = new Node(122, 122, 122);
        Node node1 = new Node(49, node0, node0, node0, node0, 1, 33);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node1, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test05454() throws Throwable {
        Node node0 = new Node(52);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test05555() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(54, 54, 54);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test05656() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(56, 56, 123);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(45);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test05757() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(57);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(33);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test05858() throws Throwable {
        Node node0 = new Node(58, 58, 58);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        Vector<Scope.Var> vector0 = new Vector<Scope.Var>(5, 40);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, vector0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test05959() throws Throwable {
        Node node0 = new Node(60);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test06060() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(61, 61, 61);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        ObjectType objectType0 = jSTypeRegistry0.createObjectType("", (Node) null, (ObjectType) null);
        Scope scope0 = new Scope((Node) null, objectType0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test06161() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node0 = new Node(65, 0, 0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06262() throws Throwable {
        Node node0 = new Node(66);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test06363() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(67, 67, 67);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test06464() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(51, 118, 68);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node1 = new Node(68, 0, 0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test06565() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(69, 42, 42);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test06666() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(70);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test06767() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node0 = new Node(71, 0, 0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06868() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(73, (-2949), (-2949));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test06969() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(90);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node1 = new Node(76, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07070() throws Throwable {
        Node node0 = new Node(77);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test07171() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node((-584), (-584), (-584));
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, hashSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(79, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07272() throws Throwable {
        Node node0 = new Node(81, 81, 81);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test07373() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(82);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test07474() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node0 = Node.newString(84, ".J\\;|[=|:'l\"lIF!Gk", 114, 20);
        typeInference0.branchedFlowThrough(node0, flowScope0);
    }

    @Test(timeout = 4000)
    public void test07575() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(111, 111, 111);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node1 = new Node(85, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07676() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(87, 71, (-2533));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test07777() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(88);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test07878() throws Throwable {
        Node node0 = new Node(90, 90, 90);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test07979() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(91, 42, 42);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test08080() throws Throwable {
        Node node0 = new Node(62, 62, 62);
        Node node1 = new Node(92, node0, node0, node0, node0, (-2313), 22);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node1, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test08181() throws Throwable {
        Node node0 = new Node(94);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test08282() throws Throwable {
        Compiler compiler0 = new Compiler();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope((Node) null, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node0 = new Node(95, (-1), 117);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08383() throws Throwable {
        Node node0 = new Node(74, 74, 74);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(97);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08484() throws Throwable {
        Node node0 = new Node(98, 98, 98);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node0, flowScope0);
    }

    @Test(timeout = 4000)
    public void test08585() throws Throwable {
        Node node0 = new Node(1767, 1767, 117);
        Node node1 = new Node(102, node0, node0, 91, 47);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test08686() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(103, 103, 995);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test08787() throws Throwable {
        Node node0 = new Node(62);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(104, 31, 4);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test08888() throws Throwable {
        Node node0 = new Node(105, 105, 105);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test08989() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(103, 103, 103);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        Node node1 = new Node(106, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09090() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(107);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test09191() throws Throwable {
        Node node0 = new Node(108);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test09292() throws Throwable {
        Node node0 = new Node(165, 165, 165);
        Node node1 = new Node(109, node0, node0, node0, node0, 1, 33);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node1, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test09393() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(112, (-2003), (-1891));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention) compiler0.defaultCodingConvention;
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test09494() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(113, 113, 113);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test09595() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(111, 111, (-5));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
        Node node1 = new Node(114, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09696() throws Throwable {
        Node node0 = new Node(122, 122, 122);
        Node node1 = new Node(115, node0, node0, node0, node0, 1, 33);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node1, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test09797() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node((-117), (-117), (-117));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Node node1 = new Node(117, node0);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test09898() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(111, 111, 111);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(118, node0);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test09999() throws Throwable {
        Node node0 = new Node(74, 74, 74);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Node node1 = new Node(119, node0);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test100100() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(51, (-60), 670);
        Node node1 = new Node(121, node0, node0, 0, 12);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node1, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test101101() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(123, 5, (-3884));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
    }

    @Test(timeout = 4000)
    public void test102102() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(124);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test103103() throws Throwable {
        Node node0 = new Node(122, 122, 122);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = compiler0.parseTestCode("E2{");
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test104104() throws Throwable {
        Node node0 = new Node(81);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Node node1 = new Node(126, node0);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test105105() throws Throwable {
        Node node0 = new Node(127, 127, 122);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test106106() throws Throwable {
        Node node0 = new Node(128, 128, 128);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test107107() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(129, 71, 129);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test108108() throws Throwable {
        Node node0 = new Node(27);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Node node1 = new Node(130, node0);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test109109() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(122, 122, 122);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        JSDocInfo jSDocInfo0 = new JSDocInfo();
        node0.setJSDocInfo(jSDocInfo0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test110110() throws Throwable {
        Node node0 = new Node(1767, 1767, 117);
        Node node1 = Node.newNumber((double) 37);
        Node node2 = new Node(93, node0, node1, 89, 47);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test111111() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(18, 18, 18);
        Node node1 = new Node(37, node0, node0, node0, node0, 34, 1);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        Scope scope0 = new Scope(node1, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(4095);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test112112() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(148, 148, 148);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        CodingConvention codingConvention0 = compiler0.getCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(30, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test113113() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(96, 96, 100);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Node node1 = new Node(30, node0);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test114114() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(93, 93, 123);
        Node node1 = new Node(32);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Stack<Scope.Var> stack0 = new Stack<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, stack0);
        Node node2 = new Node(35, node1);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test115115() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node((-584), (-584), (-584));
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(35, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test116116() throws Throwable {
        Node node0 = new Node(78);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        Compiler compiler0 = new Compiler();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(100, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test117117() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(122);
        Node node1 = new Node(101, node0, node0, 1, 0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test118118() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(101, (-1), (-1));
        Node node1 = new Node(100, node0, node0, node0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        node0.addChildToBack(node1);
        ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test119119() throws Throwable {
        BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
        BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
    }
}
