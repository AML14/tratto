/*
 * This file was automatically generated by EvoSuite
 * Thu Mar 28 08:41:17 GMT 2024
 */
package com.fasterxml.jackson.databind.util;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.fasterxml.jackson.core.JsonEncoding;
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.util.BufferRecycler;
import com.fasterxml.jackson.core.util.ByteArrayBuilder;
import com.fasterxml.jackson.databind.BeanProperty;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.Module;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectReader;
import com.fasterxml.jackson.databind.PropertyMetadata;
import com.fasterxml.jackson.databind.PropertyName;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.NoClass;
import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;
import com.fasterxml.jackson.databind.deser.BeanDeserializerFactory;
import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;
import com.fasterxml.jackson.databind.introspect.TypeResolutionContext;
import com.fasterxml.jackson.databind.introspect.VirtualAnnotatedMember;
import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;
import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;
import com.fasterxml.jackson.databind.type.ArrayType;
import com.fasterxml.jackson.databind.type.CollectionLikeType;
import com.fasterxml.jackson.databind.type.CollectionType;
import com.fasterxml.jackson.databind.type.MapLikeType;
import com.fasterxml.jackson.databind.type.MapType;
import com.fasterxml.jackson.databind.type.PlaceholderForType;
import com.fasterxml.jackson.databind.type.ReferenceType;
import com.fasterxml.jackson.databind.type.ResolvedRecursiveType;
import com.fasterxml.jackson.databind.type.TypeBindings;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.fasterxml.jackson.databind.util.AccessPattern;
import com.fasterxml.jackson.databind.util.ClassUtil;
import com.fasterxml.jackson.databind.util.Named;
import java.io.Closeable;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.lang.annotation.Annotation;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Constructor;
import java.lang.reflect.Member;
import java.sql.BatchUpdateException;
import java.sql.ClientInfoStatus;
import java.sql.SQLDataException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLIntegrityConstraintViolationException;
import java.sql.SQLInvalidAuthorizationSpecException;
import java.sql.SQLNonTransientConnectionException;
import java.sql.SQLSyntaxErrorException;
import java.sql.SQLTransactionRollbackException;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFileWriter;
import org.evosuite.runtime.mock.java.io.MockIOException;
import org.evosuite.runtime.mock.java.lang.MockError;
import org.evosuite.runtime.mock.java.lang.MockRuntimeException;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class ClassUtil_ESTest extends ClassUtil_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test0000() throws Throwable {
        ClassUtil.checkAndFixAccess((Member) null);
    }

    @Test(timeout = 4000)
    public void test0011() throws Throwable {
        SQLNonTransientConnectionException sQLNonTransientConnectionException0 = new SQLNonTransientConnectionException();
        ClassUtil.unwrapAndThrowAsIAE((Throwable) sQLNonTransientConnectionException0);
    }

    @Test(timeout = 4000)
    public void test0022() throws Throwable {
        ObjectMapper objectMapper0 = new ObjectMapper();
        Class<Module> class0 = Module.class;
        ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    }

    @Test(timeout = 4000)
    public void test0033() throws Throwable {
        Class<LinkedList> class0 = LinkedList.class;
        Class<Float> class1 = Float.TYPE;
        List<Class<?>> list0 = ClassUtil.findRawSuperTypes(class0, class1, false);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test0044() throws Throwable {
        JsonFactory jsonFactory0 = new JsonFactory();
        BufferRecycler bufferRecycler0 = new BufferRecycler();
        ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0, (-1514));
        DataOutputStream dataOutputStream0 = new DataOutputStream(byteArrayBuilder0);
        JsonEncoding jsonEncoding0 = JsonEncoding.UTF16_BE;
        JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((DataOutput) dataOutputStream0, jsonEncoding0);
        BatchUpdateException batchUpdateException0 = new BatchUpdateException();
        ClassUtil.closeOnFailAndThrowAsIOE(jsonGenerator0, (Exception) batchUpdateException0);
    }

    @Test(timeout = 4000)
    public void test0055() throws Throwable {
        ClassUtil classUtil0 = new ClassUtil();
        String string0 = ClassUtil.quotedOr(classUtil0, "4?7+a&bK'Z;A]vg~V[2");
    }

    @Test(timeout = 4000)
    public void test0066() throws Throwable {
        Class<MapType> class0 = MapType.class;
        List<Class<?>> list0 = ClassUtil.findSuperTypes(class0, class0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test0077() throws Throwable {
        Class<AccessibleObject> class0 = AccessibleObject.class;
        ClassUtil.findConstructor(class0, false);
    }

    @Test(timeout = 4000)
    public void test0088() throws Throwable {
        SQLIntegrityConstraintViolationException sQLIntegrityConstraintViolationException0 = new SQLIntegrityConstraintViolationException("2p#.X}#J)j )G");
        Throwable throwable0 = ClassUtil.throwRootCauseIfIOE(sQLIntegrityConstraintViolationException0);
    }

    @Test(timeout = 4000)
    public void test0099() throws Throwable {
        Class<Error> class0 = Error.class;
        Constructor<Error> constructor0 = ClassUtil.findConstructor(class0, true);
    }

    @Test(timeout = 4000)
    public void test00910() throws Throwable {
        Class<Error> class0 = Error.class;
        Constructor<Error> constructor0 = ClassUtil.findConstructor(class0, true);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        classUtil_Ctor0.getDeclaringClass();
        constructor0.isAccessible();
    }

    @Test(timeout = 4000)
    public void test01011() throws Throwable {
        Class<TypeIdResolver> class0 = TypeIdResolver.class;
        List<JavaType> list0 = ClassUtil.findSuperTypes((JavaType) null, class0, true);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test01112() throws Throwable {
        Class<Float> class0 = Float.class;
        Class<MapLikeType> class1 = MapLikeType.class;
        TypeBindings typeBindings0 = TypeBindings.create(class1, (List<JavaType>) null);
        Class<ReferenceType> class2 = ReferenceType.class;
        ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class2, typeBindings0);
        JavaType[] javaTypeArray0 = new JavaType[6];
        javaTypeArray0[2] = (JavaType) resolvedRecursiveType0;
        CollectionType collectionType0 = CollectionType.construct((Class<?>) class2, typeBindings0, (JavaType) resolvedRecursiveType0, javaTypeArray0, javaTypeArray0[2]);
        ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, typeBindings0, (JavaType) collectionType0, javaTypeArray0, (JavaType) resolvedRecursiveType0);
        List<JavaType> list0 = ClassUtil.findSuperTypes((JavaType) referenceType0, (Class<?>) class0, true);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test01213() throws Throwable {
        Class<JsonMappingException> class0 = JsonMappingException.class;
        List<Class<?>> list0 = ClassUtil.findRawSuperTypes((Class<?>) null, class0, false);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test01314() throws Throwable {
        Class<Integer> class0 = Integer.class;
        List<Class<?>> list0 = ClassUtil.findRawSuperTypes(class0, class0, false);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test01415() throws Throwable {
        Class<Object> class0 = Object.class;
        Class<IOException> class1 = IOException.class;
        List<Class<?>> list0 = ClassUtil.findRawSuperTypes(class0, class1, false);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test01516() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        List<Class<?>> list0 = ClassUtil.findSuperClasses((Class<?>) null, class0, true);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test01617() throws Throwable {
        Class<Float> class0 = Float.class;
        List<Class<?>> list0 = ClassUtil.findSuperClasses(class0, class0, true);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test01718() throws Throwable {
        Class<Float> class0 = Float.class;
        Class<Annotation> class1 = Annotation.class;
        List<Class<?>> list0 = ClassUtil.findSuperClasses(class1, class0, false);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test01819() throws Throwable {
        Class<CollectionType> class0 = CollectionType.class;
        Class<Object> class1 = Object.class;
        List<Class<?>> list0 = ClassUtil.findSuperClasses(class0, class1, true);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test01920() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        TypeBindings typeBindings0 = TypeBindings.create(class0, (List<JavaType>) null);
        Class<Short> class1 = Short.class;
        ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class1, typeBindings0);
        JavaType[] javaTypeArray0 = new JavaType[5];
        javaTypeArray0[4] = (JavaType) resolvedRecursiveType0;
        Class<Long> class2 = Long.class;
        ReferenceType referenceType0 = ReferenceType.construct(class2, typeBindings0, javaTypeArray0[2], javaTypeArray0, javaTypeArray0[4]);
        List<JavaType> list0 = ClassUtil.findSuperTypes((JavaType) referenceType0, (Class<?>) class1, false);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test02021() throws Throwable {
        PlaceholderForType placeholderForType0 = new PlaceholderForType(129);
        ObjectMapper objectMapper0 = new ObjectMapper();
        ObjectReader objectReader0 = objectMapper0.readerFor((JavaType) placeholderForType0);
    }

    @Test(timeout = 4000)
    public void test02122() throws Throwable {
        Class<ClientInfoStatus> class0 = ClientInfoStatus.class;
        String string0 = ClassUtil.canBeABeanType(class0);
    }

    @Test(timeout = 4000)
    public void test02224() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        String string0 = ClassUtil.canBeABeanType(class0);
    }

    @Test(timeout = 4000)
    public void test02326() throws Throwable {
        Class<PlaceholderForType> class0 = PlaceholderForType.class;
        String string0 = ClassUtil.isLocalType(class0, false);
    }

    @Test(timeout = 4000)
    public void test02427() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        Class<?> class1 = ClassUtil.getOuterClass(class0);
    }

    @Test(timeout = 4000)
    public void test02528() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        boolean boolean0 = ClassUtil.isConcrete(class0);
    }

    @Test(timeout = 4000)
    public void test02629() throws Throwable {
        Class<AccessibleObject> class0 = AccessibleObject.class;
        boolean boolean0 = ClassUtil.isConcrete(class0);
    }

    @Test(timeout = 4000)
    public void test02730() throws Throwable {
        Class<AccessibleObject> class0 = AccessibleObject.class;
        Constructor<AccessibleObject> constructor0 = ClassUtil.findConstructor(class0, true);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        boolean boolean0 = ClassUtil.isConcrete((Member) classUtil_Ctor0._ctor);
    }

    @Test(timeout = 4000)
    public void test02731() throws Throwable {
        Class<AccessibleObject> class0 = AccessibleObject.class;
        Constructor<AccessibleObject> constructor0 = ClassUtil.findConstructor(class0, true);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        boolean boolean0 = ClassUtil.isConcrete((Member) classUtil_Ctor0._ctor);
        constructor0.isAccessible();
    }

    @Test(timeout = 4000)
    public void test02832() throws Throwable {
        Class<List> class0 = List.class;
        boolean boolean0 = ClassUtil.isCollectionMapOrArray(class0);
    }

    @Test(timeout = 4000)
    public void test02933() throws Throwable {
        Class<IOException> class0 = IOException.class;
        boolean boolean0 = ClassUtil.isCollectionMapOrArray(class0);
    }

    @Test(timeout = 4000)
    public void test03034() throws Throwable {
        Class<Void> class0 = Void.class;
        boolean boolean0 = ClassUtil.isBogusClass(class0);
    }

    @Test(timeout = 4000)
    public void test03135() throws Throwable {
        Class<Void> class0 = Void.TYPE;
        boolean boolean0 = ClassUtil.isBogusClass(class0);
    }

    @Test(timeout = 4000)
    public void test03236() throws Throwable {
        Class<NoClass> class0 = NoClass.class;
        boolean boolean0 = ClassUtil.isBogusClass(class0);
    }

    @Test(timeout = 4000)
    public void test03337() throws Throwable {
        Class<JsonMappingException> class0 = JsonMappingException.class;
        boolean boolean0 = ClassUtil.isBogusClass(class0);
    }

    @Test(timeout = 4000)
    public void test03438() throws Throwable {
        Class<Void> class0 = Void.TYPE;
        String string0 = ClassUtil.isLocalType(class0, true);
    }

    @Test(timeout = 4000)
    public void test03539() throws Throwable {
        Class<Object> class0 = Object.class;
        boolean boolean0 = ClassUtil.hasClass((Object) null, class0);
    }

    @Test(timeout = 4000)
    public void test03640() throws Throwable {
        TypeFactory typeFactory0 = TypeFactory.defaultInstance();
        Class<ArrayType> class0 = ArrayType.class;
        ArrayType arrayType0 = typeFactory0.constructArrayType(class0);
        boolean boolean0 = ClassUtil.hasClass(arrayType0, class0);
    }

    @Test(timeout = 4000)
    public void test03741() throws Throwable {
        Class<Object> class0 = Object.class;
        boolean boolean0 = ClassUtil.hasClass(class0, class0);
    }

    @Test(timeout = 4000)
    public void test03842() throws Throwable {
        BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
        DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
        DefaultDeserializationContext defaultDeserializationContext0 = defaultDeserializationContext_Impl0.copy();
    }

    @Test(timeout = 4000)
    public void test03943() throws Throwable {
        Class<Float> class0 = Float.class;
        SQLTransactionRollbackException sQLTransactionRollbackException0 = new SQLTransactionRollbackException();
        MockRuntimeException mockRuntimeException0 = new MockRuntimeException(sQLTransactionRollbackException0);
        ClassUtil.verifyMustOverride(class0, mockRuntimeException0, (String) null);
    }

    @Test(timeout = 4000)
    public void test04044() throws Throwable {
        SQLInvalidAuthorizationSpecException sQLInvalidAuthorizationSpecException0 = new SQLInvalidAuthorizationSpecException();
        MockError mockError0 = new MockError(sQLInvalidAuthorizationSpecException0);
        ClassUtil.throwAsIAE((Throwable) mockError0, "NyLL");
    }

    @Test(timeout = 4000)
    public void test04145() throws Throwable {
        JsonFactory jsonFactory0 = new JsonFactory();
        MockFileWriter mockFileWriter0 = new MockFileWriter("java.lang.Class@0000000001", true);
        JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((Writer) mockFileWriter0);
        BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
        DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
        Class<Boolean> class0 = Boolean.class;
        JsonMappingException jsonMappingException0 = defaultDeserializationContext_Impl0.weirdKeyException(class0, "JSON", "0dWyN22u");
        ClassUtil.closeOnFailAndThrowAsIOE(jsonGenerator0, (Closeable) jsonGenerator0, (Exception) jsonMappingException0);
    }

    @Test(timeout = 4000)
    public void test04246() throws Throwable {
        SQLTransactionRollbackException sQLTransactionRollbackException0 = new SQLTransactionRollbackException();
        SQLDataException sQLDataException0 = new SQLDataException(sQLTransactionRollbackException0);
        Throwable throwable0 = ClassUtil.getRootCause(sQLDataException0);
    }

    @Test(timeout = 4000)
    public void test04347() throws Throwable {
        BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
        DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
        MockIOException mockIOException0 = new MockIOException("xY3uryV");
        ClassUtil.throwAsMappingException((DeserializationContext) defaultDeserializationContext_Impl0, (IOException) mockIOException0);
    }

    @Test(timeout = 4000)
    public void test04448() throws Throwable {
        DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
        BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
        DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
        DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
        JsonMappingException jsonMappingException0 = JsonMappingException.from((SerializerProvider) defaultSerializerProvider_Impl0, "#)63]v9");
        ClassUtil.throwAsMappingException((DeserializationContext) defaultDeserializationContext_Impl0, (IOException) jsonMappingException0);
    }

    @Test(timeout = 4000)
    public void test04549() throws Throwable {
        SQLSyntaxErrorException sQLSyntaxErrorException0 = new SQLSyntaxErrorException("elementType");
        ClassUtil.closeOnFailAndThrowAsIOE((JsonGenerator) null, (Closeable) null, (Exception) sQLSyntaxErrorException0);
    }

    @Test(timeout = 4000)
    public void test04650() throws Throwable {
        Class<Object> class0 = Object.class;
        Object object0 = ClassUtil.createInstance(class0, false);
    }

    @Test(timeout = 4000)
    public void test04751() throws Throwable {
        Class<ArrayType> class0 = ArrayType.class;
        ClassUtil.createInstance(class0, false);
    }

    @Test(timeout = 4000)
    public void test04852() throws Throwable {
        Character character0 = new Character(' ');
        Class<?> class0 = ClassUtil.classOf(character0);
        class0.toString();
    }

    @Test(timeout = 4000)
    public void test04953() throws Throwable {
        Class<?> class0 = ClassUtil.classOf((Object) null);
    }

    @Test(timeout = 4000)
    public void test05054() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        TypeBindings typeBindings0 = TypeBindings.create(class0, (List<JavaType>) null);
        Class<Short> class1 = Short.class;
        ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class1, typeBindings0);
        Class<?> class2 = ClassUtil.rawClass(resolvedRecursiveType0);
        class2.isPrimitive();
    }

    @Test(timeout = 4000)
    public void test05155() throws Throwable {
        Class<?> class0 = ClassUtil.rawClass((JavaType) null);
    }

    @Test(timeout = 4000)
    public void test05256() throws Throwable {
        SQLFeatureNotSupportedException sQLFeatureNotSupportedException0 = new SQLFeatureNotSupportedException("Wkk6Gf!BNw|Wa", "Wkk6Gf!BNw|Wa");
        MockRuntimeException mockRuntimeException0 = new MockRuntimeException(sQLFeatureNotSupportedException0);
        RuntimeException runtimeException0 = ClassUtil.nonNull((RuntimeException) mockRuntimeException0, (RuntimeException) mockRuntimeException0);
    }

    @Test(timeout = 4000)
    public void test05357() throws Throwable {
        Character character0 = Character.valueOf('&');
        Character character1 = ClassUtil.nonNull((Character) null, character0);
    }

    @Test(timeout = 4000)
    public void test05458() throws Throwable {
        Class<Float> class0 = Float.class;
        String string0 = ClassUtil.nullOrToString(class0);
    }

    @Test(timeout = 4000)
    public void test05559() throws Throwable {
        String string0 = ClassUtil.nullOrToString((Object) null);
    }

    @Test(timeout = 4000)
    public void test05660() throws Throwable {
        String string0 = ClassUtil.nonNullString((String) null);
    }

    @Test(timeout = 4000)
    public void test05761() throws Throwable {
        String string0 = ClassUtil.quotedOr((Object) null, "3qrS?IGt");
    }

    @Test(timeout = 4000)
    public void test05862() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        String string0 = ClassUtil.getClassDescription(class0);
    }

    @Test(timeout = 4000)
    public void test05963() throws Throwable {
        String string0 = ClassUtil.getClassDescription((Object) null);
    }

    @Test(timeout = 4000)
    public void test06064() throws Throwable {
        MockError mockError0 = new MockError();
        String string0 = ClassUtil.getClassDescription(mockError0);
    }

    @Test(timeout = 4000)
    public void test06165() throws Throwable {
        Class<Float> class0 = Float.class;
        String string0 = ClassUtil.classNameOf(class0);
    }

    @Test(timeout = 4000)
    public void test06266() throws Throwable {
        String string0 = ClassUtil.classNameOf((Object) null);
    }

    @Test(timeout = 4000)
    public void test06367() throws Throwable {
        String string0 = ClassUtil.nameOf((Class<?>) null);
    }

    @Test(timeout = 4000)
    public void test06468() throws Throwable {
        Class<Short> class0 = Short.TYPE;
        String string0 = ClassUtil.nameOf(class0);
    }

    @Test(timeout = 4000)
    public void test06569() throws Throwable {
        Class<AccessibleObject> class0 = AccessibleObject.class;
        Constructor<AccessibleObject> constructor0 = ClassUtil.findConstructor(class0, true);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        PropertyName propertyName0 = PropertyName.USE_DEFAULT;
        PlaceholderForType placeholderForType0 = new PlaceholderForType((-10));
        ArrayType arrayType0 = ArrayType.construct((JavaType) placeholderForType0, (TypeBindings) null, (Object) classUtil_Ctor0, (Object) class0);
        CollectionLikeType collectionLikeType0 = CollectionLikeType.upgradeFrom(arrayType0, placeholderForType0);
        TypeFactory typeFactory0 = TypeFactory.defaultInstance();
        TypeResolutionContext.Basic typeResolutionContext_Basic0 = new TypeResolutionContext.Basic(typeFactory0, (TypeBindings) null);
        Class<Object> class1 = Object.class;
        VirtualAnnotatedMember virtualAnnotatedMember0 = new VirtualAnnotatedMember(typeResolutionContext_Basic0, class1, "org.hibernate.proxy.java.lang.reflect.AccessibleObject", arrayType0);
        PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_OPTIONAL;
        BeanProperty.Std beanProperty_Std0 = new BeanProperty.Std(propertyName0, collectionLikeType0, propertyName0, virtualAnnotatedMember0, propertyMetadata0);
        String string0 = ClassUtil.nameOf((Named) beanProperty_Std0);
        constructor0.isAccessible();
    }

    @Test(timeout = 4000)
    public void test06570() throws Throwable {
        Class<AccessibleObject> class0 = AccessibleObject.class;
        Constructor<AccessibleObject> constructor0 = ClassUtil.findConstructor(class0, true);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        PropertyName propertyName0 = PropertyName.USE_DEFAULT;
        PlaceholderForType placeholderForType0 = new PlaceholderForType((-10));
        ArrayType arrayType0 = ArrayType.construct((JavaType) placeholderForType0, (TypeBindings) null, (Object) classUtil_Ctor0, (Object) class0);
        CollectionLikeType collectionLikeType0 = CollectionLikeType.upgradeFrom(arrayType0, placeholderForType0);
        TypeFactory typeFactory0 = TypeFactory.defaultInstance();
        TypeResolutionContext.Basic typeResolutionContext_Basic0 = new TypeResolutionContext.Basic(typeFactory0, (TypeBindings) null);
        Class<Object> class1 = Object.class;
        VirtualAnnotatedMember virtualAnnotatedMember0 = new VirtualAnnotatedMember(typeResolutionContext_Basic0, class1, "org.hibernate.proxy.java.lang.reflect.AccessibleObject", arrayType0);
        PropertyMetadata propertyMetadata0 = PropertyMetadata.STD_OPTIONAL;
        BeanProperty.Std beanProperty_Std0 = new BeanProperty.Std(propertyName0, collectionLikeType0, propertyName0, virtualAnnotatedMember0, propertyMetadata0);
        String string0 = ClassUtil.nameOf((Named) beanProperty_Std0);
    }

    @Test(timeout = 4000)
    public void test06671() throws Throwable {
        String string0 = ClassUtil.nameOf((Named) null);
    }

    @Test(timeout = 4000)
    public void test06772() throws Throwable {
        String string0 = ClassUtil.backticked((String) null);
    }

    @Test(timeout = 4000)
    public void test06873() throws Throwable {
        Class<Double> class0 = Double.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test06974() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test07075() throws Throwable {
        Class<Long> class0 = Long.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test07176() throws Throwable {
        Class<Boolean> class0 = Boolean.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test07277() throws Throwable {
        Class<Character> class0 = Character.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test07378() throws Throwable {
        Class<Float> class0 = Float.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test07479() throws Throwable {
        Class<Byte> class0 = Byte.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test07580() throws Throwable {
        Class<Short> class0 = Short.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test07681() throws Throwable {
        Class<Short> class0 = Short.class;
        ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test07782() throws Throwable {
        Class<Boolean> class0 = Boolean.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test07883() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.isEnum();
    }

    @Test(timeout = 4000)
    public void test07984() throws Throwable {
        Class<Long> class0 = Long.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test08085() throws Throwable {
        Class<Byte> class0 = Byte.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test08186() throws Throwable {
        Class<Double> class0 = Double.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.isAnnotation();
    }

    @Test(timeout = 4000)
    public void test08287() throws Throwable {
        Class<Float> class0 = Float.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.getModifiers();
    }

    @Test(timeout = 4000)
    public void test08388() throws Throwable {
        Class<Character> class0 = Character.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test08489() throws Throwable {
        Class<Short> class0 = Short.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.getModifiers();
    }

    @Test(timeout = 4000)
    public void test08590() throws Throwable {
        Class<NoClass> class0 = NoClass.class;
        ClassUtil.wrapperType(class0);
    }

    @Test(timeout = 4000)
    public void test08691() throws Throwable {
        Class<JsonMappingException> class0 = JsonMappingException.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test08792() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.isEnum();
    }

    @Test(timeout = 4000)
    public void test08893() throws Throwable {
        Class<Integer> class0 = Integer.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test08894() throws Throwable {
        Class<Integer> class0 = Integer.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.isPrimitive();
    }

    @Test(timeout = 4000)
    public void test08995() throws Throwable {
        Class<Long> class0 = Long.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test08996() throws Throwable {
        Class<Long> class0 = Long.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test09097() throws Throwable {
        Class<Boolean> class0 = Boolean.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test09098() throws Throwable {
        Class<Boolean> class0 = Boolean.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test09199() throws Throwable {
        Class<Double> class0 = Double.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test091100() throws Throwable {
        Class<Double> class0 = Double.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test092101() throws Throwable {
        Class<Float> class0 = Float.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test092102() throws Throwable {
        Class<Float> class0 = Float.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test093103() throws Throwable {
        Class<Byte> class0 = Byte.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test093104() throws Throwable {
        Class<Byte> class0 = Byte.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test094105() throws Throwable {
        Class<Short> class0 = Short.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test094106() throws Throwable {
        Class<Short> class0 = Short.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test095107() throws Throwable {
        Class<Character> class0 = Character.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test095108() throws Throwable {
        Class<Character> class0 = Character.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test096109() throws Throwable {
        Class<NoClass> class0 = NoClass.class;
        Constructor<NoClass> constructor0 = ClassUtil.findConstructor(class0, true);
        ClassUtil.checkAndFixAccess((Member) constructor0, false);
        constructor0.isAccessible();
    }

    @Test(timeout = 4000)
    public void test097110() throws Throwable {
        Class<RuntimeException> class0 = RuntimeException.class;
        Constructor<RuntimeException> constructor0 = ClassUtil.findConstructor(class0, false);
        ClassUtil.checkAndFixAccess((Member) constructor0, false);
        constructor0.isAccessible();
    }

    @Test(timeout = 4000)
    public void test098111() throws Throwable {
        AccessPattern accessPattern0 = AccessPattern.CONSTANT;
        EnumSet<AccessPattern> enumSet0 = EnumSet.of(accessPattern0);
        Class<? extends Enum<?>> class0 = ClassUtil.findEnumType(enumSet0);
        class0.getModifiers();
    }

    @Test(timeout = 4000)
    public void test099112() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        EnumMap<AccessPattern, Void> enumMap0 = new EnumMap<AccessPattern, Void>(class0);
        Class<? extends Enum<?>> class1 = ClassUtil.findEnumType(enumMap0);
        class1.isSynthetic();
    }

    @Test(timeout = 4000)
    public void test100113() throws Throwable {
        Class<ClientInfoStatus> class0 = ClientInfoStatus.class;
        EnumMap<ClientInfoStatus, Object> enumMap0 = new EnumMap<ClientInfoStatus, Object>(class0);
        ClientInfoStatus clientInfoStatus0 = ClientInfoStatus.REASON_VALUE_INVALID;
        enumMap0.put(clientInfoStatus0, (Object) class0);
        Class<? extends Enum<?>> class1 = ClassUtil.findEnumType(enumMap0);
        class1.isEnum();
    }

    @Test(timeout = 4000)
    public void test101114() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        Class<? extends Enum<?>> class1 = ClassUtil.findEnumType(class0);
        class1.getModifiers();
    }

    @Test(timeout = 4000)
    public void test102115() throws Throwable {
        Class<InputStream> class0 = InputStream.class;
        Class<? extends Enum<?>> class1 = ClassUtil.findEnumType(class0);
        class1.getModifiers();
    }

    @Test(timeout = 4000)
    public void test103116() throws Throwable {
        ObjectMapper objectMapper0 = new ObjectMapper();
        Class<ClientInfoStatus> class0 = ClientInfoStatus.class;
        ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    }

    @Test(timeout = 4000)
    public void test104117() throws Throwable {
        boolean boolean0 = ClassUtil.isJacksonStdImpl((Object) null);
    }

    @Test(timeout = 4000)
    public void test105118() throws Throwable {
        PlaceholderForType placeholderForType0 = new PlaceholderForType(129);
        boolean boolean0 = ClassUtil.isJacksonStdImpl((Object) placeholderForType0);
    }

    @Test(timeout = 4000)
    public void test106119() throws Throwable {
        Class<Character> class0 = Character.TYPE;
        String string0 = ClassUtil.getPackageName(class0);
    }

    @Test(timeout = 4000)
    public void test107120() throws Throwable {
        Class<Annotation> class0 = Annotation.class;
        ClassUtil.Ctor[] classUtil_CtorArray0 = ClassUtil.getConstructors(class0);
    }

    @Test(timeout = 4000)
    public void test108121() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        ClassUtil.Ctor[] classUtil_CtorArray0 = ClassUtil.getConstructors(class0);
    }

    @Test(timeout = 4000)
    public void test109122() throws Throwable {
        Class<CollectionType> class0 = CollectionType.class;
        Class<?> class1 = ClassUtil.getDeclaringClass(class0);
    }

    @Test(timeout = 4000)
    public void test110123() throws Throwable {
        Class<Object> class0 = Object.class;
        Class<?> class1 = ClassUtil.getDeclaringClass(class0);
    }

    @Test(timeout = 4000)
    public void test111124() throws Throwable {
        Class<Object> class0 = Object.class;
        Class<?> class1 = ClassUtil.getOuterClass(class0);
    }

    @Test(timeout = 4000)
    public void test112125() throws Throwable {
        Class<IOException> class0 = IOException.class;
        Constructor<IOException> constructor0 = ClassUtil.findConstructor(class0, false);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        classUtil_Ctor0.getDeclaredAnnotations();
        Annotation[] annotationArray0 = classUtil_Ctor0.getDeclaredAnnotations();
    }

    @Test(timeout = 4000)
    public void test112126() throws Throwable {
        Class<IOException> class0 = IOException.class;
        Constructor<IOException> constructor0 = ClassUtil.findConstructor(class0, false);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        classUtil_Ctor0.getDeclaredAnnotations();
        Annotation[] annotationArray0 = classUtil_Ctor0.getDeclaredAnnotations();
        constructor0.isAccessible();
    }

    @Test(timeout = 4000)
    public void test113127() throws Throwable {
        Class<String> class0 = String.class;
        Constructor<String> constructor0 = ClassUtil.findConstructor(class0, true);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        classUtil_Ctor0.getParameterAnnotations();
        classUtil_Ctor0.getParameterAnnotations();
        constructor0.isAccessible();
    }
}
