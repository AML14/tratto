/*
 * This file was automatically generated by EvoSuite
 * Sat Nov 04 08:58:11 GMT 2023
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.LoggerErrorManager;
import com.google.javascript.jscomp.MessageFormatter;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.Tracer;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Logger;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test0000() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gmj5z", "j_Gmj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("t@dl=I");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("t@dl=I", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(101, node0, node0, node0, 4095, 139);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0011() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(33, node0, node0, node0, 3396, (-2376));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0022() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(22, 4046, 100);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test0033() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        typeInference0.analyze();
    }

    @Test(timeout = 4000)
    public void test0044() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(100, 125, 128);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0055() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = new Node(30, node0, node0, node0, 37, (-830));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    }

    @Test(timeout = 4000)
    public void test0066() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
        FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test0077() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
        controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test0088() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("jGE", "jGE");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("jGE", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
        controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0099() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
        controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01010() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(4, node0, node0, node0, 48, 15);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01111() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(5, 30, 47);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01212() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(8, 56, 116);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01313() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("protoype", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("}3<^YjMW\"Nzy", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(12, 12, 2309);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01414() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(14, 143, 52);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01515() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("&", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("UNCOND", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(15, 16, 46);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01616() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("jGE", "jGE");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("jGE", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(16, 16, 1);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01717() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(18, 4046, 40);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01818() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(20, 144, 148);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01919() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        Node node1 = new Node(21, 119, 148);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02020() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(27, 148, 148);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02121() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(28, 37, (-2481));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02222() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        Node node1 = new Node(29, 400000, 16);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02323() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(31, 1, 49);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02424() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("-j_Gj5z", "-j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(32, node0, node0, node0, 32, 46);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02525() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(36, 109, 108);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02626() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(37, node0, node0, node0, 15, 147);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02727() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(39, 54, 4095);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02828() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString("Object#Element");
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02929() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("UNCOND", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        Node node1 = new Node(41, 1, 49);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03030() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(42, node0, node0, node0, 51, 15);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03131() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Glj7z", "j_Glj7z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Glj7z");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Glj7z", codingConvention_AssertionFunctionSpec0);
        Node node1 = new Node(43, 4, 144);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03232() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(46, 110, 32);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03333() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("q_GJ5z", "q_GJ5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(47, 399, 31);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03434() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(48, 55, 31);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03535() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(49, 4095, (-2873));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03636() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(50, 4, 4);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03737() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(51, node0, node0, node0, 4, 105);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03838() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Y", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$1", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(52, (-628), 54);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03939() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Glj7z", "j_Glj7z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("4L9BD/1(b&4<pq/%nL;");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("JSC_UNLISTEN_WITH_ANONBOUND", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(53, node0, node0, node0, 43, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04040() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(54, 143, 31);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04141() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(55, 119, 48);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04242() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(56, 4095, 54);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04343() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("jGE", "jGE");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("jGE", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(57, 134, 12);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04444() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(61, 114, 148);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04545() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("cm.google;javascript.jscomp.TypeInference");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("cm.google;javascript.jscomp.TypeInference", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(65, node0, node0, node0, 4095, 65);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04646() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(68, node0, node0, node0, 4095, 68);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04747() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_u5", "j_u5");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("KeOp?+rd%q;~&rzf}", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(69, node0, node0, node0, 1483, 1068);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04848() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(70, 42, 57);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04949() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(74, node0, node0, node0, 4095, 74);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05050() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(78, node0, node0, node0, 4095, 78);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05151() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Glj7z", "j_Glj7z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("JSC_UNLISTEN_WITH_ANONBOUnD");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("JSC_UNLISTEN_WITH_ANONBOUnD", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(79, 118, 40);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05252() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("t@dl=I");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("t@dl=I", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(81, node0, node0, node0, 4095, 12);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05353() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("?ZuWgrMe", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
        TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        JSType[] jSTypeArray0 = new JSType[4];
        Node node1 = jSTypeRegistry0.createParameters(jSTypeArray0);
        typeInference1.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test05454() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(84, 2, 135);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05555() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("q_GJ5z", "q_GJ5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        Node node1 = new Node(89, 32, 1);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05656() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_R5L", "j_R5L");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_R5L");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("JSC_UNLISTEN_WITH_ANONBOUND", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(90, 1023, 47);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05757() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        Node node1 = new Node(91, 3467, 50);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05858() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("okR|?pE+W", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(92, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05959() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(93, (-697), 400000);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06060() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("t@dl=I");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("t@dl=I", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(97, node0, node0, node0, 4095, 139);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06161() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(98, (-30), 16);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06262() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("t@dl=I");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("t@dl=I", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(99, node0, node0, node0, 4095, 139);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06363() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(102, 150, 36);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06464() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(103, node0, node0, node0, 4095, 103);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06565() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(105, node0, node0, node0, 4095, 12);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06666() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("t@dl=I");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("t@dl=I", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(106, node0, node0, node0, 4095, 139);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06767() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        Node node1 = new Node(107, 30, 70);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06868() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$TemplateTypeReplcer", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(109, 4095, 1017);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06969() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(110, (-2448), (-1075));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07070() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(111, 30, 47);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07171() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null, jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("a+", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(112, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07272() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(113, 4095, 39);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07373() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("q_GJ5z", "q_GJ5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("%N~PZq<8K_$/<md", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(114, 38, (-3635));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07474() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gmj5z", "j_Gmj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("t@dl=I");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("t@dl=I", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(115, 32, 52);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07575() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("{>5;*)#D", "com.google.javascript.jscomp.CreateSyntheticBlocks");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Glj7z", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(117, 1071, 42);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07676() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(118, 703, 56);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07777() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("a3<^YjMWnN,zy", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(119, 116, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07878() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(120, node0, node0, node0, 180, 52);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07979() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Glj7z", "j_Glj7z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Glj7z");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Glj7z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(121, 139, 16);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08080() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        Node node1 = new Node(122, 3467, 50);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08181() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("jGE", "jGE");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("jGE", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        Node node1 = new Node(123, node0, node0, node0, 52, 154);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08282() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInfrece");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInfrece", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        Node node1 = new Node(124, node0, node0, node0, 2, 48);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08383() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("JSC_UNLISTEN_WITH_ANONBOUND", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(125, 125, 108);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08484() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("JSC_UNLISTEN_WITH_ANONBOUND", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(126, 15, 128);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08585() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(127, 4095, 1);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08686() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(128, 12, 139);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08787() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        Node node1 = new Node(130, node0, node0, node0, 2, 48);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08888() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(131, 38, 140);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08989() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(133, 29, 43);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09090() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("protoype", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("a3<^YjMWnN,zy", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(134, node0, node0, node0, 1, 107);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09191() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("t@dl=I");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("t@dl=I", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(135, node0, node0, node0, 4711, 5);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09292() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(136, 617, 1841);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09393() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        Node node1 = new Node(137, 759, 42);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09494() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(138, 139, 4095);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09595() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(139, 4095, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09696() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(140, (-2553), 1);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09797() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_STRING_BOOLEAN;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(141, 143, 2);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09898() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("F&g+`z6%CA@J");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter$2", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(142, 51, 54);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09999() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(143, 400000, (-1614));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test100100() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("jQuerySub.fn", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(144, 2138, (-3163));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test101101() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("|75Zr:K_uylp}.MD2v");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("|75Zr:K_uylp}.MD2v", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(145, 48, (-1173));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test102102() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        Node node1 = new Node(147, 52, 1119);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test103103() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(148, 36, 51);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test104104() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(149, 151, 3);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test105105() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.GlobalVarReferenceMap", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(150, (-1813), 49);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test106106() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(151, 1365, 118);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test107107() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$TemplateTypeReplcer", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        Node node1 = new Node(152, 29, 4378);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test108108() throws Throwable {
        Logger logger0 = Tracer.logger;
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseSyntheticCode("j_Glj7z", "j_Glj7z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Glj7z");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Glj7z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(154, 0, (-1553));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test109109() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Gj5z", "j_Gj5z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("j_Gj5z");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("j_Gj5z", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(155, 54, 4095);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test110110() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UNCOND");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(1931, 29, 50);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test111111() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("UNCOND", "UNCOND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(4, 143, 52);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test112112() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("j_Glj7z", "j_Glj7z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("419BD/1(b&4<pq/w%nL;");
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("JSC_UNLISTEN_WITH_ANONBOUND", codingConvention_AssertionFunctionSpec0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(30, 114, 2);
        node1.addChildToFront(node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test113113() throws Throwable {
        BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
        BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
    }

    @Test(timeout = 4000)
    public void test114114() throws Throwable {
        BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
        BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
    }
}
