/*
 * This file was automatically generated by EvoSuite
 * Sat Nov 04 01:48:55 GMT 2023
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.FlowScope;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.Normalize;
import com.google.javascript.jscomp.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.rhino.ErrorReporter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.ObjectType;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test0000() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "pG!x=Riw'Ti", "pG!x=Riw'Ti");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        Node node1 = new Node(100, node0, node0, node0, 12, 40);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0011() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.common.collect.ExplicitOrdering", "nmn%L;S\"|f|M{l+");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = node0.removeChildren();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0022() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "ND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        node0.setJSType(objectType0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(101, node0, node0, node0, 106, 39);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0033() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ")q", ")q");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(120, node0, node0, node0, 8, 8);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0044() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(86, node0, node0, node0, 51, 4095);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test0055() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(63, node0, node0, node0, 0, 50);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0066() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$J#w+k+j", "6$J#w+k+j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
    }

    @Test(timeout = 4000)
    public void test0077() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
        controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test0088() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$#w++j", "6$#w++j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
        controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        Scope scope0 = new Scope(node0, objectType0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0099() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$#w++j", "6$#w++j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
        controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        Scope scope0 = new Scope(node0, objectType0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node0, flowScope0);
    }

    @Test(timeout = 4000)
    public void test01010() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(5, node0, node0, node0, 16, 4095);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01111() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "e6 Yy@,S8A\"ab", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(6, "Not declared as a constructor", 1437, 48);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01212() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompilblias_VGOID", "JSCompilblias_VGOID");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(7, node0, node0, node0, 37, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01313() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$#w++j", "6$#w++j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(8, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01414() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(9, node0, node0, node0, (-978), 130);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01515() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$J#w+k+j", "6$J#w+k+j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(10, "qitCjDXNt}RZ4}w", (-1), 4095);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01616() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "q9NGnT=Be", "q9NGnT=Be");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(11, "q9NGnT=Be", 4095, 50);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01717() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("9");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(12, "Named type with empty name component", 48, 50);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01818() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$<uW`Puq-00", "$<uW`Puq-00");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(13, node0, node0, node0, 3, 2129);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01919() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$#w++j", "6$#w++j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(15, node0, node0, node0, 49, 54);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test02020() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$#w++j", "6$#w++j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(16, 53, 35);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test02121() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$", "$");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(17, node0, node0, node0, 200000, 30);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02222() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSComH9lbliaZ_VGOID", "JSComH9lbliaZ_VGOID");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(19, node0, node0, node0, 37, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02323() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "q9NGnT=Be", "q9NGnT=Be");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(20, "q9NGnT=Be", 4095, 50);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02424() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$<uAW?MPuq-<0,", "$<uAW?MPuq-<0,");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(24, "$<uAW?MPuq-<0,", 4095, 50);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02525() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSComH9lbliaZ_VGOID", "JSComH9lbliaZ_VGOID");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(25, node0, node0, node0, 37, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02626() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(26, node0, node0, node0, 32, 29);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02727() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "f0~P6rd7fI{!", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(27, node0, node0, node0, 39, 1843);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02828() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompilblias_VGOID", "JSCompilblias_VGOID");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(28, node0, node0, node0, 37, 2);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test02929() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("JSCompile_liasR_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(29, node0, node0, node0, 46, 200000);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test03030() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "X", "X");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(31, node0, 47, 39);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03131() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "9", "9");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(32, "Named type with empty name component");
        Node node2 = new Node(93, node0, node0, node1, 0, 1);
        FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03232() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$", "$");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(34, node0, node0, node0, 15, 46);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03333() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(36, node0, node0, node0, 1, 44);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test03434() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = Node.newNumber((double) 0, 114, 1257);
        Node node2 = new Node(30, node0, node0, node1, 95, 301);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03535() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("%b-a`f^Mx?F# n4_");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(41, node0, node0, node0, 38, 46);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03636() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "IG9N#", "IG9N#");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(42, node0, node0, node0, 49, 39);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03737() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(43, node0, node0, node0, 52, 129);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03838() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("$<u?MPuq-<0,", "$<u?MPuq-<0,");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(44, node0, node0, node0, 0, 2);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03939() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$J#w+k+j", "6$J#w+k+j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(45, node0, node0, 54, 54);
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test04040() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("%b-a`f^Mx?F# n4_");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(46, node0, node0, node0, 52, (-948));
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04141() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$w+k+j", "$w+k+j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(47, node0, node0, node0, 35, 45);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04242() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "9", "9");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(48, node0, node0, node0, 200000, 122);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04343() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "2", "2");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(49, node0, node0, node0, 37, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04444() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$#w+k+j", "6$#w+k+j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(50, node0, node0, node0, 40, 41);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test04545() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$#w++j", "6$#w++j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(51, node0, node0, node0, 1, 44);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test04646() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$", "$");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(52, node0, node0, node0, 15, 46);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test04747() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "e6 Yy@,S8A\"ab", "e6 Yy@,S8A\"ab");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(53, node0, node0, node0, 30, 53);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test04848() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(54, node0, node0, node0, 51, 4095);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test04949() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(55, node0, node0, node0, 0, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05050() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$#w++j", "6$#w++j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(56, node0, node0, node0, 2, 54);
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test05151() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$J#w+k+j", "6$J#w+k+j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(57, node0, node0, node0, 46, (-757));
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05252() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("$<u?MPuq-<0,", "$<u?MPuq-<0,");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(58, node0, node0, node0, 758, 5);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05353() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$", "$");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(59, node0, node0, node0, 15, 46);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05454() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(60, node0, node0, node0, 88, (-2291));
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05555() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$<u?MPuq-<0,", "$<u?MPuq-<0,");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(61, node0, node0, node0, 0, 2);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test05656() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(62, node0, node0, node0, 4095, 39);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05757() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("%b-a`f^Mx?F# n4_");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(65, node0, node0, node0, 38, 46);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05858() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$#w++j", "6$#w++j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(66, node0, node0, node0, 1, 44);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05959() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "9", "9");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(67, node0, node0, node0, 43, 4095);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06060() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "e6 Yy@,S8A\"ab", "e6 Yy@,S8A\"ab");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(68, node0, node0, node0, 30, 137);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06161() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(69, "Not declared as a type name", 2, 1);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06262() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("%b-a`f^Mx?F# n4_");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(70, node0, node0, node0, 38, 46);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06363() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$", "$");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(71, node0, node0, node0, 15, 46);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test06464() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$<uAW?MPuq-<0,", "$<uAW?MPuq-<0,");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>(treeMap0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashMap0);
        Node node1 = new Node(72, node0, node0, node0, 2874, 52);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test06565() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$<u?MPuq-<0,", "$<u?MPuq-<0,");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(73, node0, node0, node0, 0, 2);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test06666() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(74, node0, node0, node0, 1, 44);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06767() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "ND");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(75, node0, node0, node0, 106, 39);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06868() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ";:_?@'dT(Xd7%c@", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(76, node0, node0, node0, 44, 3);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test06969() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(77, node0, node0, node0, 1, 44);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07070() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSqompiler_alias_VOSD", "JSqompiler_alias_VOSD");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(78, node0, node0, node0, 54, 46);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07171() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(79, node0, node0, 4, 47);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07272() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "e6 Yy@,S8A\"ab", "e6 Yy@,S8A\"ab");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(80, node0, node0, node0, 0, 50);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07373() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "IG9Na#", "IG9Na#");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(81, node0, node0, node0, 52, 35);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07474() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "9", "9");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(82, "Unknown class name", 3, 111);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07575() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompilblias_VGOID", "JSCompilblias_VGOID");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        Node node1 = jSTypeRegistry0.createParameters((List<JSType>) linkedList0);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test07676() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(84, node0, node0, node0, 84, 36);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07777() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSComH9lbliaZ_VGOID", "JSComH9lbliaZ_VGOID");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(85, node0, node0, node0, 37, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07878() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(87, node0, node0, node0, 1, 44);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test07979() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$<uW`Puq-00,", "$<uW`Puq-00,");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(88, "Named type with empty name component", 36, 54);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08080() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = Node.newString(89, "", 47, 49);
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test08181() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(90, node0, node0, node0, 124, 30);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test08282() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(91, node0, node0, node0, 1, 44);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08383() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$w+k+j", "$w+k+j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(92, node0, node0, node0, 36, 36);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08484() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6k#p+j", "6k#p+j");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(94);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08585() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$<u?MPuq-<0,", "$<u?MPuq-<0,");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(95, node0, node0, node0, 0, 2);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test08686() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$#w++j", "6$#w++j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(96, node0, node0, node0, 39, 35);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test08787() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "9", "9");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(97, node0, node0, node0, 0, 1);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08888() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$#w++j", "6$#w++j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(98, node0, node0, node0, 1, 44);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test08989() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("%b-a`f^Mx?F# n4_");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(99, node0, node0, node0, 38, 46);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09090() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(102, node0, node0, 4, 47);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09191() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(103, node0, node0, node0, 1, 44);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09292() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(104, node0, node0, node0, 1, 44);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09393() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ":#e?=v~T%o", ":#e?=v~T%o");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(105, node0, node0, node0, 50, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09494() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(106, node0, node0, node0, 120, 53);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test09595() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(107, node0, node0, node0, 1, 44);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09696() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$<uW`Puq-00", "$<uW`Puq-00");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(108, "$<uW`Puq-00", 4095, 50);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09797() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(109, node0, node0, node0, 32, 52);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09898() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(110, node0, node0, node0, 30, 38);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test09999() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$<u?MPuq-<0,", "$<u?MPuq-<0,");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(111, node0, node0, node0, 0, 2);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test100100() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(112, node0, node0, node0, 1, 44);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test101101() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "e6 Yy@,S8A\"ab", "e6 Yy@,S8A\"ab");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(113, node0, node0, node0, 0, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test102102() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Root module '{0}' must contain at least one source code input", "Root module '{0}' must contain at least one source code input");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(114, "Function literal argument refers to undefined this argument", 49, (-1311));
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test103103() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$<u?MPuq-<0,", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(115, node0, node0, node0, 0, 2);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test104104() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompilblias_VGOID", "JSCompilblias_VGOID");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(116, node0, node0, node0, 0, 50);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test105105() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("6$#w++=");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(117, node0, node0, node0, 119, 30);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test106106() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("$<u?MPuq-<0,", "$<u?MPuq-<0,");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(118, node0, node0, node0, 735, 31);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test107107() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(119, node0, node0, node0, 2092, 53);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test108108() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "9", "9");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(121, node0, node0, node0, 54, 39);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test109109() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler@alpas_VOID", "JSCompiler@alpas_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(122, node0, node0, node0, 51, 4095);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test110110() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSComH9lbliaZ_VGOID", "JSComH9lbliaZ_VGOID");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(123, node0, node0, node0, 46, 51);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test111111() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(124, node0, node0, node0, 8, 8);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test112112() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6$J#w+k+j", "6$J#w+k+j");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(125, node0, node0, node0, (-2088), 4);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test113113() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(126, node0, node0, node0, 1, 44);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test114114() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$<u?MPuq-<0,", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(127, node0, node0, node0, 32, 2);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test115115() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSComH9lbliaZ_VGOID", "JSComH9lbliaZ_VGOID");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(128, node0, node0, node0, 37, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test116116() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "e6 Yy@,S8A\"ab", "e6 Yy@,S8A\"ab");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(129, "I^u5S", (-2666), (-48));
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test117117() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$", "$");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = node0.removeChildren();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test118118() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        node0.addSuppression("Not declared as a constructor");
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test119119() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("6k#p+j");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(4, node0, node0, node0, 42, 54);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test120120() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6k#p+j", "6k#p+j");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(4, node0, node0, node0, 42, 54);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        node0.setJSType(objectType0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test121121() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("$<u?MPuq-<0,", "$<u?MPuq-<0,");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(64, node0, node0, node0, 0, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        node1.setJSType(objectType0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test122122() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "9", "9");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(4, "Not declared as a type name", 29, 16);
        Node node2 = new Node(93, node0, node0, node1, 0, 1);
        node0.setJSType(objectType0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
        objectType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test122123() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "9", "9");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(4, "Not declared as a type name", 29, 16);
        Node node2 = new Node(93, node0, node0, node1, 0, 1);
        node0.setJSType(objectType0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test123124() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_alias_VOID", "JSCompiler_alias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        Node node1 = new Node(37, node0, node0, node0, 2704, 100);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashMap0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test124125() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_aias_VOID", "JSCompiler_aias_VOID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
        doReturn(36, 0).when(comparator0).compare(any(), any());
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>(comparator0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Not declared as a constructor", jSTypeNative0);
        treeMap0.putIfAbsent("jv=)+(TOj+1Su", codingConvention_AssertionFunctionSpec0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(37, node0, node0, 41, 54);
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test125126() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_aiaS_VOpD", "JSCompiler_aiaS_VOpD");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
        doReturn(36, 0).when(comparator0).compare(any(), any());
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>(comparator0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Not declared as a constructor");
        treeMap0.putIfAbsent("jv=)+(TOj+1Su", codingConvention_AssertionFunctionSpec0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_aiaS_VOpD", "JSCompiler_aiaS_VOpD");
        Node node2 = new Node(37, node1, node0, 47, 54);
        FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
    }

    @Test(timeout = 4000)
    public void test126127() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_aiaS_VOpD", "JSCompiler_aiaS_VOpD");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
        doReturn(36, 0).when(comparator0).compare(any(), any());
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>(comparator0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Not declared as a constructor", jSTypeNative0);
        treeMap0.putIfAbsent("jv=)+(TOj+1Su", codingConvention_AssertionFunctionSpec0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = Normalize.parseAndNormalizeTestCode(compiler0, "JSCompiler_aiaS_VOpD", "JSCompiler_aiaS_VOpD");
        Node node2 = new Node(37, node1, node0, 47, 54);
        FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
    }

    @Test(timeout = 4000)
    public void test127128() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ".", ".");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(30, node0, node0, node0, 42, 4084);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        node0.setJSType(objectType0);
        typeInference0.flowThrough(node1, linkedFlowScope0);
        objectType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test128129() throws Throwable {
        BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
        BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
    }

    @Test(timeout = 4000)
    public void test129130() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "2", "2");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Scope scope0 = new Scope(node0, objectType0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Node node1 = new Node(35, node0, node0, node0, 12, 47);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        node0.setJSType(objectType0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }
}
