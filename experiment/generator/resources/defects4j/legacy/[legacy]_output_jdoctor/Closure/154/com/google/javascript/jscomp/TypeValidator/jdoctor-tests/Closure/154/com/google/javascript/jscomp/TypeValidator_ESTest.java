/*
 * This file was automatically generated by EvoSuite
 * Sun Nov 19 23:13:59 GMT 2023
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.Denormalize;
import com.google.javascript.jscomp.FlowSensitiveInlineVariables;
import com.google.javascript.jscomp.GatherRawExports;
import com.google.javascript.jscomp.GroupVariableDeclarations;
import com.google.javascript.jscomp.JSSourceFile;
import com.google.javascript.jscomp.NameReferenceGraph;
import com.google.javascript.jscomp.NameReferenceGraphConstruction;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.ReferenceCollectingCallback;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.ScopeCreator;
import com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TypeCheck;
import com.google.javascript.jscomp.TypeValidator;
import com.google.javascript.jscomp.UnfoldCompoundAssignments;
import com.google.javascript.jscomp.UnreachableCodeElimination;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.EnumElementType;
import com.google.javascript.rhino.jstype.EnumType;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.InstanceObjectType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.NoType;
import com.google.javascript.rhino.jstype.NullType;
import com.google.javascript.rhino.jstype.ObjectType;
import com.google.javascript.rhino.jstype.UnknownType;
import java.nio.charset.Charset;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeValidator_ESTest extends TypeValidator_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test000() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode(" nl \"rrays*Or ob1ecFsca ce acce(sed", " nl \"rrays*Or ob1ecFsca ce acce(sed");
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, "Named type with empty name component", jSType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test001() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode(" nl \"rrays*Or ob1ecFsca ce acce(sed", " nl \"rrays*Or ob1ecFsca ce acce(sed");
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, "Named type with empty name component", jSType0);
    }

    @Test(timeout = 4000)
    public void test012() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseTestCode("`JXDCZ[.t:M[!2?B8X");
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        Iterable<TypeValidator.TypeMismatch> iterable0 = typeValidator0.getMismatches();
    }

    @Test(timeout = 4000)
    public void test023() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseTestCode("!");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
        String string0 = typeValidator_TypeMismatch0.toString();
    }

    @Test(timeout = 4000)
    public void test034() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, jSType0, "Not declared as a type name");
    }

    @Test(timeout = 4000)
    public void test045() throws Throwable {
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("!");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0, (ScopeCreator) null);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, jSType0, "Named type with empty name component");
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test046() throws Throwable {
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("!");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0, (ScopeCreator) null);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, jSType0, "Named type with empty name component");
    }

    @Test(timeout = 4000)
    public void test057() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectActualObject((NodeTraversal) null, node0, noType0, "Unknown class name");
        noType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test068() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        NullType nullType0 = (NullType) jSTypeRegistry0.createDefaultObjectUnion(noType0);
        typeValidator0.expectActualObject(nodeTraversal0, node0, nullType0, "t'ptp$Gy");
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test069() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        NullType nullType0 = (NullType) jSTypeRegistry0.createDefaultObjectUnion(noType0);
        typeValidator0.expectActualObject(nodeTraversal0, node0, nullType0, "t'ptp$Gy");
        noType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test0710() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("");
        ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
        ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
        typeValidator0.expectAnyObject(nodeTraversal0, node0, functionType0, "Named type with empty name component");
        functionType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test0811() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
        typeValidator0.expectAnyObject(nodeTraversal0, node0, noType0, "Named type with empty name component");
        noType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test0912() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("~,,[QIF.L&A");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0, syntacticScopeCreator0);
        JSType jSType1 = jSTypeRegistry0.createOptionalType(jSType0);
        typeValidator0.expectAnyObject(nodeTraversal0, node0, jSType1, "Named type with empty name component");
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test1013() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
        InstanceObjectType instanceObjectType0 = (InstanceObjectType) jSTypeRegistry0.getNativeType(jSTypeNative0);
        GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
        typeValidator0.expectIndexMatch(nodeTraversal0, node0, instanceObjectType0, noType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test1014() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
        InstanceObjectType instanceObjectType0 = (InstanceObjectType) jSTypeRegistry0.getNativeType(jSTypeNative0);
        GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
        typeValidator0.expectIndexMatch(nodeTraversal0, node0, instanceObjectType0, noType0);
        noType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test1115() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        typeValidator0.expectIndexMatch((NodeTraversal) null, node0, jSType0, jSType0);
    }

    @Test(timeout = 4000)
    public void test1216() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Unknown class name");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        FlowSensitiveInlineVariables flowSensitiveInlineVariables0 = new FlowSensitiveInlineVariables(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, flowSensitiveInlineVariables0, (ScopeCreator) null);
        typeValidator0.expectBitwiseable(nodeTraversal0, node0, jSType0, "^#");
    }

    @Test(timeout = 4000)
    public void test1317() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectBitwiseable(nodeTraversal0, node0, functionType0, "Not declared as a type name");
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test1318() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectBitwiseable(nodeTraversal0, node0, functionType0, "Not declared as a type name");
        functionType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test1419() throws Throwable {
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("!");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0, (ScopeCreator) null);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        typeValidator0.expectBitwiseable(nodeTraversal0, node0, jSType0, "Not declared as a constructor");
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test1520() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Unknown class name");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
        typeValidator0.expectStringOrNumber(nodeTraversal0, node0, jSType0, "Not declared as a type name");
    }

    @Test(timeout = 4000)
    public void test1621() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("");
        ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
        ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
        JSType jSType0 = jSTypeRegistry0.createNamedType("Not declared as a constructor", "Unknown class name", 49, 1);
        typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, functionType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test1722() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        compiler0.parseTestCode("Unknown class name");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Not declared as a constructor", jSType0);
        typeValidator0.expectStringOrNumber(nodeTraversal0, (Node) null, enumType0, "Not declared as a type name");
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test1823() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Unknown class name");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        boolean boolean0 = typeValidator0.expectNotNullOrUndefined((NodeTraversal) null, node0, jSType0, "Named type with empty name component", jSType0);
    }

    @Test(timeout = 4000)
    public void test1924() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Attempt to remove() an extern definition.");
        ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
        ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.CHECKED_UNKNOWN_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, "/J_G4NIDGVp#", jSType0);
    }

    @Test(timeout = 4000)
    public void test2025() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode(" nl \"rrays*Or ob1ecFsca ce acce(sed", " nl \"rrays*Or ob1ecFsca ce acce(sed");
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
        boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, functionType0, "Unknown class name", functionType0);
    }

    @Test(timeout = 4000)
    public void test2126() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Unknown class name");
        JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
        boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, "Not declared as a constructor", (JSType) null);
    }

    @Test(timeout = 4000)
    public void test2227() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
        InstanceObjectType instanceObjectType0 = (InstanceObjectType) jSTypeRegistry0.getNativeType(jSTypeNative0);
        GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
        typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, instanceObjectType0, noType0);
        noType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test2328() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.STRING_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseSyntheticCode("Not declared as a constructor", "Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeNative jSTypeNative1 = JSTypeNative.TOP_LEVEL_PROTOTYPE;
        ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative1);
        typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, objectType0, jSType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test2429() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        typeValidator0.expectSwitchMatchesCase((NodeTraversal) null, node0, objectType0, jSType0);
    }

    @Test(timeout = 4000)
    public void test2530() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.STRING_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, functionType0, jSType0);
        functionType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test2531() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.STRING_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, functionType0, jSType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test2632() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, jSType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test2733() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Attempt to remove() an extern definition.");
        ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
        ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, jSType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test2834() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Unknown class name");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf((NodeTraversal) null, node0, jSType0, jSType0, node0, "Not declared as a constructor");
    }

    @Test(timeout = 4000)
    public void test2935() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Not declared as a constructor", jSType0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, jSType0, enumType0, (Node) null, "Unknown class name");
    }

    @Test(timeout = 4000)
    public void test3036() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Not declared as a constructor", functionType0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, functionType0, enumType0, (Node) null, "Unknown class name");
    }

    @Test(timeout = 4000)
    public void test3137() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Named type with empty name component", jSType0);
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        EnumType enumType1 = jSTypeRegistry0.createEnumType("Not declared as a constructor", enumType0);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, enumType1, enumType0, node0, "Named type with empty name component");
    }

    @Test(timeout = 4000)
    public void test3138() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Named type with empty name component", jSType0);
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        EnumType enumType1 = jSTypeRegistry0.createEnumType("Not declared as a constructor", enumType0);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, enumType1, enumType0, node0, "Named type with empty name component");
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test3239() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("");
        ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
        ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, functionType0, "Unknown class name");
    }

    @Test(timeout = 4000)
    public void test3340() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, jSType0, functionType0, "Named type with empty name component");
        functionType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test3341() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, jSType0, functionType0, "Named type with empty name component");
    }

    @Test(timeout = 4000)
    public void test3442() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_FUNCTION_TYPE;
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
        GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, noType0, "Not declared as a type name");
        noType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test3443() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_FUNCTION_TYPE;
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
        GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, noType0, "Not declared as a type name");
    }

    @Test(timeout = 4000)
    public void test3544() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
        typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, node0, jSType0, jSType0, node0, 6);
        node0.isQuotedString();
    }

    @Test(timeout = 4000)
    public void test3645() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, node0, jSType0, functionType0, node0, 1);
    }

    @Test(timeout = 4000)
    public void test3746() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Unknown class name");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectCanOverride((NodeTraversal) null, node0, jSType0, jSType0, "Not declared as a type name", jSType0);
    }

    @Test(timeout = 4000)
    public void test3847() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode(" nly arrays*Or ob1ecFscan ce acce(sed", " nly arrays*Or ob1ecFscan ce acce(sed");
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
        JSType[] jSTypeArray0 = new JSType[7];
        jSTypeArray0[6] = (JSType) functionType0;
        FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) null, jSTypeArray0);
        ObjectType objectType0 = jSTypeRegistry0.createObjectType((ObjectType) functionType1);
        typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, objectType0);
    }

    @Test(timeout = 4000)
    public void test3948() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("");
        ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
        ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
        typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, functionType0);
    }

    @Test(timeout = 4000)
    public void test4049() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode(" nly \"rrays*Or ob1ecFscan ce acce(sed", " nly \"rrays*Or ob1ecFscan ce acce(sed");
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
        typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, functionType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test4150() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode(" nly \"rrays*Or ob1ecFscan ce acce(sed", " nly \"rrays*Or ob1ecFscan ce acce(sed");
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
        typeValidator0.setShouldReport(false);
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
        typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, functionType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test4251() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectCanCast(nodeTraversal0, node0, functionType0, jSType0);
        functionType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test4252() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectCanCast(nodeTraversal0, node0, functionType0, jSType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test4353() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        Denormalize denormalize0 = new Denormalize(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectCanCast(nodeTraversal0, node0, functionType0, noType0);
        noType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test4354() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        Denormalize denormalize0 = new Denormalize(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectCanCast(nodeTraversal0, node0, functionType0, noType0);
        functionType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test4455() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        Scope scope0 = new Scope(node0, noType0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Scope.Var scope_Var0 = scope0.declare("kd0R7KXL)JtA|os=\"f", node0, noType0, (CompilerInput) null, true);
        typeValidator0.expectUndeclaredVariable("<k;vjYdTDAt^gO", node0, node0, scope_Var0, "kd0R7KXL)JtA|os=\"f", noType0);
    }

    @Test(timeout = 4000)
    public void test4556() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        compiler0.parseTestCode("Unknown class name");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node0 = new Node(33);
        typeValidator0.expectUndeclaredVariable("Unknown class name", node0, node0, (Scope.Var) null, "Not declared as a type name", jSType0);
    }

    @Test(timeout = 4000)
    public void test4657() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("SBx' ", "SBx' ");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Scope scope0 = new Scope(node0, compiler0);
        Scope.Var scope_Var0 = scope0.declare("#I-", node0, (JSType) null, (CompilerInput) null);
        typeValidator0.expectUndeclaredVariable("SBx' ", node0, node0, scope_Var0, "JSC_DUP_VAR_DECLARATION", (JSType) null);
    }

    @Test(timeout = 4000)
    public void test4758() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode(" nly \"rrays*Or ob1ecFscan ce acce(sed", " nly \"rrays*Or ob1ecFscan ce acce(sed");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
        Scope scope0 = new Scope(node0, compiler0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Unknown class name", functionType0);
        EnumElementType enumElementType0 = enumType0.getElementsType();
        JSType jSType0 = enumElementType0.getPropertyType("Not declared as a type name");
        Charset charset0 = Charset.defaultCharset();
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("S63MumJVF_q[` sQ\"f", charset0);
        CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
        Scope.Var scope_Var0 = scope0.declare("EP", node0, jSType0, compilerInput0, false);
        typeValidator0.expectUndeclaredVariable("", node0, node0, scope_Var0, "S63MumJVF_q[` sQ\"f", enumElementType0);
    }

    @Test(timeout = 4000)
    public void test4859() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Unknown class name");
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("Named type with empty name component");
        CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
        Scope scope0 = new Scope(node0, noType0);
        Scope.Var scope_Var0 = scope0.declare("Named type with empty name component", node0, noType0, compilerInput0, false);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectUndeclaredVariable("Named type with empty name component", node0, node0, scope_Var0, "Not declared as a type name", (JSType) null);
    }

    @Test(timeout = 4000)
    public void test4960() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        Scope scope0 = new Scope(node0, noType0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Scope.Var scope_Var0 = scope0.declare("_nD1HOfPD", node0, noType0, (CompilerInput) null, true);
        NameReferenceGraphConstruction nameReferenceGraphConstruction0 = new NameReferenceGraphConstruction(compiler0);
        NameReferenceGraph nameReferenceGraph0 = nameReferenceGraphConstruction0.getNameReferenceGraph();
        NameReferenceGraph.Name nameReferenceGraph_Name0 = nameReferenceGraph0.WINDOW;
        UnknownType unknownType0 = (UnknownType) nameReferenceGraph_Name0.getType();
        typeValidator0.expectUndeclaredVariable("", node0, node0, scope_Var0, "", unknownType0);
        unknownType0.isConstructor();
    }

    @Test(timeout = 4000)
    public void test5061() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        Scope scope0 = new Scope(node0, noType0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node1 = new Node(118, node0, node0, node0, 7, 4095);
        Scope.Var scope_Var0 = scope0.declare("kd0R7KXL)JtA|os=\"f", node0, noType0, (CompilerInput) null, true);
        typeValidator0.expectUndeclaredVariable("<k;vjYdTDAt^gO", node1, node1, scope_Var0, "kd0R7KXL)JtA|os=\"f", noType0);
        typeValidator0.getReadableJSTypeName(node0, true);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test5162() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        Scope scope0 = new Scope(node0, noType0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node1 = new Node(118, node0, node0, node0, 7, 4095);
        Scope.Var scope_Var0 = scope0.declare("kd0R7KXL)JtA|os=\"f", node0, noType0, (CompilerInput) null, true);
        typeValidator0.expectUndeclaredVariable("kd0R7KXL)JtA|os=\"f", node0, node1, scope_Var0, "*[[2?!+4~yQ", noType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test5263() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Unknown class name");
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("Named type with empty name component");
        CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, true);
        Scope scope0 = new Scope(node0, noType0);
        Scope.Var scope_Var0 = scope0.declare("Named type with empty name component", node0, noType0, compilerInput0, true);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node1 = new Node(1, node0, 4095, 10);
        typeValidator0.expectUndeclaredVariable("Not declared as a constructor", node0, node1, scope_Var0, "Not declared as a constructor", noType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test5364() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Unknown class name");
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("Named type with empty name component");
        CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
        Scope scope0 = new Scope(node0, noType0);
        Scope.Var scope_Var0 = scope0.declare("Named type with empty name component", node0, noType0, compilerInput0, false);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node1 = new Node(130, node0, node0, node0, 34, 44);
        typeValidator0.expectUndeclaredVariable("Not declared as a constructor", node1, node1, scope_Var0, "Not declared as a constructor", noType0);
    }

    @Test(timeout = 4000)
    public void test5465() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Unknown class name");
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("Named type with empty name component");
        CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
        Scope scope0 = new Scope(node0, noType0);
        Scope.Var scope_Var0 = scope0.declare("Named type with empty name component", node0, noType0, compilerInput0, false);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node1 = new Node(130, node0, node0, node0, 34, 44);
        Vector<JSType> vector0 = new Vector<JSType>();
        FunctionType functionType0 = (FunctionType) jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) noType0, (JSType) noType0, (List<JSType>) vector0);
        typeValidator0.expectUndeclaredVariable("kI`}oOzsS", node0, node1, scope_Var0, "", functionType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test5566() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectAllInterfaceProperties((NodeTraversal) null, node0, noType0);
    }

    @Test(timeout = 4000)
    public void test5667() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("actual parameter %d of %s does not match formal parameter", "actual parameter %d of %s does not match formal parameter");
        ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
        ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.setShouldReport(false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
        typeValidator0.expectIndexMatch(nodeTraversal0, node0, functionType0, functionType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test5768() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectCanCast(nodeTraversal0, node0, jSType0, functionType0);
        functionType0.hasCachedValues();
    }

    @Test(timeout = 4000)
    public void test5769() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Denormalize denormalize0 = new Denormalize(compiler0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectCanCast(nodeTraversal0, node0, jSType0, functionType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test5870() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Not declared as a constructor");
        JSTypeNative jSTypeNative1 = JSTypeNative.ARRAY_FUNCTION_TYPE;
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative1);
        GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectCanOverride(nodeTraversal0, node0, jSType0, functionType0, "Unknown class name", jSType0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test5971() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseTestCode("Unknown class name");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node0 = new Node(33);
        Node node1 = Node.newString(45, "Unknown class name");
        node0.addChildrenToFront(node1);
        String string0 = typeValidator0.getReadableJSTypeName(node0, true);
    }

    @Test(timeout = 4000)
    public void test6072() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("~,,[QIF.L&A");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        String string0 = typeValidator0.getReadableJSTypeName(node0, false);
    }

    @Test(timeout = 4000)
    public void test6173() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("actual parameter %d of %s does not match formal parameter", "actual parameter %d of %s does not match formal parameter");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node0 = new Node(42);
        String string0 = typeValidator0.getReadableJSTypeName(node0, true);
    }

    @Test(timeout = 4000)
    public void test6274() throws Throwable {
        Compiler compiler0 = new Compiler();
        Denormalize denormalize0 = new Denormalize(compiler0);
        compiler0.parseTestCode("!");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
        boolean boolean0 = typeValidator_TypeMismatch0.equals(denormalize0);
    }

    @Test(timeout = 4000)
    public void test6375() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
        boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch0);
    }

    @Test(timeout = 4000)
    public void test6476() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(functionType0, jSType0);
        boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
    }

    @Test(timeout = 4000)
    public void test6477() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(functionType0, jSType0);
        boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
        typeValidator_TypeMismatch1.equals((Object) typeValidator_TypeMismatch0);
    }

    @Test(timeout = 4000)
    public void test6578() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(jSType0, functionType0);
        boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
    }

    @Test(timeout = 4000)
    public void test6579() throws Throwable {
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
        JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
        LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
        FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(jSType0, functionType0);
        boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
        typeValidator_TypeMismatch1.equals((Object) typeValidator_TypeMismatch0);
    }
}
