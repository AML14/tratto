/*
 * This file was automatically generated by EvoSuite
 * Sat Nov 04 06:04:49 GMT 2023
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.MemoizedScopeCreator;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.SyntheticAst;
import com.google.javascript.jscomp.TypeCheck;
import com.google.javascript.jscomp.VarCheck;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeCheck_ESTest extends TypeCheck_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test000() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = new Node(302);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test001() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = new Node(302);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test012() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "z%#GOU36^`^3=s`W;Uw");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        TypeCheck typeCheck1 = typeCheck0.reportMissingProperties(false);
    }

    @Test(timeout = 4000)
    public void test023() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "z%#GOU36^`^3=s`W;Uw");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        Node node0 = new Node(83);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (MemoizedScopeCreator) null, compilerOptions0.checkMissingReturn);
        Node node1 = Node.newString("Object#Key");
        typeCheck0.check(node1, false);
        node1.isInc();
    }

    @Test(timeout = 4000)
    public void test034() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "element {0} does not exist on this enum");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        Node node0 = new Node(5273);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(syntacticScopeCreator0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, memoizedScopeCreator0, compilerOptions0.reportMissingOverride);
        typeCheck0.processForTesting(node0, node0);
    }

    @Test(timeout = 4000)
    public void test045() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "z%#GOU36^`^3=s`W;Uw");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        Node node0 = new Node(83);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (MemoizedScopeCreator) null, compilerOptions0.checkMissingReturn);
        typeCheck0.processForTesting(node0, node0);
    }

    @Test(timeout = 4000)
    public void test056() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = new Node(1337);
        typeCheck0.processForTesting(node0, node0);
    }

    @Test(timeout = 4000)
    public void test067() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        SyntheticAst syntheticAst0 = new SyntheticAst("P#G`JlOuslIU;");
        Node node0 = syntheticAst0.getAstRoot(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test078() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = new Node(100);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(8, node0, node0, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test089() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = new Node(83);
        Node node1 = new Node(15, (-2021), 1113);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test0910() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "z%#GOU36^`^3=s`W;Uw");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        VarCheck varCheck0 = new VarCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, varCheck0);
        Node node0 = new Node(21);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test1011() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = new Node(31, 114, 4);
        typeCheck0.visit(nodeTraversal0, node0, (Node) null);
        node0.isSetterDef();
    }

    @Test(timeout = 4000)
    public void test1112() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        VarCheck varCheck0 = new VarCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, varCheck0);
        Node node0 = new Node(126);
        Node node1 = new Node(32, node0, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.isAnd();
    }

    @Test(timeout = 4000)
    public void test1213() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        VarCheck varCheck0 = new VarCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, varCheck0);
        Node node0 = new Node(34);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test1314() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("element {0} does not exist on this enum", "element {0} does not exist on this enum");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = Node.newNumber(0.0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        double double0 = typeCheck0.getTypedPercent();
    }

    @Test(timeout = 4000)
    public void test1415() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        Node node0 = new Node(139, (-3803), 111);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node1 = new Node(52, node0, node0, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.isLabelName();
    }

    @Test(timeout = 4000)
    public void test1516() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("{1} cannot extend this type; {0}s can only extend {0}s", "{1} cannot extend this type; {0}s can only extend {0}s", "Object#Key");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = new Node(302);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(55, node0, node0, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test1617() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "z%#GOU36^`^3=s`W;Uw");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        VarCheck varCheck0 = new VarCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, varCheck0);
        Node node0 = new Node(83);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (MemoizedScopeCreator) null, compilerOptions0.checkMissingReturn);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.isVar();
    }

    @Test(timeout = 4000)
    public void test1718() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        Node node0 = new Node(86);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0, compilerOptions0.checkGlobalNamesLevel);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test1819() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = new Node(90);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test1920() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = new Node(100);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.hasChildren();
    }

    @Test(timeout = 4000)
    public void test2021() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "z%#GOU36^`^3=s`W;Uw");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = new Node(104);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test2122() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = new Node(107, (-3803), 107);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test2223() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeCheck typeCheck0 = new TypeCheck(compiler0, reverseAbstractInterpreter0, jSTypeRegistry0);
        Node node0 = new Node(112);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test2324() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        VarCheck varCheck0 = new VarCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, varCheck0);
        Node node0 = new Node(119);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test2425() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = new Node(121);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test2526() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = new Node(302);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(124, 53, 29);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test2627() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Element", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0, compilerOptions0.checkGlobalNamesLevel);
        Node node0 = new Node(145, 86, 4095);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test2728() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        VarCheck varCheck0 = new VarCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, varCheck0);
        Node node0 = new Node(150);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test2829() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = new Node(302);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visitName(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test2930() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = new Node(83);
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test3031() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("Object#Key", "Object#Element");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        Node node0 = new Node(302);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        Node node1 = new Node(30, node0, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test3132() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SourceFile sourceFile0 = SourceFile.fromCode("7<BOa$7R", "7<BOa$7R");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        double double0 = typeCheck0.getTypedPercent();
    }
}
