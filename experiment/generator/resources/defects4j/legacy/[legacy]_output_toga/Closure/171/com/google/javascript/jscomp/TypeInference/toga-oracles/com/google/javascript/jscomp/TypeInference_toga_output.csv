project,bug_num,test_name,test_prefix,except_pred,assert_pred
project,0,test0000,"public void test0000() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gmj5z"", ""j_Gmj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(101, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // AND 4095 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test0011,"public void test0011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(33, node0, node0, node0, 3396, (-2376));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000709] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000710] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000711] is not a string node
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",0,
project,0,test0043,"public void test0043() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(100, 125, 128);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test0086,"public void test0086() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
    controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000709] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000710] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000711] does not have a condition.
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",0,
project,0,test0097,"public void test0097() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
    controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000709] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000710] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000711] does not have a condition.
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",0,
project,0,test0108,"public void test0108() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(4, node0, node0, node0, 48, 15);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RETURN 48 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test0119,"public void test0119() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(5, 30, 47);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 5
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test01210,"public void test01210() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(8, 56, 116);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 8
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test01311,"public void test01311() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""protoype"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""}3<^YjMW\""Nzy"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(12, 12, 2309);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EQ 12 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01412,"public void test01412() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(14, 143, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LT 143 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01513,"public void test01513() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""&"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""UNCOND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(15, 16, 46);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LE 16 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01614,"public void test01614() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(16, 16, 1);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GT 16 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01715,"public void test01715() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(18, 4046, 40);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LSH 4046 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01816,"public void test01816() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(20, 144, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // URSH 144 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test01917,"public void test01917() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(21, 119, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test02018,"public void test02018() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(27, 148, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITNOT 148 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test02119,"public void test02119() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(28, 37, (-2481));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",0,
project,0,test02220,"public void test02220() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(29, 400000, 16);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",0,
project,0,test02321,"public void test02321() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(31, 1, 49);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DELPROP 1 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test02422,"public void test02422() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""-j_Gj5z"", ""-j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(32, node0, node0, node0, 32, 46);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // TYPEOF 32 : string does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test02523,"public void test02523() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(36, 109, 108);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 36
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test02624,"public void test02624() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(37, node0, node0, node0, 15, 147);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CALL 15 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test02725,"public void test02725() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(39, 54, 4095);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Number node not created with Node.newNumber
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",0,
project,0,test02826,"public void test02826() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(""Object#Element"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // STRING Object#Element does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test02927,"public void test02927() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""UNCOND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(41, 1, 49);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NULL 1 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03028,"public void test03028() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(42, node0, node0, node0, 51, 15);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // THIS 51 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03129,"public void test03129() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Glj7z"", codingConvention_AssertionFunctionSpec0);
    Node node1 = new Node(43, 4, 144);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FALSE 4 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03230,"public void test03230() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(46, 110, 32);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SHNE 110 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03331,"public void test03331() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""q_GJ5z"", ""q_GJ5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(47, 399, 31);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // REGEXP 399 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03432,"public void test03432() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(48, 55, 31);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 48
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test03533,"public void test03533() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(49, 4095, (-2873));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // THROW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03634,"public void test03634() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(50, 4, 4);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 50
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test03735,"public void test03735() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(51, node0, node0, node0, 4, 105);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // IN 4 : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03836,"public void test03836() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Y"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInference$1"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(52, (-628), 54);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // INSTANCEOF : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test03937,"public void test03937() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""4L9BD/1(b&4<pq/%nL;"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(53, node0, node0, node0, 43, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 53
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04038,"public void test04038() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(54, 143, 31);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 54
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04139,"public void test04139() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(55, 119, 48);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 55
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04240,"public void test04240() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(56, 4095, 54);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 56
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04341,"public void test04341() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(57, 134, 12);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 57
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04442,"public void test04442() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(61, 114, 148);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 61
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04543,"public void test04543() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""cm.google;javascript.jscomp.TypeInference"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""cm.google;javascript.jscomp.TypeInference"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(65, node0, node0, node0, 4095, 65);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 65
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04644,"public void test04644() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(68, node0, node0, node0, 4095, 68);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 68
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04745,"public void test04745() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_u5"", ""j_u5"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""KeOp?+rd%q;~&rzf}"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(69, node0, node0, node0, 1483, 1068);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 69
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04846,"public void test04846() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(70, 42, 57);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 70
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test04947,"public void test04947() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(74, node0, node0, node0, 4095, 74);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 74
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test05048,"public void test05048() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInference"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(78, node0, node0, node0, 4095, 78);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 78
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test05149,"public void test05149() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""JSC_UNLISTEN_WITH_ANONBOUnD"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUnD"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(79, 118, 40);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 79
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test05250,"public void test05250() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(81, node0, node0, node0, 4095, 12);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 81
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test05351,"public void test05351() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""?ZuWgrMe"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
    TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    JSType[] jSTypeArray0 = new JSType[4];
    Node node1 = jSTypeRegistry0.createParameters(jSTypeArray0);
    // Undeclared exception!
    try {
        typeInference1.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // PARAM_LIST : ? does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test05452,"public void test05452() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(84, 2, 135);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 84
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test05553,"public void test05553() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""q_GJ5z"", ""q_GJ5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(89, 32, 1);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_BITAND 32 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test05654,"public void test05654() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_R5L"", ""j_R5L"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_R5L"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(90, 1023, 47);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_LSH 1023 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test05755,"public void test05755() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(91, 3467, 50);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_RSH 3467 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test05856,"public void test05856() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""okR|?pE+W"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(92, node0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_URSH : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test05957,"public void test05957() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(93, (-697), 400000);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test06058,"public void test06058() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(97, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_MOD 4095 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test06159,"public void test06159() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(98, (-30), 16);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test06260,"public void test06260() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(99, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 99
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test06361,"public void test06361() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(102, 150, 36);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // INC 150 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test06462,"public void test06462() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(103, node0, node0, node0, 4095, 103);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DEC 4095 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test06563,"public void test06563() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(105, node0, node0, node0, 4095, 12);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FUNCTION <invalid> 4095 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test06664,"public void test06664() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(106, node0, node0, node0, 4095, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 106
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test06765,"public void test06765() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(107, 30, 70);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 107
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test06866,"public void test06866() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference$TemplateTypeReplcer"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(109, 4095, 1017);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 109
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test06967,"public void test06967() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(110, (-2448), (-1075));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",0,
project,0,test07068,"public void test07068() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(111, 30, 47);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CASE 30 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07169,"public void test07169() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null, jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""a+"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(112, 54, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DEFAULT_CASE 54 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07270,"public void test07270() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(113, 4095, 39);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // WHILE 4095 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07371,"public void test07371() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""q_GJ5z"", ""q_GJ5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""%N~PZq<8K_$/<md"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(114, 38, (-3635));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DO does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07472,"public void test07472() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gmj5z"", ""j_Gmj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(115, 32, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FOR 32 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07573,"public void test07573() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""{>5;*)#D"", ""com.google.javascript.jscomp.CreateSyntheticBlocks"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(117, 1071, 42);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CONTINUE 1071 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07674,"public void test07674() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(118, 703, 56);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // VAR 703 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07775,"public void test07775() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""prototype"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""a3<^YjMWnN,zy"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(119, 116, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // WITH 116 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test07876,"public void test07876() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(120, node0, node0, node0, 180, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",0,
project,0,test07977,"public void test07977() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Glj7z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(121, 139, 16);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 121
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test08078,"public void test08078() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(122, 3467, 50);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // VOID 3467 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test08179,"public void test08179() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""jGE"", ""jGE"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jGE"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(123, node0, node0, node0, 52, 154);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 123
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test08280,"public void test08280() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInfrece"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInfrece"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(124, node0, node0, node0, 2, 48);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EMPTY 2 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test08381,"public void test08381() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(125, 125, 108);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BLOCK 125 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test08482,"public void test08482() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(126, 15, 128);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LABEL 15 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test08583,"public void test08583() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(127, 4095, 1);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 127
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test08684,"public void test08684() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(128, 12, 139);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 128
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test08785,"public void test08785() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.TypeInference"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(130, node0, node0, node0, 2, 48);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EXPR_RESULT 2 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test08886,"public void test08886() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(131, 38, 140);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 131
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test08987,"public void test08987() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = Scope.createGlobalScope(node0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(133, 29, 43);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 133
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09088,"public void test09088() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""protoype"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""a3<^YjMWnN,zy"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(134, node0, node0, node0, 1, 107);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 134
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09189,"public void test09189() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""t@dl=I"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""t@dl=I"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(135, node0, node0, node0, 4711, 5);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 135
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09290,"public void test09290() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(136, 617, 1841);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 136
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09391,"public void test09391() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    Node node1 = new Node(137, 759, 42);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 137
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09492,"public void test09492() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(138, 139, 4095);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 138
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09593,"public void test09593() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(139, 4095, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 139
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09694,"public void test09694() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Key"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Key"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(140, (-2553), 1);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 140
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09795,"public void test09795() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_STRING_BOOLEAN;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(141, 143, 2);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 141
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09896,"public void test09896() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""F&g+`z6%CA@J"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter$2"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(142, 51, 54);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 142
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test09997,"public void test09997() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("""", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(143, 400000, (-1614));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 143
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test10098,"public void test10098() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""jQuerySub.fn"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(144, 2138, (-3163));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 144
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test10199,"public void test10199() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""|75Zr:K_uylp}.MD2v"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""|75Zr:K_uylp}.MD2v"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(145, 48, (-1173));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 145
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test102100,"public void test102100() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = new Node(147, 52, 1119);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GETTER_DEF 52 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test103101,"public void test103101() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(148, 36, 51);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETTER_DEF 36 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test104102,"public void test104102() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(149, 151, 3);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CONST 151 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test105103,"public void test105103() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""com.google.javascript.jscomp.GlobalVarReferenceMap"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(150, (-1813), 49);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 150
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test106104,"public void test106104() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""Object#Element"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(151, 1365, 118);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 151
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test107105,"public void test107105() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager((MessageFormatter) null, logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""com.google.javascript.jscomp.TypeInference$TemplateTypeReplcer"", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    Node node1 = new Node(152, 29, 4378);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    assertNotSame(flowScope0, linkedFlowScope0);
}",0,
project,0,test108106,"public void test108106() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Glj7z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Glj7z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(154, 0, (-1553));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // STRING_KEY does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test109107,"public void test109107() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Gj5z"", ""j_Gj5z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""j_Gj5z"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""j_Gj5z"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(155, 54, 4095);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CAST 54 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test110108,"public void test110108() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""UNCOND"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createLatticeBottom(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(1931, 29, 50);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 1931
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",0,
project,0,test111109,"public void test111109() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""UNCOND"", ""UNCOND"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("""", jSTypeNative0);
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""Object#Element"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(4, 143, 52);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RETURN 143 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test112110,"public void test112110() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""j_Glj7z"", ""j_Glj7z"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""419BD/1(b&4<pq/w%nL;"");
    ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(""JSC_UNLISTEN_WITH_ANONBOUND"", codingConvention_AssertionFunctionSpec0);
    Scope scope0 = Scope.createGlobalScope(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(30, 114, 2);
    node1.addChildToFront(node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW 114 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",0,
project,0,test113111,"public void test113111() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
    assertEquals(BooleanLiteralSet.FALSE, booleanLiteralSet1);
}",0,
project,0,test114112,"public void test114112() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
    assertSame(booleanLiteralSet1, booleanLiteralSet0);
}",0,
