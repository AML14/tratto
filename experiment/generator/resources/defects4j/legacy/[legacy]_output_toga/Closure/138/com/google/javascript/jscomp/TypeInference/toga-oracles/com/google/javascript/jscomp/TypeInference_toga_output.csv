project,bug_num,test_name,test_prefix,except_pred,assert_pred
project,0,test0000,"public void test0000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(89, 89, 89);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(100, node0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // OR : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test0011,"public void test0011() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(86, 0, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test0022,"public void test0022() throws Throwable {
    Logger logger0 = Logger.getLogger(""wc.MP^5nK.NR%o-"");
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    Node node0 = compiler0.parseTestCode(""d1"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, compiler0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
    Multimap<Scope, Scope.Var> multimap0 = typeInference0.getAssignedOuterLocalVars();
    assertNotNull(multimap0);
}",0,
project,0,test0033,"public void test0033() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(33, 15, 4);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test0044,"public void test0044() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(120, 17, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test0105,"public void test0105() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(63);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
    controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ARRAYLIT : com.google.javascript.rhino.jstype.InstanceObjectType@0000000079 does not have a condition.
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",0,
project,0,test0127,"public void test0127() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
    controlFlowGraph0.connectIfNotFound((Node) null, controlFlowGraph_Branch0, (Node) null);
    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough((Node) null, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",0,
project,0,test01510,"public void test01510() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Node node0 = new Node(5);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GOTO does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test01611,"public void test01611() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 51, 123);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(6, 7, 7);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // IFEQ 7 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test01813,"public void test01813() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(8, 27, 46);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETNAME 27 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test01914,"public void test01914() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(148, 148, 148);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(9, 19, (-2624));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITOR : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02015,"public void test02015() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(148);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(10, 39, 19);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITXOR 39 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02116,"public void test02116() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-593), (-593), (-593));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(11, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITAND : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02217,"public void test02217() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(12, 21, 129);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EQ 21 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02419,"public void test02419() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(14, node0, node0, node0, 40, 33);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LT 40 : com.google.javascript.rhino.jstype.BooleanType@0000000268 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02823,"public void test02823() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.getRoot();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(19, ""+"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RSH + : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test02924,"public void test02924() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-117), (-117), (-117));
    Node node1 = new Node(20, 36, 18);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // URSH 36 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test03025,"public void test03025() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(21, node0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test03126,"public void test03126() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122, 122, 122);
    Node node1 = new Node(22, node0, node0, node0, node0, 3, 14);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SUB 3 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test03227,"public void test03227() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(99);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(23, node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // MUL : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test03328,"public void test03328() throws Throwable {
    Node node0 = new Node(74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    Node node1 = new Node(24, 7, 13);
    Stack<Scope.Var> stack0 = new Stack<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, stack0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DIV 7 : com.google.javascript.rhino.jstype.NumberType@0000000270 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test03530,"public void test03530() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 51, 123);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention) compiler0.defaultCodingConvention;
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(26);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NOT : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test03631,"public void test03631() throws Throwable {
    Node node0 = new Node(81, 81, 81);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((PrintStream) null);
    Compiler compiler0 = new Compiler(printStreamErrorManager0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(28, (-2961), 30);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test03732,"public void test03732() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(29, 42, 108);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test03833,"public void test03833() throws Throwable {
    Node node0 = new Node(122, 122, 122);
    Node node1 = new Node(30, node0, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW : com.google.javascript.rhino.jstype.NoType@0000000070 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04035,"public void test04035() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122, (-671), 122);
    Node node1 = new Node(34, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETPROP does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04136,"public void test04136() throws Throwable {
    Node node0 = new Node(74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(36, 2, 100000);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SETELEM 2 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04237,"public void test04237() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122, 123, 123);
    Node node1 = new Node(37, node0, node0, node0, node0, 34, 1);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CALL 34 : com.google.javascript.rhino.jstype.NoType@0000000064 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04338,"public void test04338() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    JSType[] jSTypeArray0 = new JSType[3];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LP : com.google.javascript.rhino.jstype.UnknownType@0000000043 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04439,"public void test04439() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node0 = Node.newString(""Invalid token: "");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // STRING Invalid token:  : com.google.javascript.rhino.jstype.StringType@0000000042 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04641,"public void test04641() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, 111);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(42, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // THIS does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04742,"public void test04742() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(43, 0, 28);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FALSE 0 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test04944,"public void test04944() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(45, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test05045,"public void test05045() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, 101, 101);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
    Node node1 = new Node(46, 16, 6);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SHNE 16 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test05146,"public void test05146() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Compiler compiler0 = new Compiler();
    CodingConvention codingConvention0 = compiler0.getCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(47, 28, 4095);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // OBJECT 28 : com.google.javascript.rhino.jstype.InstanceObjectType@0000000429 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test05247,"public void test05247() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-584), (-584), (-584));
    Node node1 = new Node(48, node0, node0, node0, node0, 33, 9);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(10);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BINDNAME 33 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test06156,"public void test06156() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(65, 0, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test06459,"public void test06459() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, 118, 68);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(68, 0, 0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // REF_CALL 0 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test06762,"public void test06762() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node0 = new Node(71, 0, 0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ESCXMLATTR 0 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test06964,"public void test06964() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(90);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(76, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // REF_NS_NAME does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test07166,"public void test07166() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-584), (-584), (-584));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, hashSet0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(79, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LB does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test07469,"public void test07469() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node0 = Node.newString(84, "".J\\;|[=|:'l\""lIF!Gk"", 114, 20);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RP .J\\;|[=|:'l\""lIF!Gk 114 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test07570,"public void test07570() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, 111);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(85, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // COMMA : com.google.javascript.rhino.jstype.UnknownType@0000000043 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test08277,"public void test08277() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope((Node) null, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node0 = new Node(95, (-1), 117);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_MUL : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test08378,"public void test08378() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(97);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_MOD : com.google.javascript.rhino.jstype.NumberType@0000000270 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test08479,"public void test08479() throws Throwable {
    Node node0 = new Node(98, 98, 98);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",0,
project,0,test08580,"public void test08580() throws Throwable {
    Node node0 = new Node(1767, 1767, 117);
    Node node1 = new Node(102, node0, node0, 91, 47);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // INC 91 : com.google.javascript.rhino.jstype.NumberType@0000000271 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test08782,"public void test08782() throws Throwable {
    Node node0 = new Node(62);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(104, 31, 4);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DOT 31 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test08984,"public void test08984() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(103, 103, 103);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    Node node1 = new Node(106, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EXPORT does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test09590,"public void test09590() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, (-5));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
    Node node1 = new Node(114, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DO does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test09792,"public void test09792() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-117), (-117), (-117));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(117, node0);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CONTINUE does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test09893,"public void test09893() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(111, 111, 111);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    Node node1 = new Node(118, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // VAR does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test09994,"public void test09994() throws Throwable {
    Node node0 = new Node(74, 74, 74);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(119, node0);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // WITH does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test10095,"public void test10095() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(51, (-60), 670);
    Node node1 = new Node(121, node0, node0, 0, 12);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FINALLY 0 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test10196,"public void test10196() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(123, 5, (-3884));
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
    assertNotSame(flowScope1, flowScope0);
}",0,
project,0,test10398,"public void test10398() throws Throwable {
    Node node0 = new Node(122, 122, 122);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = compiler0.parseTestCode(""E2{"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BLOCK [sourcename: java.lang.String@0000000461] does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",1,
project,0,test10499,"public void test10499() throws Throwable {
    Node node0 = new Node(81);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Node node1 = new Node(126, node0);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LABEL does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test108103,"public void test108103() throws Throwable {
    Node node0 = new Node(27);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(130, node0);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EXPR_RESULT does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test110105,"public void test110105() throws Throwable {
    Node node0 = new Node(1767, 1767, 117);
    Node node1 = Node.newNumber((double) 37);
    Node node2 = new Node(93, node0, node1, 89, 47);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_ADD 89 : com.google.javascript.rhino.jstype.UnknownType@0000000274 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test111106,"public void test111106() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(18, 18, 18);
    Node node1 = new Node(37, node0, node0, node0, node0, 34, 1);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    Scope scope0 = new Scope(node1, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>(4095);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CALL 34 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test112107,"public void test112107() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(148, 148, 148);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    CodingConvention codingConvention0 = compiler0.getCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(30, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test113108,"public void test113108() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(96, 96, 100);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Node node1 = new Node(30, node0);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test114109,"public void test114109() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(93, 93, 123);
    Node node1 = new Node(32);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    Stack<Scope.Var> stack0 = new Stack<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, stack0);
    Node node2 = new Node(35, node1);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GETELEM does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test115110,"public void test115110() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node((-584), (-584), (-584));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(35, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GETELEM does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test116111,"public void test116111() throws Throwable {
    Node node0 = new Node(78);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    Compiler compiler0 = new Compiler();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(100, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // OR does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test117112,"public void test117112() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(122);
    Node node1 = new Node(101, node0, node0, 1, 0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
    DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // AND 1 : com.google.javascript.rhino.jstype.VoidType@0000000045 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.LinkedDirectedGraph"", e);
    }
}",0,
project,0,test118113,"public void test118113() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(101, (-1), (-1));
    Node node1 = new Node(100, node0, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
    Scope scope0 = new Scope(node0, (ObjectType) null);
    node0.addChildToBack(node1);
    ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, arrayList0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: StackOverflowError"");
    } catch (StackOverflowError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",0,
project,0,test119114,"public void test119114() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
    assertSame(booleanLiteralSet1, booleanLiteralSet0);
}",0,
