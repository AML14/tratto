package star.tratto.oraclegrammar.custom;

import org.junit.jupiter.api.Test;
import star.tratto.oraclegrammar.trattoGrammar.Oracle;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static star.tratto.oraclegrammar.custom.Splitter.split;
import static star.tratto.TestUtilities.readOraclesFromExternalFiles;
import static star.tratto.util.StringUtils.compactExpression;

/**
 * This class actually contains integration tests since it involves not only the Splitter
 * but also the Parser and some utility functions from the StringUtils class
 */
public class SplitterTest {

    /**
     * This test is to check that, for all oracles contained in the resources files,
     * the compacted expression of the tokens generated by the Splitter matches
     * exactly the compacted expression of the original oracle. Also, for each token,
     * check that when splitting the partialExpression up to that token, the resulting
     * tokens are the same as the tokens up to that token in the oracleTokens list.
     */
    @Test
    public void splitterTest() {
        // Read oracles from external files
        List<String> stringOracles = readOraclesFromExternalFiles();

        // Instantiate Parser
        Parser parser = Parser.getInstance();

        // For each oracle, parse and split
        for (String stringOracle : stringOracles) {
            // For each oracle, we check whether the compacted expression of the tokens generated
            // by the Splitter matches exactly the compacted expression of the original oracle
            Oracle oracle = parser.getOracle(stringOracle);
            List<String> oracleTokens = split(oracle);
            assertEquals(compactExpression(stringOracle), compactExpression(oracleTokens));

            // For each token, check that when splitting the partialExpression up to that token,
            // the resulting tokens are the same as the tokens up to that token in the oracleTokens list
            for (int i = 0; i < oracleTokens.size(); i++) {
                List<String> partialExpressionTokens = oracleTokens.subList(0, i);
                List<String> splittedPartialExpressionTokens = split(parser.getPartialOracle(compactExpression(partialExpressionTokens)));
                assertEquals(partialExpressionTokens, splittedPartialExpressionTokens);
            }
        }
    }

    /**
     * This test is to check that, for all oracles contained in the resources files,
     * when splitting the oracles and reconstructing them adding spaces between tokens,
     * the resulting oracle is the same as the original oracle.
     */
    @Test
    public void handleTokenTest() {
        Parser parser = Parser.getInstance();
        List<String> stringOracles = readOraclesFromExternalFiles();

        List<String> currentOracleTokens = null;
        String currentOracleTokensConcat = null;
        String splitRejoinedOraclesTokensConcat = null;
        for (String stringOracle: stringOracles) {
            currentOracleTokens = Splitter.split(parser.getOracle(stringOracle));
            currentOracleTokensConcat = String.join(" ", currentOracleTokens);
            splitRejoinedOraclesTokensConcat = String.join(" ", Splitter.split(parser.getOracle(joinOracleTokens(currentOracleTokens))));
            assertEquals(currentOracleTokensConcat, splitRejoinedOraclesTokensConcat, "Original oracle: " + stringOracle);
        }
    }

    private String joinOracleTokens(List<String> oracleTokens) {
        StringBuilder oracle = new StringBuilder();
        for (String token: oracleTokens) {
            oracle.append(" " + token);
        }
        return oracle.toString();
    }
}
